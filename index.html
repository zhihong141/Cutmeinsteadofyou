<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- CRITICAL for Mobile: Ensures full-screen and blocks pinch-to-zoom -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cut Me Instead of You</title>
    <script src="https://cdn.tailwindcss.com">
    // Use window load event to start app safely
window.addEventListener('load', () => {
    try {
        initSequence();
    } catch (e) {
        console.error('Init failed, starting local fallback:', e);
        try {
            startLocalApp();
        } catch (_) {}
        try {
            dismissSplashScreen();
        } catch (_) {
            const splash = document.getElementById('splashScreen');
            if (splash) splash.classList.add('hidden');
        }
    }
});

    </script>
    <!-- Firebase Libraries - Simplified for Mobile Module Loading -->
    <script type="module">
        // **FIXED EXPORT:** Exposing functions directly to window object for correct access later
        try {
            const { initializeApp } = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js");
            const { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js");
            const { getFirestore, doc, getDoc, setDoc, onSnapshot, setLogLevel } = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js");

            // Set individual global variables (most robust approach outside a single JS file environment)
            window.initializeApp = initializeApp;
            window.getAuth = getAuth;
            window.signInAnonymously = signInAnonymously;
            window.signInWithCustomToken = signInWithCustomToken;
            window.onAuthStateChanged = onAuthStateChanged;
            window.getFirestore = getFirestore;
            window.doc = doc;
            window.getDoc = getDoc;
            window.setDoc = setDoc;
            window.onSnapshot = onSnapshot;
            window.setLogLevel = setLogLevel;

            window.dispatchEvent(new Event('firebase-ready'));
        } catch (e) {
            console.error("Failed to load Firebase modules.", e);
            window.dispatchEvent(new Event('firebase-ready'));
        }

    </script>
    <!-- Helper Libraries for Export and Sound -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js">// Use window load event to start app safely
window.addEventListener('load', () => {
    try {
        initSequence();
    } catch (e) {
        console.error('Init failed, starting local fallback:', e);
        try {
            startLocalApp();
        } catch (_) {}
        try {
            dismissSplashScreen();
        } catch (_) {
            const splash = document.getElementById('splashScreen');
            if (splash) splash.classList.add('hidden');
        }
    }
});

    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js">// Use window load event to start app safely
window.addEventListener('load', () => {
    try {
        initSequence();
    } catch (e) {
        console.error('Init failed, starting local fallback:', e);
        try {
            startLocalApp();
        } catch (_) {}
        try {
            dismissSplashScreen();
        } catch (_) {
            const splash = document.getElementById('splashScreen');
            if (splash) splash.classList.add('hidden');
        }
    }
});

    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js">// Use window load event to start app safely
window.addEventListener('load', () => {
    try {
        initSequence();
    } catch (e) {
        console.error('Init failed, starting local fallback:', e);
        try {
            startLocalApp();
        } catch (_) {}
        try {
            dismissSplashScreen();
        } catch (_) {
            const splash = document.getElementById('splashScreen');
            if (splash) splash.classList.add('hidden');
        }
    }
});

    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s ease-out;
            /* Prevents iOS/Android pull-to-refresh on scroll */
            overscroll-behavior-y: contain;
        }
        .canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Critical for touch drawing: blocks scrolling/zooming */
            touch-action: none;
        }
        #staticCanvas, #activeCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #activeCanvas {
            cursor: crosshair;
        }
        /* ML Meter is positioned bottom-left, optimized for thumb access */
        #mlMeterContainer {
            position: fixed;
            bottom: 24px;
            left: 24px;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            transition: background-color 0.3s, border-color 0.3s;
            cursor: pointer; /* Added cursor for quick-log interaction */
        }
        #mlPercent {
            font-weight: bold;
            font-size: 1.1rem;
            width: 75px;
            height: 75px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none;
            line-height: 1.1;
            transition: background-color 0.3s, color 0.3s;
        }
        /* Screen Shake Animation */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shaking {
            animation: shake 0.15s infinite alternate;
        }

        /* Guided Breathing Animation */
        #breathOverlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        #breathOverlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #breathCircle {
            width: 150px;
            height: 150px;
            background-color: #2dd4bf; /* Teal */
            border-radius: 50%;
            transition: transform 4s ease-in-out;
            transform: scale(0.5);
        }
        #breathText {
            font-size: 1.75rem;
            font-weight: 600;
            color: white;
            margin-top: 40px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out 0.3s;
        }
        #breathCircle.breathe-in { transform: scale(1.2); }
        #breathCircle.breathe-out { transform: scale(0.5); }
        #breathText.visible { opacity: 1; }

        /* Focus Challenge Target (Touch friendly) */
        #focusTarget {
            position: absolute;
            width: 80px; /* Increased size for touch */
            height: 80px;
            background-color: rgba(250, 204, 21, 0.8);
            border: 4px solid white;
            border-radius: 50%;
            box-shadow: 0 0 15px white;
            z-index: 120;
            transition: transform 0.5s ease-out, background-color 0.2s ease;
            cursor: pointer;
        }
        #focusTarget.success {
            background-color: rgba(74, 222, 128, 0.8);
        }

        /* Splash Screen Style */
        #splashScreen {
            position: fixed;
            inset: 0;
            background-color: #000000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 1;
            transition: opacity 1.0s ease-out;
            color: white;
            /* Allow clicks to dismiss */
            pointer-events: auto;
        }
        #splashScreen.fade-out {
            opacity: 0;
        }
        /* Email Selection Modal */
        .email-option-button {
            transition: all 0.2s;
            border-bottom: 4px solid;
        }
        /* Color overrides for email buttons */
        #emailGmail { background-color: #DB4437; border-color: #a1261d; }
        #emailGmail:hover { background-color: #c0392b; }
        #emailOutlook { background-color: #0078D4; border-color: #004b86; }
        #emailOutlook:hover { background-color: #0066c0; }
        #emailMailto { background-color: #6C757D; border-color: #495057; }
        #emailMailto:hover { background-color: #5a6268; }
    </style>
</head>
<body class="w-screen h-screen">

    <!-- === SPLASH SCREEN  === -->
    <div id="splashScreen">
        <h1 class="text-6xl sm:text-7xl font-extrabold text-white mb-4 tracking-wider">
            SEVEN.FOUR
        </h1>
        <p class="text-sm sm:text-base text-gray-400">
            &copy; 2025. A Visualization Tool.
        </p>
    </div>

    <!-- Header Bar - Mobile-First Layout -->
    <div id="header" class="fixed top-0 left-0 w-full p-4 backdrop-blur-sm z-50 shadow-2xl flex flex-col justify-start items-start space-y-3 border-b-2 border-gray-700">

        <!-- === TOP SECTION: Title and Description === -->
        <div class="w-full">
            <h1 class="font-extrabold text-3xl leading-tight tracking-tight">
                <!-- Use text-[#HEXCODE] for custom colors -->
                <span data-lang="title1" class="text-[#C23B31] block">Cut Me</span>
                <span data-lang="title2" class="text-[#F6C44F] block mt-1">Instead of You</span>
            </h1>
            <p id="headerDescription" data-lang="description" class="text-sm text-gray-400 mt-2 leading-relaxed">
                A touch tool for visualizing and managing emotional tension.
            </p>
        </div>

        <!-- === BUTTON CONTAINER - Forced 2-Column Grid (Now 2x5) === -->
        <div class="w-full grid grid-cols-2 gap-3 pt-3">

            <!-- Group 1 & 2 (Primary Actions) - KEEP LARGE -->
            <button id="modeToggleButton"
                    class="w-full py-3 text-sm font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                <span data-lang="cutMode">Cut Mode</span>
            </button>
            <button id="breathButton"
                    class="w-full py-3 text-sm font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.5 7.5a.5.5 0 00-1 0v4.586l-1.293-1.293a.5.5 0 00-.707.707l2 2a.5.5 0 00.707 0l2-2a.5.5 0 00-.707-.707L10 12.086V7.5z" clip-rule="evenodd" />
                </svg>
                <span data-lang="takeBreath">Take a Breath</span>
            </button>

            <!-- Group 3 & 4 (Coping Tools) - KEEP LARGE -->
            <button id="challengeButton"
                    class="w-full py-3 text-sm font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-4 w-4 mr-2">
                    <path d="M10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z" />
                    <path fill-rule="evenodd" d="M10 0a10 10 0 1 1 0 20 10 10 0 0 1 0-20ZM2 10a8 8 0 1 1 14.322 4.908l-2.072-2.072a3.996 3.996 0 0 0-5.83-5.83l-2.071 2.072A8 8 0 0 1 2 10Z" clip-rule="evenodd" />
                </svg>
                <span data-lang="challenge">Challenge</span>
            </button>
            <button id="affirmationsButton"
                    class="w-full py-3 text-sm font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-4 w-4 mr-2">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-5.5-2.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM10 12a5.99 5.99 0 0 0-4.793 2.39A6.483 6.483 0 0 0 10 16.5a6.483 6.483 0 0 0 4.793-2.11A5.99 5.99 0 0 0 10 12Z" clip-rule="evenodd" />
                </svg>
                <span data-lang="affirmations">Affirmations</span>
            </button>

            <!-- Group 5 & 6 (Utility/Log & Settings) - COMPACTED -->
            <button id="logButton"
                    class="w-full py-2 text-xs font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-3 w-3 mr-2">
                    <path fill-rule="evenodd" d="M2.5 4A1.5 1.5 0 0 0 1 5.5v10A1.5 1.5 0 0 0 2.5 17h15a1.5 1.5 0 0 0 1.5-1.5v-10A1.5 1.5 0 0 0 17.5 4h-15ZM10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z" clip-rule="evenodd" />
                </svg>
                <span data-lang="log">Log</span>
            </button>
            <button id="settingsButton"
                    class="w-full py-2 text-xs font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-3 w-3 mr-2">
                    <path fill-rule="evenodd" d="M11.07 2.232a.75.75 0 0 0-1.06-.03l-7.5 7.5a.75.75 0 0 0-.03 1.06l7.5 7.5a.75.75 0 1 0 1.09-1.03L4.85 10l6.25-6.22a.75.75 0 0 0-.03-1.06l-.03-.03Zm3.59 1.06a.75.75 0 0 1 0 1.06L18.15 10l-3.49 3.47a.75.75 0 1 1-1.06-1.06L16.03 10l-2.43-2.44a.75.75 0 0 1 1.06 0Z" clip-rule="evenodd" />
                </svg>
                <span data-lang="settings">Settings</span>
            </button>

            <!-- Group 7 & 8 (Undo/Clear) - COMPACTED -->
            <button id="undoButton"
                    class="w-full py-2 text-xs font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-3 w-3 mr-2">
                    <path fill-rule="evenodd" d="M15.312 11.424A7.5 7.5 0 0 1 10 18.75a8.25 8.25 0 0 1-5.34-1.928.75.75 0 0 1 .982-1.127A6.75 6.75 0 0 0 10 17.25c2.43 0 4.67-1.144 6.22-3.048h-1.077a.75.75 0 0 1 0-1.5h2.5a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-1.091Z" clip-rule="evenodd" />
                    <path fill-rule="evenodd" d="M10 2.5a8.25 8.25 0 0 1 5.34 1.928.75.75 0 0 1-.982 1.127A6.75 6.75 0 0 0 10 3.75c-2.43 0-4.67 1.144-6.22 3.048h1.077a.75.75 0 0 1 0 1.5H2.5a.75.75 0 0 1-.75-.75v-2.5a.75.75 0 0 1 1.5 0v1.091Z" clip-rule="evenodd" />
                </svg>
                <span data-lang="undo">Undo</span>
            </button>
            <button id="clearButton"
                    class="w-full py-2 text-xs font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-3 w-3 mr-2">
                    <path fill-rule="evenodd" d="M8.75 1A2.75 2.75 0 0 0 6 3.75v.443c-.795.077-1.58.275-2.316.596l-.16.079A1.75 1.75 0 0 0 2.25 6.31v5.769c0 .762.486 1.48 1.218 1.833l1.112.541a.75.75 0 0 0 .615-1.365l-1.112-.541a.25.25 0 0 1-.129-.126V6.31c0-.214.133-.395.32-.485.342-.162.7-.294 1.07-.395.093-.025.184-.047.275-.067v6.61a.75.75 0 0 0 1.5 0V3.75c0-.621.504-1.125 1.125-1.125h2.5c.621 0 1.125.504 1.125 1.125V13h-.041a.75.75 0 0 0 0 1.5h.041c.414 0 .75-.336.75-.75V3.75c0-1.517-1.233-2.75-2.75-2.75h-2.5ZM6.75 3.75v.993c.277.037.55.09.818.157V3.75h-.818ZM10 4.125V3.75h.818v1.018c.268-.067.541-.12.818-.157V3.75h-.818ZM14.75 6.25a.75.75 0 0 0-1.5 0v.5a.75.75 0 0 0 1.5 0v-.5ZM13.25 8.75a.75.75 0 0 0-1.5 0v.5a.75.75 0 0 0 1.5 0v-.5ZM11.75 11.25a.75.75 0 0 0-1.5 0v.5a.75.75 0 0 0 1.5 0v-.5Z" clip-rule="evenodd" />
                </svg>
                <span data-lang="clearAll">Clear All</span>
            </button>

            <!-- Group 9 & 10 (Theme/Info) - COMPACTED -->
            <button id="themeToggleButton"
                    class="w-full py-2 text-xs font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                <svg id="themeIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-3 w-3 mr-2">
                    <!-- Icon path set by JS -->
                </svg>
                <span id="themeText" data-lang-target="theme">Light Mode</span>
            </button>
            <button id="infoButton"
                    class="w-full py-2 text-xs font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center bg-gray-500 hover:bg-gray-600 border-gray-700 hover:border-gray-800 text-white">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-3 w-3 mr-2">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0ZM8.948 7.61a.5.5 0 0 1-.163.593L7.765 9.176a.75.75 0 0 0 0 1.148l1.02 1.02a.75.75 0 0 0 1.148 0l1.02-1.02a.5.5 0 0 1 .593.163l1.183 1.183a.75.75 0 1 0 1.06-1.06l-1.183-1.183a.5.5 0 0 1-.593-.163l-1.02-1.02a.75.75 0 0 0-1.148 0l-1.02 1.02a.75.75 0 0 0-1.148 0l-1.183-1.183a.5.5 0 0 1-.163-.593l1.183-1.183a.75.75 0 0 0-1.06-1.06Z" clip-rule="evenodd" />
                </svg>
                <span data-lang="info">Info</span>
            </button>
        </div>
    </div>

    <!-- ML Meter Display (Position remains same, perfect for thumb) -->
    <div id="mlMeterContainer">
        <div id="mlPercent"></div>
    </div>

    <!-- Canvases -->
    <div class="canvas-container">
        <canvas id="staticCanvas"></canvas>
        <canvas id="activeCanvas"></canvas>
    </div>

    <!-- Tension Red Overlay -->
    <div id="tensionOverlay" class="fixed inset-0 pointer-events-none z-40"
         style="background-color: rgba(139, 0, 0, 0); transition: background-color 0.5s ease-out;">
    </div>

    <!-- Guided Breathing Overlay -->
    <div id="breathOverlay">
        <div id="breathCircle"></div>
        <p id="breathText" data-lang="breatheIn">Breathe In...</p>
    </div>

    <!-- 100% ML Overload Modal (Uses w-full mobile-first sizing) -->
    <div id="overloadModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[130] hidden">
        <div class="bg-red-900 text-white p-6 rounded-xl shadow-2xl transition duration-300 border-4 border-red-500 w-11/12 max-w-sm space-y-4">
            <h2 class="text-2xl font-extrabold text-red-300 mb-2 border-b-2 border-red-700 pb-2" data-lang="overloadTitle">
                Mental Overload!
            </h2>
            <p class="text-red-200 font-medium text-lg" data-lang="overloadDesc">
                Your Mental Load is at 100%. Drawing is disabled.
            </p>
            <p class="text-lg font-bold text-white" data-lang="overloadInstruct">
                Please use a coping tool to relieve the tension.
            </p>
            <div class="flex flex-col space-y-3 pt-4">
                <button id="overloadBreathButton"
                        class="w-full py-3 text-base font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center bg-emerald-600 hover:bg-emerald-500 border-emerald-800 hover:border-emerald-700 text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.5 7.5a.5.5 0 00-1 0v4.586l-1.293-1.293a.5.5 0 00-.707.707l2 2a.5.5 0 00.707 0l2-2a.5.5 0 00-.707-.707L10 12.086V7.5z" clip-rule="evenodd" />
                    </svg>
                    <span data-lang="takeBreath">Take a Breath</span>
                </button>
                <button id="overloadChallengeButton"
                        class="w-full py-3 text-base font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center bg-indigo-700 hover:bg-indigo-600 border-indigo-900 hover:border-indigo-800 text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-5 w-5 mr-2">
                        <path d="M10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z" />
                        <path fill-rule="evenodd" d="M10 0a10 10 0 1 1 0 20 10 10 0 0 1 0-20ZM2 10a8 8 0 1 1 14.322 4.908l-2.072-2.072a3.996 3.996 0 0 0-5.83-5.83l-2.071 2.072A8 8 0 0 1 2 10Z" clip-rule="evenodd" />
                    </svg>
                    <span data-lang="challenge">Start a Challenge</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Quick-Log Trigger Modal (Tapping the ML Meter opens this) -->
    <div id="quickLogModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[125] hidden">
        <div class="bg-gray-800 text-white p-6 rounded-xl shadow-2xl border-4 border-gray-600 w-11/12 max-w-sm space-y-4">
            <h2 class="text-2xl font-extrabold text-blue-300 border-b-2 border-gray-700 pb-2" data-lang="quickLogTitle">
                Quick Check-in
            </h2>
            <p class="text-gray-300 text-base" data-lang="quickLogDesc">
                What triggered this moment? Logging gives you a small pause.
            </p>
            <textarea id="quickLogInput" rows="3" class="w-full p-3 border-2 border-gray-600 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-700 text-white text-base" placeholder="e.g., Felt frustrated by work, Sudden anxiety..."></textarea>
            <div class="space-y-2 pt-1">
                <p class="text-gray-200 text-sm font-semibold">Primary Emotion</p>
                <div class="flex flex-wrap gap-2">
    <button type="button"
        class="quick-emotion-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
        data-emotion="Shame">Shame</button>

    <button type="button"
        class="quick-emotion-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
        data-emotion="Anger">Anger</button>

    <button type="button"
        class="quick-emotion-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
        data-emotion="Sadness">Sadness</button>

    <button type="button"
        class="quick-emotion-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
        data-emotion="Anxiety">Anxiety</button>

    <button type="button"
        class="quick-emotion-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
        data-emotion="Emptiness">Emptiness</button>

    <button type="button"
        class="quick-emotion-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
        data-emotion="Overwhelmed">Overwhelmed</button>

                    <button type="button"
    class="quick-emotion-btn emotion-other-btn px-3 py-1 rounded-full border border-dashed border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
    data-emotion="Other">Other...</button>
</div>
            </div>
            <div class="space-y-2">
                <p class="text-gray-200 text-sm font-semibold">External Trigger</p>
                <div class="flex flex-wrap gap-2">
                    <button type="button" class="quick-trigger-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-purple-600 hover:border-purple-400" data-trigger="Relationship Conflict">Relationship Conflict</button>
                    <button type="button" class="quick-trigger-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-purple-600 hover:border-purple-400" data-trigger="Financial Stress">Financial Stress</button>
                    <button type="button" class="quick-trigger-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-purple-600 hover:border-purple-400" data-trigger="Loneliness">Loneliness</button>
                    <button type="button" class="quick-trigger-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-purple-600 hover:border-purple-400" data-trigger="Boredom">Boredom</button>
                </div>
            </div>

            <div class="flex justify-between space-x-3 pt-2">
                <button id="cancelQuickLogButton" class="py-2 px-4 bg-gray-600 hover:bg-gray-700 text-white font-semibold rounded-lg shadow border-b-4 border-gray-800 transition-all" data-lang="cancel">
                    Cancel
                </button>
                <button id="saveQuickLogButton" class="py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg shadow border-b-4 border-blue-800 transition-all" data-lang="saveQuickLog">
                    Log & Pause
                </button>
            </div>
        </div>
    </div>

    <!-- New: Positive Action Log Modal -->
    <div id="positiveActionModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[120] hidden">
        <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-green-400 w-11/12 max-w-md space-y-4">
            <h2 class="text-2xl font-extrabold text-green-700 border-b border-green-300 pb-2" data-lang="positiveActionTitle">Log Positive Action</h2>
            <p class="text-gray-600 text-base" data-lang="positiveActionDesc">Record an action you took that was positive, helpful, or neutral. This supports healthy habit building.</p>
            <textarea id="positiveActionInput" rows="4" class="w-full p-3 border-2 border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-green-500 bg-gray-50 text-gray-900 text-base" placeholder-key="positiveActionPlaceholder"></textarea>
            <div class="flex justify-end space-x-3">
                <button id="cancelPositiveActionButton" class="py-2 px-5 bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold rounded-lg shadow border-b-4 border-gray-400 hover:border-gray-300 transition-all" data-lang="cancel">
                    Cancel
                </button>
                <button id="savePositiveActionButton" class="py-2 px-5 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-lg shadow border-b-4 border-green-800 hover:border-green-700 transition-all" data-lang="save">
                    Save
                </button>
            </div>
        </div>
    </div>

<!-- Post-Relief Grounding / Check-Out Modal -->
<div id="groundingModal"
     class="fixed inset-0 bg-gray-900/80 backdrop-blur-sm flex items-center justify-center z-[150] hidden">
  <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-indigo-400 w-11/12 max-w-md space-y-4">
    <h2 class="text-2xl font-extrabold text-indigo-800 border-b-2 border-gray-200 pb-2"
        data-lang="groundingTitle">
      Grounding Check-Out
    </h2>

    <p class="text-gray-700 text-base" data-lang="groundingIntro">
      Before you head back to your day, let’s do a short grounding check-out so you leave this space feeling a bit more settled.
    </p>

    <!-- Guided 5-4-3-2-1 grounding prompt -->
    <div class="bg-indigo-50 rounded-lg p-3 space-y-1 text-sm text-gray-800">
      <p data-lang="grounding5"><span class="font-semibold">5</span> things you can see.</p>
      <p data-lang="grounding4"><span class="font-semibold">4</span> things you can touch.</p>
      <p data-lang="grounding3"><span class="font-semibold">3</span> things you can hear.</p>
      <p data-lang="grounding2"><span class="font-semibold">2</span> things you can smell.</p>
      <p data-lang="grounding1"><span class="font-semibold">1</span> thing you can taste.</p>
    </div>

    <!-- Commitment Prompt -->
    <div class="space-y-2">
      <label for="groundingCommitInput"
             class="block text-sm font-semibold text-gray-800"
             data-lang="groundingCommitLabel">
        One small action you’ll take next:
      </label>
      <textarea id="groundingCommitInput" rows="2"
        class="w-full border border-gray-300 rounded-lg p-2 text-sm focus:ring-2 focus:ring-indigo-400 focus:outline-none"
        placeholder-key="groundingCommitPlaceholder"></textarea>
      <p class="text-xs text-gray-500" data-lang="groundingExamples">
        This can be simple, like “I will stretch my shoulders”, “I will step away from my screen”, or “I will text my safety contact”.
      </p>
    </div>

    <div class="flex justify-end space-x-3">
      <button id="skipGroundingButton"
              class="px-3 py-2 text-sm rounded-lg border border-gray-300 text-gray-600 hover:bg-gray-50"
              data-lang="groundingSkip">
        Skip for now
      </button>
      <button id="confirmGroundingButton"
              class="px-4 py-2 text-sm font-semibold rounded-lg bg-indigo-600 text-white hover:bg-indigo-700"
              data-lang="groundingDone">
        Done, back to canvas
      </button>
    </div>
  </div>
</div>

    <!-- Welcome / Content Warning Modal - ADJUSTED FOR SIZE -->
    <div id="welcomeModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[125] hidden">
        <div class="bg-yellow-200 p-6 rounded-xl shadow-2xl transition duration-300 border-4 border-yellow-500 w-11/12 max-w-lg transform">
            <h2 class="text-xl font-extrabold text-gray-900 mb-4 border-b border-yellow-400 pb-2" data-lang="welcomeTitle">
                Welcome - Please Read
            </h2>
            <p class="text-gray-800 mb-4 font-medium text-base" data-lang="welcomeIntent">
                This is a tool, not a game. It's designed to be a safe alternative to help you visualize and manage overwhelming feelings.
            </p>
            <p class="text-gray-800 mb-6 font-medium text-base">
                <strong class="text-red-700" data-lang="welcomeWarning">Content Warning:</strong>
                <span data-lang="welcomeWarningText">This application contains metaphors for self-harm. If you are in crisis, please close this and use the resources below.</span>
            </p>
            <p class="text-gray-800 mb-6 font-medium text-base">
                <strong data-lang="welcomeGoal">Your Goal:</strong>
                <span data-lang="welcomeGoalText">Your goal is not to fill the screen, but to use the 'Breathe' and 'Challenge' tools to manage your 'Mental Load' (the meter at the bottom left). This is a tool for practicing relief.</span>
            </p>
            <div class="space-y-2 mb-6 text-center bg-yellow-100 p-4 rounded-lg border border-yellow-300">
                <p class="text-base font-bold text-gray-900" data-lang="welcomeCrisisTitle">Immediate Crisis Support:</p>
                <a href="https://www.iasp.info/crisis-centres/" target="_blank"
                   class="block text-lg font-extrabold text-red-600 hover:text-red-800 transition duration-150 underline decoration-2" data-lang="welcomeCrisisLink">
                    IASP International Help Finder
                </a>
                <p class="text-sm text-gray-700 mt-1" data-lang="welcomeCrisisUS">
                    (If you are in the US, dial 988)
                </p>
            </div>
            <button id="closeWelcomeModal"
                    class="mt-6 w-full py-2.5 text-sm bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold rounded-xl shadow transition duration-150 ease-in-out border-b-4 border-yellow-700 hover:border-yellow-600"
                    data-lang="welcomeUnderstand">
                I Understand
            </button>
        </div>
    </div>

    <!-- Add this new modal after the welcomeModal and before the checkinModal -->
<div id="microCheckModal" class="fixed inset-0 bg-red-900/95 backdrop-blur-sm flex items-center justify-center z-[140] hidden">
    <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-red-600 w-11/12 max-w-md space-y-4">
        <div class="bg-red-100 border-l-4 border-red-500 p-4 mb-4">
            <h3 class="text-lg font-bold text-red-800">Mental Load Alert</h3>
            <p class="text-red-700 mt-1">Your Mental Load has reached 60%. Take a moment to pause.</p>
        </div>

        <h2 class="text-2xl font-extrabold text-gray-900 border-b-2 border-gray-300 pb-3">
            Quick Self-Check
        </h2>

        <p class="text-gray-800 text-lg font-medium">
            What is one thing you can tell yourself right now about this feeling?
            <span class="block text-sm text-gray-500 mt-2">(e.g., 'This feeling is temporary')</span>
        </p>

        <textarea id="microCheckResponse" rows="3" class="w-full p-3 border-2 border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-red-500 bg-gray-50 text-gray-900 text-base" placeholder="Type your response here..."></textarea>

        <button id="submitMicroCheckButton"
                class="w-full py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow-lg transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-4 border-red-800 disabled:opacity-50 disabled:cursor-not-allowed"
                disabled>
            Continue
        </button>
    </div>
</div>

    <!-- Mental Health Check-in Modal -->
    <div id="checkinModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[100] hidden">
        <div class="bg-yellow-200 p-6 rounded-xl shadow-2xl transition duration-300 border-4 border-yellow-500 w-11/12 max-w-sm transform rotate-1">
            <h2 class="text-2xl font-extrabold text-gray-900 mb-3 border-b border-yellow-400 pb-2" data-lang="checkinTitle">Checking In...</h2>
            <p id="randomEncouragement" class="text-gray-800 mb-6 font-medium text-lg">
                <!-- Content injected by JavaScript -->
            </p>
            <p class="text-sm text-gray-700 mb-6 italic border-t border-yellow-300 pt-4" data-lang="checkinRemember">
                Remember, whatever you're going through, you don't have to face it alone. Please look up a local crisis center or hotline immediately.
            </p>
            <div class="space-y-2 mb-6 text-center">
                <p class="text-base font-bold text-gray-900" data-lang="welcomeCrisisTitle">Immediate Crisis Support:</p>
                <a href="https://www.iasp.info/crisis-centres/" target="_blank"
                   class="block text-xl font-extrabold text-red-600 hover:text-red-800 transition duration-150 underline decoration-2" data-lang="welcomeCrisisLink">
                    IASP International Help Finder
                </a>
                <p class="text-xs text-gray-700 mt-1" data-lang="welcomeCrisisUS">
                    If you are in the US, dial <strong>988</strong>. Find resources specific to your country using the link above.
                </p>
            </div>
            <button id="closeCheckinModal"
                    class="mt-6 w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold rounded-xl shadow transition duration-150 ease-in-out border-b-4 border-yellow-700 hover:border-yellow-600"
                    data-lang="checkinClose">
                I'm Okay / Close
            </button>
        </div>
    </div>
    <!-- Sensory Challenge Modal -->
    <div id="sensoryChallengeModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[110] hidden">
        <div class="bg-indigo-900 text-white p-6 rounded-xl shadow-2xl transition duration-300 border-4 border-indigo-500 w-11/12 max-w-sm space-y-4">
            <h2 class="text-2xl font-extrabold text-indigo-400 mb-2 border-b-2 border-indigo-700 pb-2" data-lang="challengeTitle">
                CRISIS: Sensory Challenge!
            </h2>
            <p class="text-indigo-200 font-medium text-lg" data-lang="challengeDesc">
                Override the urge by using an intense coping skill.
            </p>
            <div class="bg-indigo-800 p-4 rounded-lg border-2 border-indigo-500">
                <p class="text-xl font-bold text-indigo-300 mb-2" data-lang="challengeTaskTitle">Your Task:</p>
                <p id="challengeTask" class="text-2xl font-extrabold text-white italic">
                    <!-- Task injected by JavaScript -->
                </p>
            </div>
            <div class="text-center bg-gray-800 p-4 rounded-lg">
                <p class="text-lg font-semibold text-gray-300" data-lang="challengeTime">Time remaining:</p>
                <p id="challengeTimer" class="text-5xl font-extrabold text-red-500 tracking-widest">
                    --:--
                </p>
            </div>
            <p class="text-xs text-gray-400 pt-2 text-center" data-lang="challengeInstruct">
                <strong>Start the task NOW.</strong> Press the button below only when the time runs out.
            </p>
            <button id="completeChallengeButton"
                    class="mt-4 w-full py-3 text-base bg-green-700 hover:bg-green-600 text-white font-bold rounded-xl shadow-lg transition duration-150 ease-in-out opacity-50 cursor-not-allowed border-b-4 border-green-900"
                    disabled data-lang="challengeComplete">
                Complete Challenge (Wait for timer)
            </button>
            <button id="cancelChallengeButton"
                    class="w-full py-2 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow transition duration-150 ease-in-out text-sm border-b-4 border-red-800"
                    data-lang="challengeCancel">
                Cancel (I need immediate help)
            </button>
        </div>
    </div>

        <!-- ML History Log Modal - OPTIMIZED FOR MOBILE -->
    <div id="logModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[115] hidden">
        <div class="bg-white p-4 rounded-xl shadow-2xl border-4 border-gray-400 w-11/12 max-w-sm space-y-4">
            <div class="flex flex-col justify-between items-start border-b-2 border-gray-300 pb-2 space-y-2">
                <h2 class="text-xl font-extrabold text-gray-900" data-lang="logTitle">
                    Activity Log
                </h2>
                <!-- Buttons split for space and clarity -->
                <div class="flex space-x-2 w-full">
                    <button id="addLogNoteButton" class="py-2 px-3 flex-1 bg-blue-600 hover:bg-blue-700 text-white text-xs font-semibold rounded-lg shadow-md border-b-4 border-blue-800 hover:border-blue-700 transition-all transform active:translate-y-0" data-lang="logAddNote">
                        Add Note
                    </button>
                    <!-- NEW: Button for Positive Action -->
                    <button id="logPositiveActionButton" class="py-2 px-3 flex-1 bg-green-600 hover:bg-green-700 text-white text-xs font-semibold rounded-lg shadow-md border-b-4 border-green-800 hover:border-green-700 transition-all transform active:translate-y-0" data-lang="logPositiveAction">
                        Log Action
                    </button>
                </div>
            </div>
            <div id="logSummary" class="bg-gray-100 p-3 rounded-lg border border-gray-200 text-sm shadow-inner">
                <!-- Summary injected by JavaScript -->
            </div>
            <div class="max-h-40 overflow-y-auto border border-gray-300 rounded-lg shadow-md">
                <table class="w-full text-left text-xs">
                    <thead>
                        <tr class="text-gray-600 uppercase tracking-wider sticky top-0 bg-gray-50 border-b border-gray-300">
                            <th class="py-1 px-2 w-1/4" data-lang="logTime">Time</th>
                            <th class="py-1 px-2 w-1/2" data-lang="logAction">Action</th>
                            <th class="py-1 px-2 w-1/4 text-right" data-lang="logChange">ML Change</th>
                        </tr>
                    </thead>
                    <tbody id="logDetails" class="divide-y divide-gray-100">
                        <!-- Log entries injected by JavaScript -->
                    </tbody>
                </table>
            </div>
            <!-- Export Options -->
            <div>
                <h3 class="text-base font-semibold text-gray-800 mb-2" data-lang="logExportTitle">Export Session</h3>
                <div class="grid grid-cols-2 gap-2">
                    <button id="exportPdfButton" class="w-full py-2 px-2 text-xs font-medium rounded-lg shadow transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-2 bg-red-600 hover:bg-red-700 text-white border-red-800" data-lang="logExportPDF">
                        Save as PDF
                    </button>
                    <button id="exportCsvButton" class="w-full py-2 px-2 text-xs font-medium rounded-lg shadow transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-2 bg-green-600 hover:bg-green-700 text-white border-green-800" data-lang="logExportCSV">
                        Save as CSV
                    </button>
                    <button id="exportEmailButton" class="w-full py-2 px-2 text-xs font-medium rounded-lg shadow transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-2 bg-blue-600 hover:bg-blue-700 text-white border-blue-800" data-lang="logExportEmail">
                        Email Report
                    </button>
                    <button id="exportCopyButton" class="w-full py-2 px-2 text-xs font-medium rounded-lg shadow transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-2 bg-gray-600 hover:bg-gray-700 text-white border-gray-800" data-lang="logExportCopy">
                        Copy Summary
                    </button>
                </div>
            </div>
            <button id="closeLogModal"
                    class="mt-2 w-full py-2 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-xl shadow-lg transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-4 border-gray-800"
                    data-lang="close">
                Close Log
            </button>
        </div>
    </div>

    <!-- Email Selection Modal (New Element) -->
    <div id="emailSelectModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[120] hidden">
        <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-blue-400 w-11/12 max-w-md space-y-6">
            <h2 class="text-2xl font-extrabold text-gray-900 border-b-2 border-gray-300 pb-3" data-lang="emailTitle">
                Select Email Client
            </h2>
            <p class="text-gray-700 text-base" data-lang="emailDesc">
                Choose your preferred email client. The session summary will be copied to your clipboard first.
            </p>
            <div class="grid grid-cols-1 gap-3">
                <button id="emailGmail" class="email-option-button w-full py-3 text-base font-bold text-white rounded-xl shadow-md transform active:translate-y-0 active:shadow-sm">
                    Gmail
                </button>
                <button id="emailOutlook" class="email-option-button w-full py-3 text-base font-bold text-white rounded-xl shadow-md transform active:translate-y-0 active:shadow-sm">
                    Outlook / Office 365
                </button>
                <button id="emailMailto" class="email-option-button w-full py-3 text-base font-bold text-white rounded-xl shadow-md transform active:translate-y-0 active:shadow-sm">
                    Default Mail App (Apple Mail, Samsung Mail, etc.)
                </button>
            </div>
            <button id="closeEmailSelectModal"
                    class="mt-4 w-full py-3 bg-gray-400 hover:bg-gray-500 text-gray-900 font-bold rounded-xl shadow-lg border-b-4 border-gray-600 transition-all"
                    data-lang="cancel">
                Cancel
            </button>
        </div>
    </div>

    <!-- Add Note Modal -->
    <div id="addNoteModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[120] hidden">
        <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-gray-400 w-11/12 max-w-md space-y-4">
            <h2 class="text-2xl font-extrabold text-gray-900 border-b border-gray-300 pb-2" data-lang="noteTitle">Add Journal Note</h2>
            <p class="text-gray-600 text-base" data-lang="noteDesc">Add a note about what you're feeling or what triggered this moment. It will be saved in your log.</p>
            <textarea id="noteInput" rows="4" class="w-full p-3 border-2 border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-50 text-gray-900 text-base" placeholder-key="notePlaceholder"></textarea>
            <div class="space-y-2 pt-1">
                <p class="text-gray-700 text-sm font-semibold">Primary Emotion</p>
                <div class="flex flex-wrap gap-2">
    <button type="button"
        class="note-emotion-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
        data-emotion="Shame">Shame</button>

    <button type="button"
        class="note-emotion-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
        data-emotion="Anger">Anger</button>

    <button type="button"
        class="note-emotion-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
        data-emotion="Sadness">Sadness</button>

    <button type="button"
        class="note-emotion-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
        data-emotion="Anxiety">Anxiety</button>

    <button type="button"
        class="note-emotion-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
        data-emotion="Emptiness">Emptiness</button>

    <button type="button"
        class="note-emotion-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
        data-emotion="Overwhelmed">Overwhelmed</button>

                    <button type="button"
    class="note-emotion-btn emotion-other-btn px-3 py-1 rounded-full border border-dashed border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
    data-emotion="Other">Other...</button>
</div>
            </div>
            <div class="space-y-2">
                <p class="text-gray-700 text-sm font-semibold">External Trigger</p>
                <div class="flex flex-wrap gap-2">
                    <button type="button" class="note-trigger-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-purple-100 hover:border-purple-500" data-trigger="Relationship Conflict">Relationship Conflict</button>
                    <button type="button" class="note-trigger-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-purple-100 hover:border-purple-500" data-trigger="Financial Stress">Financial Stress</button>
                    <button type="button" class="note-trigger-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-purple-100 hover:border-purple-500" data-trigger="Loneliness">Loneliness</button>
                    <button type="button" class="note-trigger-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-purple-100 hover:border-purple-500" data-trigger="Boredom">Boredom</button>
                </div>
            </div>

            <div class="flex justify-end space-x-3">
                <button id="cancelNoteButton" class="py-2 px-5 bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold rounded-lg shadow border-b-4 border-gray-400 hover:border-gray-300 transition-all" data-lang="cancel">
                    Cancel
                </button>
                <button id="saveNoteButton" class="py-2 px-5 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg shadow border-b-4 border-blue-800 hover:border-blue-700 transition-all" data-lang="save">
                    Save
                </button>
            </div>
        </div>
    </div>

    <!-- Affirmations Modal -->
    <div id="affirmationsModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[115] hidden">
        <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-gray-400 w-11/12 max-w-lg space-y-6">
            <h2 class="text-2xl font-extrabold text-gray-900 border-b-2 border-gray-300 pb-3" data-lang="affirmTitle">
                Personalized Affirmations
            </h2>
            <p class="text-gray-600 text-base" data-lang="affirmDesc">
                Add personalized affirmations that will appear during your check-ins. These words of encouragement can help you through difficult moments.
            </p>

            <!-- Add New Affirmation -->
            <div class="flex space-x-3">
                <input type="text" id="affirmationInput" placeholder-key="affirmPlaceholder" class="flex-grow p-3 border-2 border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-teal-500 bg-gray-50 text-gray-900 text-base">
                <button id="addAffirmationButton" class="py-2 px-5 bg-teal-600 hover:bg-teal-700 text-white font-semibold rounded-lg shadow border-b-4 border-teal-800 hover:border-teal-700 transition-all" data-lang="add">
                    Add
                </button>
            </div>

            <!-- Prioritize Checkbox -->
            <div class="flex items-center space-x-3 bg-gray-100 p-3 rounded-lg border border-gray-200">
                <input type="checkbox" id="prioritizeAffirmations" class="w-5 h-5 text-teal-600 rounded border-gray-300 focus:ring-teal-500">
                <label for="prioritizeAffirmations" class="font-medium text-gray-700 text-base" data-lang="affirmPrioritize">
                    Prioritize my affirmations during high tension moments
                </label>
            </div>

            <!-- Saved Affirmations List -->
            <div class="max-h-60 overflow-y-auto border border-gray-300 rounded-lg shadow-md p-2 space-y-2 bg-gray-50">
                <ul id="affirmationsList" class="divide-y divide-gray-200">
                    <!-- Affirmations will be injected here -->
                </ul>
            </div>

            <div class="flex justify-between">
                <button id="clearAffirmationsButton" class="py-2 px-4 bg-red-600 hover:bg-red-700 text-white text-sm font-semibold rounded-lg shadow border-b-4 border-red-800 hover:border-red-700 transition-all" data-lang="affirmClear">
                    Clear All
                </button>
                <button id="closeAffirmationsModal" class="py-2 px-5 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-xl shadow-lg border-b-4 border-gray-800 transition-all" data-lang="close">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[115] hidden">
        <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-gray-400 w-11/12 max-w-md space-y-6">
            <h2 class="text-2xl font-extrabold text-gray-900 border-b-2 border-gray-300 pb-3" data-lang="settingsTitle">
                Settings
            </h2>

            <!-- Language Settings -->
            <div class="space-y-2">
                <label for="languageSelector" class="font-semibold text-gray-700 text-base" data-lang="settingsLang">Language / Bahasa:</label>
                <select id="languageSelector" class="w-full p-3 border-2 border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-50 text-gray-900 text-base">
                    <option value="en">English</option>
                    <option value="ms">Bahasa Melayu</option>
                    <option value="zh">简体中文 (Simplified Chinese)</option>
                    <option value="ta">தமிழ் (Tamil)</option>
                </select>
            </div>

            <!-- Visual Settings -->
            <div class="space-y-4 pt-4 border-t border-gray-200">
                <h3 class="text-xl font-bold text-gray-800" data-lang="settingsVisual">Visual Settings</h3>
                <div class="flex items-center justify-between bg-gray-100 p-3 rounded-lg border border-gray-200">
                    <label for="toggleDrips" class="font-medium text-gray-700 text-base" data-lang="settingsDrips">
                        Enable Drip & Pool Effects
                    </label>
                    <input type="checkbox" id="toggleDrips" class="w-6 h-6 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                </div>
                <div class="flex items-center justify-between bg-gray-100 p-3 rounded-lg border border-gray-200">
                    <label for="toggleShake" class="font-medium text-gray-700 text-base" data-lang="settingsShake">
                        Enable Tension Screen Shake
                    </label>
                    <input type="checkbox" id="toggleShake" class="w-6 h-6 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                </div>
            </div>

            <!-- Haptic Settings -->
            <div class="space-y-4 pt-4 border-t border-gray-200">
                <h3 class="text-xl font-bold text-gray-800" data-lang="settingsHaptic">Haptic Feedback</h3>
                <label for="hapticIntensitySlider" class="font-medium text-gray-700 text-base block" data-lang="hapticIntensity">
                    Intensity: <span id="hapticIntensityValue">50%</span>
                </label>
                <input type="range" id="hapticIntensitySlider" min="0" max="100" value="50" step="10"
                       class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                <p class="text-sm text-gray-500 italic" data-lang="hapticNote">Set to 0% to disable all vibrations.</p>
            </div>

            <button id="closeSettingsModal"
                    class="mt-6 w-full py-3 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-xl shadow-lg transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-4 border-gray-800"
                    data-lang="close">
                Close
            </button>
        </div>
    </div>

    <!-- One-time "Heal Metaphor" Notification -->
    <div id="healNotification" class="fixed bottom-24 right-6 bg-green-600 text-white p-4 rounded-xl shadow-2xl border-4 border-green-400 w-11/12 max-w-sm z-[100] hidden transition-all duration-300 transform translate-x-full">
        <h3 class="font-bold text-lg" data-lang="healNotifyTitle">Cut Healed!</h3>
        <p class="text-sm" data-lang="healNotifyDesc">
            Notice the 'Mental Load' didn't change? That's intentional. Healing is the first step. Now, use 'Breathe' or 'Challenge' to relieve the underlying tension.
        </p>
    </div>

    <!-- Notification Box for "Copied" -->
    <div id="notificationBox" class="fixed bottom-24 right-6 bg-blue-600 text-white py-3 px-5 rounded-xl shadow-2xl z-[100] hidden transition-all duration-300 transform translate-x-full">
        <p id="notificationText" class="font-semibold"></p>
    </div>

    <!-- Main Application Logic -->
    <script type="module">
        // === Firebase Imports ===
        // IMPORTANT: In this version, the Firebase libraries are exposed directly to the window in the first script tag.
        // We reference them here as global variables, which resolves the 'initializeApp is not a function' error.
        const { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, getFirestore, doc, getDoc, setDoc, onSnapshot, setLogLevel } = window;


        // === App State ===
        let appState = {
            currentML: 0,
            cuts: [],
            healLines: [],
            history: [],
            mlHistory: [],
            userAffirmations: [],
            settings: {
                language: 'en',
                prioritizeAffirmations: false,
                enableDrips: true,
                enableShake: true,
                hapticIntensity: 50, // NEW: Haptic Intensity (0-100)
            },
            hasWelcomed: false,
            hasHealedOnce: false,
            // NEW STREAK STATE
            lastActivityDay: null,
            currentStreak: 0
        };

        // === Constants ===
        const STATIC_SFX_VOLUME = 0.7; // Fixed volume for cuts/heals
        const STATIC_BREATH_VOLUME = 0.5; // Fixed volume for breath
        // Removed HAPTIC_ENABLED_INTERNAL, now controlled by appState.settings.hapticIntensity
        const QUICK_LOG_ML_RELIEF = 1000; // 1000 ML (2.0 ml in display) relief for quick log.
        const POSITIVE_ACTION_ML_RELIEF = 500; // Small relief for logging positive action

        // === Local State & DOM Refs ===
        let isDrawing = false;
        let startPoint = null;
        let endPoint = null;
        let currentStrokePoints = [];
        let activeDrips = [];
        let lastTime = 0;
        let strokeIdCounter = 0;
        let isHealMode = false;
        let strokesSinceLastPrompt = 0;
        let isReliefActive = false;
        let reliefMLDrained = 0;
        let isChallengeActive = false;
        let isGroundingActive = false;
        let challengeTimerInterval = null;
        let focusTarget = null;
        let focusTimer = null;
        let focusTimeElapsed = 0;
        let currentTheme = 'dark';
        let breathInterval = null;
        let breathState = 0;
        let audioMuted = true;
        let saveTimeout = null;
        let isSaving = false;
        let db, auth, userId;
        let unsubscribe;
        let isFirebaseReady = false;
        let cutSynth, healSynth, breathNoise, breathFilter;
        let splashTimerId = null;
let isMicroCheckActive = false;
let microCheckRequired = false;
let microCheckCompleted = false;
let microCheckCooldownActive = false;
let mlDripPaused = false;

        // Configuration Constants
        const MAX_CUTS_BEFORE_PROMPT = 5;
        const MAX_PERMANENT_CUTS = 5;
        const LINE_COLOR = '#8B0000';
        const DRIP_COLOR = '#8B0000';
        const POOL_CENTER_OFFSET = 4;
        const SEGMENTS = 50;
        const MAX_CUT_WIDTH = 6;
        const TRAIL_WIDTH_MAX = 4;
        const TRAIL_JAGGED_OFFSET = 1.5;
        const HEAL_COLOR = '#FFD700';
        const HEAL_WIDTH = 5;
        const HEAL_GLOW_COLOR = '#FFA500';
        const MAX_ML = 50000;
        const ML_DISPLAY_FACTOR = 500;
        const PRESERVE_TENSION_ON_CUT_HEAL = true;
        const ML_ACCUMULATION_MULTIPLIER = 2.0;
        const BASE_DRIP_COOLDOWN_MS = 6000;
        const MIN_DRIP_COOLDOWN_MS = 1000;
        const BASE_DRIP_ACCELERATION = 0.00004;
        const MAX_DRIP_ACCELERATION = 0.0001;
        const DRIP_INITIAL_SPEED = 0.006;
        let globalLastDripTime = 0;
        const MIN_GLOBAL_DELAY_MAX = 500;
        const MIN_GLOBAL_DELAY_MIN = 100;
        const HEALING_RADIUS = 150;
        const MIN_HEAL_STROKES = 2;
        const MAX_HEAL_STROKES = 4;
        const RELIEF_PER_SECOND = 4000;
        const SHAKE_THRESHOLD = 0.7;
        const MAX_RED_OPACITY = 0.25;
        const CHALLENGE_TIME_SECONDS = 60;
        const ML_REDUCTION_PER_CHALLENGE = 20000;
        const FOCUS_CHALLENGE_DURATION = 15000;
        const DEBOUNCE_SAVE_MS = 2000;
        const FIREBASE_TIMEOUT_MS = 3000;


        // === DOM Elements ===
        const staticCanvas = document.getElementById('staticCanvas');
        const staticCtx = staticCanvas.getContext('2d');
        const activeCanvas = document.getElementById('activeCanvas');
        const activeCtx = activeCanvas.getContext('2d');
        const headerEl = document.getElementById('header');
        const headerDescriptionEl = document.getElementById('headerDescription');
        const clearButton = document.getElementById('clearButton');
        const undoButton = document.getElementById('undoButton');
        const breathButton = document.getElementById('breathButton');
        const modeToggleButton = document.getElementById('modeToggleButton');
        const challengeButton = document.getElementById('challengeButton');
        const affirmationsButton = document.getElementById('affirmationsButton');
        const logButton = document.getElementById('logButton');
        const settingsButton = document.getElementById('settingsButton');
        const infoButton = document.getElementById('infoButton');
        const themeToggleButton = document.getElementById('themeToggleButton');
        const themeIconEl = document.getElementById('themeIcon');
        const themeTextEl = document.getElementById('themeText');
        const mlMeterContainerEl = document.getElementById('mlMeterContainer');
        const mlPercentEl = document.getElementById('mlPercent');
        const tensionOverlay = document.getElementById('tensionOverlay');
        const breathOverlay = document.getElementById('breathOverlay');
        const breathCircle = document.getElementById('breathCircle');
        const breathText = document.getElementById('breathText');
        const welcomeModal = document.getElementById('welcomeModal');
        const closeWelcomeModal = document.getElementById('closeWelcomeModal');
        const checkinModal = document.getElementById('checkinModal');
        const closeCheckinModal = document.getElementById('closeCheckinModal');
        const randomEncouragementEl = document.getElementById('randomEncouragement');
        const sensoryChallengeModal = document.getElementById('sensoryChallengeModal');
        const challengeTaskEl = document.getElementById('challengeTask');
        const challengeTimerEl = document.getElementById('challengeTimer');
        const completeChallengeButton = document.getElementById('completeChallengeButton');
        const cancelChallengeButton = document.getElementById('cancelChallengeButton');
        const logModal = document.getElementById('logModal');
        const closeLogModal = document.getElementById('closeLogModal');
        const logSummaryEl = document.getElementById('logSummary');
        const logDetailsEl = document.getElementById('logDetails');
        const addLogNoteButton = document.getElementById('addLogNoteButton');
        const exportPdfButton = document.getElementById('exportPdfButton');
        const exportCsvButton = document.getElementById('exportCsvButton');
        const exportEmailButton = document.getElementById('exportEmailButton');
        const exportCopyButton = document.getElementById('exportCopyButton');
        const emailSelectModal = document.getElementById('emailSelectModal');
        const closeEmailSelectModal = document.getElementById('closeEmailSelectModal');
        const emailGmailButton = document.getElementById('emailGmail');
        const emailOutlookButton = document.getElementById('emailOutlook');
        const emailMailtoButton = document.getElementById('emailMailto');
        const addNoteModal = document.getElementById('addNoteModal');
        const noteInput = document.getElementById('noteInput');
        const saveNoteButton = document.getElementById('saveNoteButton');
        const cancelNoteButton = document.getElementById('cancelNoteButton');
        const affirmationsModal = document.getElementById('affirmationsModal');
        const affirmationInput = document.getElementById('affirmationInput');
        const addAffirmationButton = document.getElementById('addAffirmationButton');
        const prioritizeAffirmations = document.getElementById('prioritizeAffirmations');
        const affirmationsList = document.getElementById('affirmationsList');
        const clearAffirmationsButton = document.getElementById('clearAffirmationsButton');
        const closeAffirmationsModal = document.getElementById('closeAffirmationsModal');
        const settingsModal = document.getElementById('settingsModal');
        const languageSelector = document.getElementById('languageSelector');
        const toggleDrips = document.getElementById('toggleDrips');
        const toggleShake = document.getElementById('toggleShake');
        const closeSettingsModal = document.getElementById('closeSettingsModal');
        const healNotification = document.getElementById('healNotification');
const notificationBox = document.getElementById('notificationBox');
const notificationText = document.getElementById('notificationText');
const overloadModal = document.getElementById('overloadModal');
const overloadBreathButton = document.getElementById('overloadBreathButton');
const overloadChallengeButton = document.getElementById('overloadChallengeButton');
const splashScreen = document.getElementById('splashScreen');

// NEW for micro-check
const microCheckModal = document.getElementById('microCheckModal');
const microCheckResponse = document.getElementById('microCheckResponse');
const submitMicroCheckButton = document.getElementById('submitMicroCheckButton');
// Enable / disable the "Continue" button based on typing
if (microCheckResponse && submitMicroCheckButton) {
    submitMicroCheckButton.disabled = true; // start disabled
    microCheckResponse.addEventListener('input', () => {
        const hasText = microCheckResponse.value.trim().length > 0;
        submitMicroCheckButton.disabled = !hasText;
    });
}

        // Quick Log Modal Elements
        const quickLogModal = document.getElementById('quickLogModal');
        const quickLogInput = document.getElementById('quickLogInput');
        const saveQuickLogButton = document.getElementById('saveQuickLogButton');
        const cancelQuickLogButton = document.getElementById('cancelQuickLogButton');

        // Positive Action Modal Elements
        const positiveActionModal = document.getElementById('positiveActionModal');
        const logPositiveActionButton = document.getElementById('logPositiveActionButton');
        const positiveActionInput = document.getElementById('positiveActionInput');
        const savePositiveActionButton = document.getElementById('savePositiveActionButton');
        const cancelPositiveActionButton = document.getElementById('cancelPositiveActionButton');

// Grounding / Check-Out Modal Elements
const groundingModal = document.getElementById('groundingModal');
const groundingCommitInput = document.getElementById('groundingCommitInput');
const skipGroundingButton = document.getElementById('skipGroundingButton');
const confirmGroundingButton = document.getElementById('confirmGroundingButton');

        // New Haptic Slider Elements
        const hapticIntensitySlider = document.getElementById('hapticIntensitySlider');
        const hapticIntensityValue = document.getElementById('hapticIntensityValue');


        // === Theme Configuration (Simplified from original) ===
        const THEMES = {
            dark: {
                bodyBg: '#111827', headerBg: 'bg-gray-900/95', headerText: 'text-white',
                headerDescText: 'text-gray-400', headerBorder: 'border-gray-700',
                meterBg: '#2D3748', meterInnerBg: '#1F2937', meterBorder: '#1F2937',
                modalBg: 'bg-gray-900/90', cutHealText: 'text-white', breathText: 'text-white',
                challengeText: 'text-white', affirmText: 'text-white', themeText: 'text-white',
                logText: 'text-white', settingsText: 'text-white', undoText: 'text-white',
                clearText: 'text-white', infoText: 'text-white',
                themeBg: 'bg-blue-600', themeHover: 'hover:bg-blue-500', themeBorder: 'border-blue-800',
                themeBorderHover: 'hover:border-blue-700',
                logBg: 'bg-purple-600', logHover: 'hover:bg-purple-500', logBorder: 'border-purple-800',
                logBorderHover: 'hover:border-purple-700', settingsBg: 'bg-gray-600', settingsHover: 'hover:bg-gray-500',
                settingsBorder: 'border-gray-800', settingsBorderHover: 'hover:border-gray-700', undoBg: 'bg-gray-600',
                undoHover: 'hover:bg-gray-500', undoBorder: 'border-gray-800', undoBorderHover: 'hover:border-gray-700',
                clearBg: 'bg-gray-600', clearHover: 'hover:bg-gray-500', clearBorder: 'border-gray-800',
                clearBorderHover: 'hover:border-gray-700',
                infoBg: 'bg-gray-500', infoHover: 'hover:bg-gray-600', infoBorder: 'border-gray-700',
                infoBorderHover: 'hover:border-gray-800',
                canvasBg: '#111827',
                iconPath: '<path d="M7.75 4A2.75 2.75 0 0 1 10.5 6.75v10.5a.75.75 0 0 0 1.5 0V6.75a4.25 4.25 0 0 0-8.5 0v10.5a.75.75 0 0 0 1.5 0V6.75A2.75 2.75 0 0 1 7.75 4Z" />',
                modeName: 'themeDark'
            },
            light: {
                bodyBg: '#F3F4F6', headerBg: 'bg-white/95', headerText: 'text-gray-900',
                headerDescText: 'text-gray-600', headerBorder: 'border-gray-300',
                meterBg: '#D1D5DB', meterInnerBg: '#F9FAFB', meterBorder: '#E5E7EB',
                modalBg: 'bg-white/90', cutHealText: 'text-white', breathText: 'text-white',
                challengeText: 'text-white', affirmText: 'text-white', themeText: 'text-white',
                logText: 'text-white', settingsText: 'text-gray-900', undoText: 'text-gray-900',
                clearText: 'text-gray-900', infoText: 'text-white',
                themeBg: 'bg-blue-600', themeHover: 'hover:bg-blue-500', themeBorder: 'border-blue-800',
                themeBorderHover: 'hover:border-blue-700',
                logBg: 'bg-purple-600', logHover: 'hover:bg-purple-500', logBorder: 'border-purple-800',
                logBorderHover: 'hover:border-purple-700', settingsBg: 'bg-white', settingsHover: 'hover:bg-gray-50',
                settingsBorder: 'border-gray-300', settingsBorderHover: 'hover:border-gray-400', undoBg: 'bg-white',
                undoHover: 'hover:bg-gray-50', undoBorder: 'border-gray-300', undoBorderHover: 'hover:border-gray-400',
                clearBg: 'bg-white', clearHover: 'hover:bg-gray-50', clearBorder: 'border-gray-300',
                clearBorderHover: 'hover:border-gray-400',
                infoBg: 'bg-gray-500', infoHover: 'hover:bg-gray-600', infoBorder: 'border-gray-700',
                infoBorderHover: 'hover:border-gray-800',
                canvasBg: '#F3F4F6',
                iconPath: '<path fill-rule="evenodd" d="M10 2a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0v-1.5A.75.75 0 0 1 10 2Zm6.28 12.78a.75.75 0 0 0-1.06-1.06l-1.06 1.06a.75.75 0 0 0 1.06 1.06l1.06-1.06ZM3.72 14.72a.75.75 0 0 0 1.06 1.06l-1.06 1.06a.75.75 0 0 0-1.06-1.06l1.06 1.06ZM16.03 5.97a.75.75 0 0 0-1.06-1.06l-1.06 1.06a.75.75 0 0 0 1.06 1.06l1.06-1.06ZM5.94 4.66a.75.75 0 0 0 1.06-1.06L5.94 2.54a.75.75 0 0 0-1.06 1.06l1.06 1.06ZM10 18a.75.75 0 0 1-.75-.75v-1.5a.75.75 0 0 1 1.5 0v1.5a.75.75 0 0 1-.75-.75ZM6.75 10a3.25 3.25 0 1 1 6.5 0 3.25 3.25 0 0 1-6.5 0Z" clip-rule="evenodd" />',
                modeName: 'theme'
            }
        };

        // === Translation Data ===
        const translations = {
            en: {
                title1: "Cut Me", title2: "Instead of You", description: "A touch tool for visualizing and managing emotional tension.",
                cutMode: "Cut Mode", healMode: "Heal Mode (Draw Light)", takeBreath: "Take a Breath", challenge: "Challenge",
                affirmations: "Affirmations", theme: "Light Mode", themeDark: "Dark Mode", log: "Log", info: "Info",
                emailTitle: "Select Email Client", emailDesc: "Choose your preferred email client. The session summary will be copied to your clipboard first.",
                settings: "Settings", undo: "Undo", clearAll: "Clear All", breatheIn: "Breathe In...",
                breatheHold: "Hold...", breatheOut: "Breathe Out...", overloadTitle: "Mental Overload!",
                overloadDesc: "Your Mental Load is at 100%. Drawing is disabled.", overloadInstruct: "Please use a coping tool to relieve the tension.",
                welcomeTitle: "Welcome - Please Read", welcomeIntent: "This is a tool, not a game. It's designed to be a safe alternative to help you visualize and manage overwhelming feelings.",
                welcomeWarning: "Content Warning:", welcomeWarningText: "This application contains metaphors for self-harm. If you are in crisis, please close this and use the resources below.",
                welcomeGoal: "Your Goal:", welcomeGoalText: "Your goal is not to fill the screen, but to use the 'Breathe' and 'Challenge' tools to manage your 'Mental Load' (the meter at the bottom left). This is a tool for practicing relief.",
                welcomeCrisisTitle: "Immediate Crisis Support:", welcomeCrisisLink: "IASP International Help Finder", welcomeCrisisUS: "(If you are in the US, dial 988)",
                welcomeUnderstand: "I Understand", checkinTitle: "Checking In...", checkinRemember: "Remember, whatever you're going through, you don't have to face it alone. Please look up a local crisis center or hotline immediately.",
                checkinClose: "I'm Okay / Close", challengeTitle: "CRISIS: Sensory Challenge!", challengeDesc: "Override the urge by using an intense coping skill.",
                challengeTaskTitle: "Your Task:", challengeTime: "Time remaining:", challengeInstruct: "Start the task NOW. Press the button below only when the time runs out.",
                challengeComplete: "Complete Challenge (Wait for timer)", challengeCancel: "Cancel (I need immediate help)", challengeFocus: "Keep your finger inside the moving target for 15 seconds.",
                logTitle: "Activity Log", logAddNote: "Add Note", logTime: "Time", logAction: "Action", logChange: "ML Change",
                logExportTitle: "Export Session", logExportPDF: "Save as PDF Report", logExportCSV: "Save as CSV Data", logExportEmail: "Email to Professional",
                logExportCopy: "Copy Session Summary", logSummaryAccumulation: "Accumulation (Drips):", logSummaryRelief: "Relief (Breaths/Challenges/Undos):",
                logSummaryNet: "Net Change:", logDrips: "drips", logRelief: "Relief", logChallenges: "Challenges", logUndos: "Undos",
                logActionCut: "Cut Drip (Accumulation)", logActionBreath: "Breath (Relief)", logActionChallenge: "Challenge (Relief)",
                logActionUndo: "Undo Cut (Relief)", logActionReset: "Full Reset (Relief)", logActionNote: "Journal Note", logActionQuick: "Quick Log (Relief)",
                logStreak: "Current Streak: {count} Day(s)",
                noteTitle: "Add Journal Note", noteDesc: "Add a note about what you're feeling or what triggered this moment. It will be saved in your log.",
                notePlaceholder: "e.g., 'Felt overwhelmed after class,' 'Argument with family'", affirmTitle: "Personalized Affirmations",
                affirmDesc: "Add personalized affirmations that will appear during your check-ins. These words of encouragement can help you through difficult moments.",
                affirmPlaceholder: "e.g., 'I am safe in this moment.'", affirmPrioritize: "Prioritize my affirmations during high tension moments",
                affirmClear: "Clear All", affirmRemove: "Remove", settingsTitle: "Settings", settingsLang: "Language / Bahasa:",
                settingsVisual: "Visual Settings", settingsDrips: "Enable Drip & Pool Effects", settingsShake: "Enable Tension Screen Shake",
                settingsAudio: "Audio Settings",
                settingsHaptic: "Haptic Feedback", // NEW
                hapticIntensity: "Intensity:", // NEW
                hapticNote: "Set to 0% to disable all vibrations.", // NEW
                close: "Close", save: "Save", cancel: "Cancel", add: "Add", notifyCopied: "Copied to clipboard!",
                notifyEmail: "Copied! Now paste into your email.", healNotifyTitle: "Cut Healed!",
                healNotifyDesc: "Notice the 'Mental Load' didn't change? That's intentional. Healing is the first step. Now, use 'Breathe' or 'Challenge' to relieve the underlying tension.",
                quickLogTitle: "Quick Check-in", quickLogDesc: "What triggered this moment? Logging gives you a small pause.",
                saveQuickLog: "Log & Pause",
                positiveActionTitle: "Log Positive Action",
                positiveActionDesc: "Record an action you took that was positive, helpful, or neutral. This supports healthy habit building.",
                positiveActionPlaceholder: "e.g., 'Took a 10 min walk,' 'Drank water,' 'Called a friend'",
                logPositiveAction: "Log Action",
                logActionPositive: "Positive Action (Relief)",
                groundingTitle: "Grounding Check-Out",
groundingIntro: "Before you head back to your day, let’s do a short grounding check-out so you leave this space feeling a bit more settled.",
grounding5: "5 things you can see.",
grounding4: "4 things you can touch.",
grounding3: "3 things you can hear.",
grounding2: "2 things you can smell.",
grounding1: "1 thing you can taste.",
groundingCommitLabel: "One small action you’ll take next:",
groundingCommitPlaceholder: "I will drink a glass of water.",
groundingExamples: "This can be simple, like “I will stretch my shoulders”, “I will step away from my screen”, or “I will text my safety contact”.",
groundingSkip: "Skip for now",
groundingDone: "Done, back to canvas"          // NO comma here (last key)
            },
            ms: {
                title1: "Lukaiku", title2: "Gantimu", description: "Alat sentuhan untuk memvisualisasikan dan menguruskan ketegangan emosi.",
                cutMode: "Mod Luka", healMode: "Mod Pulih (Cahaya)", takeBreath: "Tarik Nafas", challenge: "Cabaran",
                affirmations: "Afirmasi", theme: "Mod Cerah", themeDark: "Mod Gelap", log: "Log", info: "Maklumat",
                emailTitle: "Pilih Klien E-mel", emailDesc: "Pilih klien e-mel pilihan anda. Ringkasan sesi akan disalin ke papan keratan anda dahulu.",
                settings: "Tetapan", undo: "Buat Asal", clearAll: "Padam Semua", breatheIn: "Tarik Nafas...",
                breatheHold: "Tahan...", breatheOut: "Hembus Nafas...", overloadTitle: "Beban Mental Penuh!",
                overloadDesc: "Beban Mental anda sudah 100%. Lukisan dilumpuhkan.", overloadInstruct: "Sila guna alat daya tindak untuk melegakan ketegangan.",
                welcomeTitle: "Selamat Datang - Sila Baca", welcomeIntent: "Ini adalah alat, bukan permainan. Ia direka sebagai alternatif selamat untuk membantu anda memvisualisasikan dan menguruskan perasaan yang terbeban.",
                welcomeWarning: "Amaran Kandungan:", welcomeWarningText: "Aplikasi ini mengandungi metafora untuk mencederakan diri. Jika anda dalam krisis, sila tutup dan guna sumber di bawah.",
                welcomeGoal: "Matlamat Anda:", welcomeGoalText: "Matlamat anda bukan untuk mengisi skrin, tetapi untuk menggunakan alat 'Nafas' dan 'Cabaran' untuk menguruskan 'Beban Mental' anda (meter di kiri bawah). Ini adalah alat untuk berlatih kelegaan.",
                welcomeCrisisTitle: "Sokongan Krisis Segera:", welcomeCrisisLink: "Pencari Bantuan Antarabangsa IASP", welcomeCrisisUS: "(Jika anda di AS, dail 988)",
                welcomeUnderstand: "Saya Faham", checkinTitle: "Daftar Masuk...", checkinRemember: "Ingat, apa jua yang anda lalui, anda tidak perlu menghadapinya seorang diri. Sila cari pusat krisis atau talian hotline tempatan dengan segera.",
                checkinClose: "Saya OK / Tutup", challengeTitle: "KRISIS: Cabaran Deria!", challengeDesc: "Atasi desakan dengan menggunakan kemahiran daya tindak yang intensif.",
                challengeTaskTitle: "Tugas Anda:", challengeTime: "Masa berbaki:", challengeInstruct: "Mulakan tugas SEKARANG. Tekan butang di bawah hanya apabila masa tamat.",
                challengeComplete: "Selesai Cabaran (Tunggu pemasa)", challengeCancel: "Batal (Saya perlukan bantuan segera)", challengeFocus: "Kekalkan jari anda di dalam sasaran bergerak selama 15 saat.",
                logTitle: "Log Aktiviti", logAddNote: "Tambah Nota", logTime: "Masa", logAction: "Tindakan", logChange: "Perubahan BM",
                logExportTitle: "Eksport Sesi", logExportPDF: "Simpan sebagai Laporan PDF", logExportCSV: "Simpan sebagai Data CSV", logExportEmail: "E-mel kepada Profesional",
                logExportCopy: "Salin Ringkasan Sesi", logSummaryAccumulation: "Pengumpulan (Titisan):", logSummaryRelief: "Kelegaan (Nafas/Cabaran/Buat Asal):",
                logSummaryNet: "Perubahan Bersih:", logDrips: "titisan", logRelief: "Kelegaan", logChallenges: "Cabaran", logUndos: "Buat Asal",
                logActionCut: "Titisan Luka (Pengumpulan)", logActionBreath: "Nafas (Kelegaan)", logActionChallenge: "Cabaran (Kelegaan)",
                logActionUndo: "Buat Asal Luka (Kelegaan)", logActionReset: "Set Semula Penuh (Kelegaan)", logActionNote: "Nota Jurnal", logActionQuick: "Log Cepat (Kelegaan)",
                logStreak: "Siri Semasa: {count} Hari", // NEW STREAK KEY
                noteTitle: "Tambah Nota Jurnal", noteDesc: "Tambah nota tentang apa yang anda rasa atau apa yang mencetuskan detik ini. Ia akan disimpan dalam log anda.",
                notePlaceholder: "cth., 'Rasa terbeban selepas kelas,' 'Bergaduh dengan keluarga'", affirmTitle: "Afirmasi Peribadi",
                affirmDesc: "Tambah afirmasi peribadi yang akan muncul semasa daftar masuk anda. Kata-kata semangat ini boleh membantu anda melalui detik sukar.",
                affirmPlaceholder: "cth., 'Saya selamat pada masa ini.'", affirmPrioritize: "Utamakan afirmasi saya semasa detik ketegangan tinggi",
                affirmClear: "Padam Semua", affirmRemove: "Padam", settingsTitle: "Tetapan", settingsLang: "Bahasa / Language:",
                settingsVisual: "Tetapan Visual", settingsDrips: "Aktifkan Kesan Titisan & Kolam", settingsShake: "Aktifkan Getaran Skrin Ketegangan",
                settingsAudio: "Tetapan Audio", // NEW
                settingsHaptic: "Maklum Balas Haptik", // NEW
                hapticIntensity: "Keamatan:", // NEW
                hapticNote: "Tetapkan kepada 0% untuk melumpuhkan semua getaran.", // NEW
                close: "Tutup", save: "Simpan", cancel: "Batal", add: "Tambah", notifyCopied: "Disalin ke papan keratan!",
                notifyEmail: "Disalin! Sekarang tampal ke dalam e-mel anda.", healNotifyTitle: "Luka Dipulih!",
                healNotifyDesc: "Perasan 'Beban Mental' tidak berubah? Itu sengaja. Pemulihan adalah langkah pertama. Sekarang, guna 'Nafas' atau 'Cabaran' untuk melegakan ketegangan yang masih ada.",
                quickLogTitle: "Daftar Masuk Cepat", quickLogDesc: "Apa yang mencetuskan detik ini? Log masuk memberi anda jeda kecil.",
                saveQuickLog: "Log Masuk & Jeda",
                positiveActionTitle: "Log Tindakan Positif",
                positiveActionDesc: "Catatkan tindakan yang anda ambil yang positif, membantu, atau neutral. Ini menyokong pembinaan tabiat sihat.",
                positiveActionPlaceholder: "cth., 'Berjalan 10 minit,' 'Minum air,' 'Hubungi rakan'",
                logPositiveAction: "Log Tindakan",
                logActionPositive: "Tindakan Positif (Kelegaan)",
                groundingTitle: "Semakan Grounding",
groundingIntro: "Sebelum anda kembali meneruskan hari anda, mari kita buat semakan grounding yang ringkas supaya anda meninggalkan ruang ini dengan rasa sedikit lebih tenang.",
grounding5: "5 perkara yang anda boleh lihat.",
grounding4: "4 perkara yang anda boleh sentuh.",
grounding3: "3 perkara yang anda boleh dengar.",
grounding2: "2 perkara yang anda boleh bau.",
grounding1: "1 perkara yang anda boleh rasa di mulut.",
groundingCommitLabel: "Satu tindakan kecil yang akan anda lakukan selepas ini:",
groundingCommitPlaceholder: "Saya akan minum segelas air.",
groundingExamples: "Ini boleh jadi sangat mudah, seperti \"Saya akan regangkan bahu\", \"Saya akan menjauh sekejap dari skrin\", atau \"Saya akan mesej orang sokongan saya\".",
groundingSkip: "Langkau dahulu",
groundingDone: "Selesai, kembali ke kanvas"
            },
            zh: {
                title1: "割我", title2: "代你", description: "一个可视化和管理情绪压力的触摸工具。",
                cutMode: "切割模式", healMode: "治愈模式 (绘制光)", takeBreath: "深呼吸", challenge: "挑战",
                affirmations: "自我肯定", theme: "浅色模式", themeDark: "深色模式", log: "日志", info: "信息",
                emailTitle: "选择电子邮件客户端", emailDesc: "选择您首选的电子邮件客户端。会话摘要将首先复制到您的剪贴板。",
                settings: "设置", undo: "撤销", clearAll: "全部清除", breatheIn: "吸气...",
                breatheHold: "屏住...", breatheOut: "呼气...", overloadTitle: "精神超负荷！",
                overloadDesc: "您的精神负荷已达100%。绘图功能已禁用。", overloadInstruct: "请使用应对工具来缓解压力。",
                welcomeTitle: "欢迎 - 请阅读", welcomeIntent: "这是一个工具，不是一个游戏。它旨在作为一个安全的替代品，帮助您将压倒性的感觉可视化并进行管理。",
                welcomeWarning: "内容警告：", welcomeWarningText: "此应用程序包含自我伤害的比喻。如果您正处于危机之中，请关闭此应用并使用以下资源。",
                welcomeGoal: "您的目标：", welcomeGoalText: "您的目标不是填满屏幕，而是使用“呼吸”和“挑战”工具来管理您的“精神负荷”（左下角的仪表）。这是一个练习缓解的工具。",
                welcomeCrisisTitle: "即时危机支持：", welcomeCrisisLink: "IASP 国际帮助查找器", welcomeCrisisUS: "（如果您在美国，请拨打 988）",
                welcomeUnderstand: "我明白了", checkinTitle: "签到中...", checkinRemember: "请记住，无论您正在经历什么，您都不必独自面对。请立即查找当地的危机中心或热线。",
                checkinClose: "我没事 / 关闭", challengeTitle: "危机：感官挑战！", challengeDesc: "通过使用强烈的应对技巧来克服冲动。",
                challengeTaskTitle: "您的任务：", challengeTime: "剩余时间：", challengeInstruct: "立即开始任务。仅在时间耗尽时才按下面的按钮。",
                challengeComplete: "完成挑战（等待计时器）", challengeCancel: "取消（我需要立即帮助）", challengeFocus: "将您的手指保持在移动目标内 15 秒。",
                logTitle: "活动日志", logAddNote: "添加备注", logTime: "时间", logAction: "操作", logChange: "精神负荷变化",
                logExportTitle: "导出会话", logExportPDF: "另存为 PDF 报告", logExportCSV: "另存为 CSV 数据", logExportEmail: "发送给专业人士",
                logExportCopy: "复制会话摘要", logSummaryAccumulation: "积累（滴落）：", logSummaryRelief: "缓解（呼吸/挑战/撤销）：",
                logSummaryNet: "净变化：", logDrips: "次滴落", logRelief: "次缓解", logChallenges: "次挑战", logUndos: "次撤销",
                logActionCut: "切割滴落（积累）", logActionBreath: "呼吸（缓解）", logActionChallenge: "挑战（缓解）",
                logActionUndo: "撤销切割（缓解）", logActionReset: "完全重置（缓解）", logActionNote: "日记备注", logActionQuick: "快速记录（缓解）",
                logStreak: "当前连续天数：{count} 天", // NEW STREAK KEY
                noteTitle: "添加日记备注", noteDesc: "添加一条关于您的感受或触发此事件的备注。它将保存在您的日志中。",
                notePlaceholder: "例如，'下课后感到不堪重负'，'与家人争吵'", affirmTitle: "个性化肯定",
                affirmDesc: "添加将在您签到时出现的个性化肯定。这些鼓励的话语可以帮助您度过困难时刻。",
                affirmPlaceholder: "例如，'在这一刻，我是安全的。'", affirmPrioritize: "在精神紧张时优先显示我的肯定",
                affirmClear: "全部清除", affirmRemove: "移除", settingsTitle: "设置", settingsLang: "语言 / Language:",
                settingsVisual: "视觉设置", settingsDrips: "启用滴落和水池效果", settingsShake: "启用压力屏幕抖动",
                settingsAudio: "音频设置", // NEW
                settingsHaptic: "触觉反馈", // NEW
                hapticIntensity: "强度:", // NEW
                hapticNote: "设置为 0% 以禁用所有振动。", // NEW
                close: "关闭", save: "保存", cancel: "取消", add: "添加", notifyCopied: "已复制到剪贴板！",
                notifyEmail: "已复制！现在粘贴到您的电子邮件中。", healNotifyTitle: "伤口已治愈！",
                healNotifyDesc: "注意到“精神负荷”没有改变吗？这是故意的。治愈是第一步。现在，使用“呼吸”或“挑战”来缓解潜在的压力。",
                quickLogTitle: "快速记录", quickLogDesc: "什么触发了这一刻？记录可以给您一个小小的停顿。",
                saveQuickLog: "记录并停顿",
                positiveActionTitle: "记录积极行动",
                positiveActionDesc: "记录您采取的积极、有帮助或中立的行动。这有助于建立健康的习惯。",
                positiveActionPlaceholder: "例如，'散步 10 分钟'，'喝水'，'给朋友打电话'",
                logPositiveAction: "记录行动",
                logActionPositive: "积极行动（缓解）",
                groundingTitle: "稳定收尾练习",
groundingIntro: "在你回到日常生活之前，让我们做一个简短的稳定练习，让你带着稍微平稳一点的状态离开这个空间。",
grounding5: "说出你看到的 5 样东西。",
grounding4: "说出你可以触碰的 4 样东西。",
grounding3: "说出你听到的 3 种声音。",
grounding2: "说出你闻到的 2 种气味。",
grounding1: "说出你可以尝到的 1 种味道。",
groundingCommitLabel: "接下来你会做的一件小事：",
groundingCommitPlaceholder: "我要喝一杯水。",
groundingExamples: "可以很简单，例如“我会伸展一下肩膀”、“我会先离开屏幕一会儿”，或“我会给我的安全联系人发讯息”。",
groundingSkip: "暂时跳过",
groundingDone: "完成，回到画布"
            },
            ta: {
                title1: "வெட்டு", title2: "உனக்குப் பதிலாக", description: "உணர்ச்சிவசமான பதற்றத்தைக் காட்சிப்படுத்தவும் நிர்வகிக்கவும் ஒரு தொடு கருவி.",
                cutMode: "வெட்டு முறை", healMode: "குணப்படுத்தும் முறை (ஒளி)", takeBreath: "மூச்சு விடுங்கள்", challenge: "சவால்",
                affirmations: "உறுதிமொழிகள்", theme: "ஒளி முறை", themeDark: "இருண்ட முறை", log: "பதிவு", info: "தகவல்",
                emailTitle: "மின்னஞ்சல் கிளையண்டைத் தேர்ந்தெடுக்கவும்", emailDesc: "உங்களுக்குப் பிடித்த மின்னஞ்சல் கிளையண்டைத் தேர்ந்தெடுக்கவும். அமர்வுச் சுருக்கம் முதலில் உங்கள் கிளிப்போர்டுக்கு நகலெடுக்கப்படும்.",
                settings: "அமைப்புகள்", undo: "செயல்தவிர்", clearAll: "அனைத்தையும் அழி", breatheIn: "மூச்சை உள்ளிழு...",
                breatheHold: "நிறுத்து...", breatheOut: "மூச்சை வெளிவிடு...", overloadTitle: "மன சுமை அதிகம்!",
                overloadDesc: "உங்கள் மன சுமை 100% ஆக உள்ளது. வரைதல் முடக்கப்பட்டது.", overloadInstruct: "பதற்றத்தைக் குறைக்க, சமாளிக்கும் கருவிகளில் ஒன்றைப் பயன்படுத்தவும்.",
                welcomeTitle: "சுவாகதம் - தயவுசெய்து படிக்கவும்",
                welcomeIntent: "இது ஒரு கருவி, விளையாட்டல்ல. தாங்க முடியாத உணர்வுகளைக் காட்சிப்படுத்தவும் நிர்வகிக்கவும் உதவும் பாதுகாப்பான மாற்றாக இது வடிவமைக்கப்பட்டுள்ளது.",
                welcomeWarning: "உள்ளடக்க எச்சரிக்கை:", welcomeWarningText: "இந்தப் பயன்பாட்டில் சுய-தீங்குக்கான உருவகங்கள் உள்ளன. நீங்கள் நெருக்கடியில் இருந்தால், தயவுசெய்து இதை மூடிவிட்டு கீழே உள்ள வளங்களைப் பயன்படுத்தவும்.",
                welcomeGoal: "உங்கள் இலக்கு:", welcomeGoalText: "உங்கள் இலக்கு திரையை நிரப்புவதல்ல, மாறாக 'மூச்சு' மற்றும் 'சவால்' கருவிகளைப் பயன்படுத்தி உங்கள் 'மனச் சுமையை' (கீழே இடதுபுறத்தில் உள்ள அளவி) நிர்வகிப்பதாகும். இது நிவாரணம் பயிற்சி செய்வதற்கான ஒரு கருவி.",
                welcomeCrisisTitle: "உடனடி நெருக்கடி ஆதரவு:", welcomeCrisisLink: "IASP சர்வதேச உதவி தேடல்", welcomeCrisisUS: "(நீங்கள் அமெரிக்காவில் இருந்தால், 988 ஐ அழைக்கவும்)",
                welcomeUnderstand: "நான் புரிந்துகொள்கிறேன்", checkinTitle: "சரிபார்க்கப்படுகிறது...", checkinRemember: "நினைவில் கொள்ளுங்கள், நீங்கள் எதைச் சந்தித்தாலும், அதைத் தனியாக எதிர்கொள்ள வேண்டியதில்லை. தயவுசெய்து உள்ளூர் நெருக்கடி மையத்தையோ அல்லது ஹாட்லைனையோ உடனடியாகத் தேடுங்கள்.",
                checkinClose: "நான் நலமாக உள்ளேன் / மூடு", challengeTitle: "நெருக்கடி: உணர்ச்சி சவால்!", challengeDesc: "தீவிரமான சமாளிப்புத் திறனைப் பயன்படுத்தி உந்துதலை மீறுங்கள்.",
                challengeTaskTitle: "உங்கள் பணி:", challengeTime: "மீதமுள்ள நேரம்:", challengeInstruct: "இப்போதே பணியைத் தொடங்குங்கள். நேரம் முடிந்ததும் மட்டுமே கீழே உள்ள பொத்தானை அழுத்தவும்.",
                challengeComplete: "சவாலை முடிக்கவும் (டைமருக்காகக் காத்திருக்கவும்)", challengeCancel: "ரத்துசெய் (எனக்கு உடனடி உதவி தேவை)", challengeFocus: "உங்கள் விரலை நகரும் இலக்கின் உள்ளே 15 வினாடிகள் வைத்திருக்கவும்.",
                logTitle: "செயல்பாட்டு பதிவு", logAddNote: "குறிப்பு சேர்", logTime: "நேரம்", logAction: "செயல்", logChange: "மன சுமை மாற்றம்",
                logExportTitle: "அமர்வை ஏற்றுமதி செய்",
                logExportPDF: "PDF அறிக்கையாகச் சேமி",
                logExportCSV: "CSV தரவாகச் சேமி",
                logExportEmail: "நிபுணருக்கு மின்னஞ்சல் அனுப்பு",
                logExportCopy: "அமர்வுச் சுருக்கத்தை நகலெடு",
                logSummaryAccumulation: "திரள் (சொட்டுகள்):",
                logSummaryRelief: "நிவாரணம் (மூச்சுகள்/சவால்கள்/செயல்தவிர்):",
                logSummaryNet: "நிகர மாற்றம்:",
                logDrips: "சொட்டுகள்", logRelief: "நிவாரணம்", logChallenges: "சவால்கள்", logUndos: "செயல்தவிர்",
                logActionCut: "வெட்டுச் சொட்டு (திரள்)", logActionBreath: "மூச்சு (நிவாரணம்)", logActionChallenge: "சவால் (நிவாரணம்)",
                logActionUndo: "வெட்டை செயல்தவிர் (நிவாரணம்)", logActionReset: "முழு மீட்டமைப்பு (நிவாரணம்)", logActionNote: "பத்திரிகை குறிப்பு", logActionQuick: "விரைவுப் பதிவு (நிவாரணம்)",
                logStreak: "தற்போதைய தொடர்ச்சியான நாட்கள்: {count} நாள்(கள்)", // NEW STREAK KEY
                noteTitle: "பத்திரிகைக் குறிப்பைச் சேர்", noteDesc: "நீங்கள் என்ன உணர்கிறீர்கள் அல்லது இந்தத் தருணத்தைத் தூண்டியது என்ன என்பது பற்றிய ஒரு குறிப்பைச் சேர்க்கவும். இது உங்கள் பதிவில் சேமிக்கப்படும்.",
                notePlaceholder: "எ.கா., 'வகுப்பிற்குப் பிறகு சோர்வாக உணர்ந்தேன்,' 'குடும்பத்துடன் சண்டை'", affirmTitle: "தனிப்பயனாக்கப்பட்ட உறுதிமொழிகள்",
                affirmDesc: "உங்கள் சரிபார்ப்புகளின் போது தோன்றும் தனிப்பயனாக்கப்பட்ட உறுதிமொழிகளைச் சேர்க்கவும். இந்த ஊக்கமளிக்கும் வார்த்தைகள் கடினமான தருணங்களைக் கடக்க உதவும்.",
                affirmPlaceholder: "எ.கா., 'நான் இந்தத் தருணத்தில் பாதுகாப்பாக இருக்கிறேன்.'",
                affirmPrioritize: "அதிக பதற்றம் உள்ள தருணங்களில் எனது உறுதிமொழிகளுக்கு முன்னுரிமை கொடு",
                affirmClear: "அனைத்தையும் அழி", affirmRemove: "நீக்கு", settingsTitle: "அமைப்புகள்", settingsLang: "மொழி / Language:",
                settingsVisual: "காட்சி அமைப்புகள்", settingsDrips: "சொட்டு & குளம் விளைவுகளை இயக்கு", settingsShake: "பதற்றம் திரை நடுக்கத்தை இயக்கு",
                settingsAudio: "ஆடியோ அமைப்புகள்", // NEW
                settingsHaptic: "தொட்டுணர்ச்சி கருத்து", // NEW
                hapticIntensity: "தீவிரம்:", // NEW
                hapticNote: "அனைத்து அதிர்வுகளையும் முடக்க 0% என அமைக்கவும்.", // NEW
                close: "மூடு", save: "சேமி", cancel: "ரத்துசெய்", add: "சேர்", notifyCopied: "கிளிப்போர்டுக்கு நகலெடுக்கப்பட்டது!",
                notifyEmail: "நகலெடுக்கப்பட்டது! இப்போது உங்கள் மின்னஞ்சலில் ஒட்டவும்.", healNotifyTitle: "காயம் குணமாகியது!",
                healNotifyDesc: "திரையை நிரப்புவது உங்கள் இலக்கு அல்ல, ஆனால் 'மூச்சு' மற்றும் 'சவால்' கருவிகளைப் பயன்படுத்தி உங்கள் 'மனச் சுமையை' (கீழே இடதுபுறத்தில் உள்ள அளவி) நிர்வகிப்பதாகும். இது நிவாரணம் பயிற்சி செய்வதற்கான ஒரு கருவி.",
                groundingTitle: "நிலைப்படுத்தும் நிறைவு (Grounding Check-out)",
groundingIntro: "உங்கள் நாளுக்குத் திரும்புவதற்கு முன், ஒரு சிறிய நிலைப்படுத்தும் பயிற்சியை செய்து, கொஞ்சம் அமைதியான நிலையுடன் இந்த இடத்தை விட்டு செல்லலாம்.",
grounding5: "நீங்கள் பார்க்கக்கூடிய 5 விஷயங்களை குறிப்பிடுங்கள்.",
grounding4: "நீங்கள் தொடக்கூடிய 4 விஷயங்களை குறிப்பிடுங்கள்.",
grounding3: "நீங்கள் கேட்கக்கூடிய 3 ஒலிகளை குறிப்பிடுங்கள்.",
grounding2: "நீங்கள் மணக்கக்கூடிய 2 மணங்களை குறிப்பிடுங்கள்.",
grounding1: "நீங்கள் சுவைக்கக்கூடிய 1 சுவையை குறிப்பிடுங்கள்.",
groundingCommitLabel: "அடுத்ததாக நீங்கள் செய்யும் ஒரு சிறிய செயல்:",
groundingCommitPlaceholder: "நான் ஒரு டம்ளர் தண்ணீர் குடிப்பேன்.",
groundingExamples: "இது மிகவும் எளிமையானதாக இருக்கலாம்; உதாரணத்திற்கு \"நான் தோள்களை சிறிது நீட்டி பார்க்கிறேன்\", \"நான் சில நிமிடங்கள் திரையிலிருந்து விலகுகிறேன்\", அல்லது \"என் பாதுகாப்பு நபருக்கு ஒரு செய்தி அனுப்புகிறேன்\" போன்றவை.",
groundingSkip: "இப்போதைக்கு தவிர்க்கவும்",
groundingDone: "முடிந்தது, கன்வாசுக்கு திரும்ப"
            }
        };

        // === Encouraging Messages & Challenges (kept from original) ===
        const encouragingMessages = [
            "This moment is just one part of your journey, and it's okay if today feels heavy. Just try to focus on taking the next small, gentle step forward. Your strength isn't about getting through everything perfectly, but about continuing to show up for yourself, even when it's hard. You've got this.",
            "Please remember that you are worthy of kindness and support, especially from yourself. The feelings you have are valid, but they don't define your entire future. There are people who care deeply about you and want to help carry this weight. Reach out—connection is always available.",
            "The most difficult feelings are temporary, even if they feel overwhelming right now. You are resilient, and is light waiting for you just beyond this moment. Give yourself permission to pause, breathe, and simply wait for the intensity to pass. Hold on just a little longer.",
            "A setback isn't a failure, it's just a reminder that you're human. Be gentle with yourself today. Focus on tiny victories: a glass of water, a deep breath, or a moment of quiet. You are doing the best you can with what you have, and that is more than enough."
        ];
        const SENSORY_CHALLENGES = [
            "Go find 5 ice cubes and hold them tightly in your hands until they melt completely.",
            "Splash your face with ice-cold water 5 times. (Tightly hold your breath during the splash!)",
            "Put a piece of lemon or strong sour candy in your mouth for 30 seconds. Focus only on the taste.",
            "Find a strong scent (peppermint oil, vinegar, or perfume) and breathe it in deeply for 5 breaths.",
            "Do 1 minutes of intense exercise (jumping jacks, running in place) until you feel physically tired.",
            "Take a rubber band (or hair tie) and snap it lightly on your wrist 10 times. (Safe discomfort only!)",
            "focus_challenge"
        ];

        // =================================================================
        // CORE UTILITY FUNCTIONS (Defined first to solve ReferenceErrors)
        // =================================================================

        // Function to format a date to YYYY-MM-DD (Used for streak tracking)
        function formatDate(date) {
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // NEW STREAK LOGIC
        function checkAndUpdateStreak() {
            const now = new Date();
            const todayStr = formatDate(now);

            // Check if activity was already logged today (only updates streak if it's a new day's first action)
            if (appState.lastActivityDay === todayStr) {
                return;
            }

            const lastActivity = appState.lastActivityDay;

            // Calculate yesterday's date string
            const yesterday = new Date(now);
            yesterday.setDate(now.getDate() - 1);
            const yesterdayStr = formatDate(yesterday);

            if (lastActivity === yesterdayStr) {
                // Streak continues
                appState.currentStreak = (appState.currentStreak || 0) + 1;
            } else if (lastActivity) {
                // Streak broken (last activity was before yesterday)
                appState.currentStreak = 1;
            } else {
                 // First time logging ever
                 appState.currentStreak = 1;
            }

            appState.lastActivityDay = todayStr;
            triggerSave();
        }

        function getTranslation(key) {
            return translations[appState.settings.language][key] || translations['en'][key];
        }

        function updateLanguage(lang) {
            if (!translations[lang]) lang = 'en';
            appState.settings.language = lang;

            document.querySelectorAll('[data-lang]').forEach(el => {
                const key = el.getAttribute('data-lang');
                if (translations[lang][key]) {
                    el.textContent = translations[lang][key];
                }
            });

            document.querySelectorAll('[data-lang-target]').forEach(el => {
                const themeKey = THEMES[currentTheme].modeName;
                el.textContent = translations[lang][themeKey];
            });

             document.querySelectorAll('[placeholder-key]').forEach(el => {
                const key = el.getAttribute('placeholder-key');
                if (translations[lang][key]) {
                    el.placeholder = translations[lang][key];
                }
            });

            // Update dynamic content
            updateMeterDisplay();
            // Check if log modal is open and update it
            if (!logModal.classList.contains('hidden')) {
                updateLogModal();
            }
            // Update the affirmations list immediately to ensure correct placeholder language
            updateAffirmationsList();
        }

        function drawTaperedCutSegments(ctxToUse, cut) {
            const points = cut.smoothPoints;
            if (points.length < 2) return;
            const progress = cut.currentHealStrokes / cut.requiredHealStrokes;
            ctxToUse.globalAlpha = Math.max(0.1, 1.0 - progress);
            ctxToUse.strokeStyle = LINE_COLOR;
            ctxToUse.lineCap = 'round';
            ctxToUse.lineJoin = 'round';
            ctxToUse.shadowBlur = 0;
            const totalSegments = points.length - 1;
            for (let i = 0; i < totalSegments; i++) {
                const t = i / totalSegments;
                const width = MAX_CUT_WIDTH * 4 * t * (1 - t);
                ctxToUse.beginPath();
                ctxToUse.moveTo(points[i].x, points[i].y);
                ctxToUse.lineTo(points[i + 1].x, points[i + 1].y);
                ctxToUse.lineWidth = width;
                ctxToUse.stroke();
            }
        }

        function drawHealLineSegments(ctxToUse, healLine) {
            const points = healLine.points;
            if (!points || points.length < 2) return;
            ctxToUse.strokeStyle = HEAL_COLOR;
            ctxToUse.lineWidth = HEAL_WIDTH;
            ctxToUse.lineCap = 'round';
            ctxToUse.lineJoin = 'round';
            ctxToUse.shadowColor = HEAL_GLOW_COLOR;
            ctxToUse.shadowBlur = 10;
            ctxToUse.globalAlpha = 1.0;
            ctxToUse.beginPath();
            ctxToUse.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctxToUse.lineTo(points[i].x, points[i].y);
            }
            ctxToUse.stroke();
            ctxToUse.shadowBlur = 0;
        }

        function drawDripPool(x, y) {
            if (!appState.settings.enableDrips) return;
            staticCtx.fillStyle = `rgba(128, 0, 0, 0.7)`;
            staticCtx.beginPath();
            staticCtx.ellipse(x, y, 4, 3, 0, 0, 2 * Math.PI);
            staticCtx.fill();
        }

        function drawTrailSegments(ctxToUse, trail) {
            if (trail.length < 2) return;
            ctxToUse.strokeStyle = DRIP_COLOR;
            ctxToUse.lineCap = 'round';
            ctxToUse.lineJoin = 'round';
            ctxToUse.shadowBlur = 0;
            for (let i = 0; i < trail.length - 1; i++) {
                const p1 = trail[i];
                const p2 = trail[i + 1];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                let nx = 0, ny = 0;
                if (length > 0) {
                    nx = -dy / length;
                    ny = dx / length;
                }
                const randomWidth = 1 + Math.random() * (TRAIL_WIDTH_MAX - 1);
                ctxToUse.lineWidth = randomWidth;
                const randomOffset = (Math.random() * 2 - 1) * TRAIL_JAGGED_OFFSET;
                const offsetX = nx * randomOffset;
                const offsetY = ny * randomOffset;
                ctxToUse.beginPath();
                ctxToUse.moveTo(p1.x + offsetX, p1.y + offsetY);
                ctxToUse.lineTo(p2.x + offsetX, p2.y + offsetY);
                ctxToUse.stroke();
            }
        }

        function redrawStaticContent() {
            staticCtx.fillStyle = THEMES[currentTheme].canvasBg;
            staticCtx.fillRect(0, 0, staticCanvas.width, staticCanvas.height);

            appState.cuts.forEach(cut => {
                const progress = cut.currentHealStrokes / cut.requiredHealStrokes;
                const alpha = Math.max(0.1, 1.0 - progress);
                staticCtx.globalAlpha = alpha;

                drawTaperedCutSegments(staticCtx, cut);

                if (appState.settings.enableDrips) {
                    if (cut.pools) {
                        cut.pools.forEach(pool => drawDripPool(pool.x, pool.y));
                    }
                    if (cut.completedTrails) {
                        cut.completedTrails.forEach(trail => {
                            drawTrailSegments(staticCtx, trail);
                        });
                    }
                }
            });

            staticCtx.globalAlpha = 1.0;
            staticCtx.shadowBlur = 0;

            appState.healLines.forEach(healLine => {
                drawHealLineSegments(staticCtx, healLine);
            });

            updateMeterDisplay();
        }

        function updateMeterDisplay() {
    // Clamp ML within bounds
    appState.currentML = Math.max(0, Math.min(appState.currentML, MAX_ML));
    const percentage   = Math.floor((appState.currentML / MAX_ML) * 100);
    const tensionRatio = appState.currentML / MAX_ML;

    // === 60% Rule: Proactive micro check ===
    // Triggers ONCE per session when ML is between 60% and 99%,
    // and only if no micro-check / cooldown / challenge / relief is running.
    if (
        !microCheckCompleted &&
        !microCheckRequired &&
        !isMicroCheckActive &&
        !microCheckCooldownActive &&
        appState.currentML >= MAX_ML * 0.6 &&
        appState.currentML < MAX_ML
    ) {
        microCheckRequired = true;
        showMicroCheckModal();
    }

    // === Meter Color + Overload Logic ===
    const HUE        = 350;
    const SATURATION = Math.min(100, 30 + (tensionRatio * 70));
    const LIGHTNESS  = Math.max(40, 70 - (tensionRatio * 30));
    const fillColor  = `hsl(${HUE}, ${SATURATION}%, ${LIGHTNESS}%)`;

    let valueText;

    if (percentage >= 100) {
        // Hard cap display at max
        valueText = `${(MAX_ML / ML_DISPLAY_FACTOR).toFixed(1)}`;
        mlMeterContainerEl.style.background = fillColor;

        // Show overload modal ONLY if no micro-check / cooldown / challenge / relief is running
        if (!isChallengeActive && !isReliefActive && !isMicroCheckActive && !microCheckCooldownActive) {
            overloadModal.classList.remove('hidden');
        }
    } else {
        valueText = `${(appState.currentML / ML_DISPLAY_FACTOR).toFixed(1)}`;
        mlMeterContainerEl.style.background =
            `conic-gradient(${fillColor} ${percentage}%, ${THEMES[currentTheme].meterBg} ${percentage}%)`;
        overloadModal.classList.add('hidden');
    }

    const maxMlDisplay = (MAX_ML / ML_DISPLAY_FACTOR).toFixed(1);
    mlPercentEl.innerHTML = `
        <span style="font-size: 1.1rem; font-weight: bold; line-height: 1;">${valueText}</span>
        <span style="font-size: 0.6rem; opacity: 0.8; margin-top: 2px;">/ ${maxMlDisplay} ml</span>
    `;
}


        function applyTheme(theme) {
            const oppositeTheme = theme === 'dark' ? 'light' : 'dark';
            const config = THEMES[theme];
            const oppositeConfig = THEMES[oppositeTheme];

            // 1. Body Background
            document.body.style.backgroundColor = config.bodyBg;
            // 2. Header
            headerEl.classList.remove(oppositeConfig.headerBg, oppositeConfig.headerText, oppositeConfig.headerBorder);
            headerEl.classList.add(config.headerBg, config.headerText, config.headerBorder);
            // 3. Header Description
            headerDescriptionEl.classList.remove(oppositeConfig.headerDescText);
            headerDescriptionEl.classList.add(config.headerDescText);
            // 4. ML Meter
            mlMeterContainerEl.style.backgroundColor = config.meterBg;
            mlMeterContainerEl.style.borderColor = config.meterBorder;
            mlPercentEl.style.backgroundColor = config.meterInnerBg;
            mlPercentEl.style.color = config.headerText;
            // 5. Theme Toggle Button
            themeIconEl.innerHTML = config.iconPath;
            // Use getTranslation to make sure theme button text is updated on language change
            themeTextEl.textContent = getTranslation(oppositeConfig.modeName);


            // Helper to apply styles to a button
            const styleButton = (btn, text, bg, hover, border, borderHover) => {
                // Remove all possible theme classes first
                btn.classList.remove(
                    oppositeConfig[text], oppositeConfig[bg], oppositeConfig[hover],
                    oppositeConfig[border], oppositeConfig[borderHover],
                    config[text], config[bg], config[hover],
                    config[border], config[borderHover]
                );
                // Add the correct classes for the current theme
                btn.classList.add(
                    config[text], config[bg], config[hover],
                    config[border], config[borderHover]
                );
            };

            // 6. Style Primary Buttons (Always colored, only text color changes)
            const primaryButtons = [modeToggleButton, breathButton, challengeButton, affirmationsButton];
            primaryButtons.forEach(btn => {
                btn.classList.remove(oppositeConfig.cutHealText, config.cutHealText); // Use cutHealText as a generic key
                btn.classList.add(config.cutHealText);
            });

            // 7. Style Utility Buttons (Colors change with theme)
            styleButton(themeToggleButton, 'themeText', 'themeBg', 'themeHover', 'themeBorder', 'themeBorderHover');
            styleButton(logButton, 'logText', 'logBg', 'logHover', 'logBorder', 'logBorderHover');
            styleButton(settingsButton, 'settingsText', 'settingsBg', 'settingsHover', 'settingsBorder', 'settingsBorderHover');
            styleButton(undoButton, 'undoText', 'undoBg', 'undoHover', 'undoBorder', 'undoBorderHover');
            styleButton(clearButton, 'clearText', 'clearBg', 'clearHover', 'clearBorder', 'clearBorderHover');
            // NEW: Info Button
            styleButton(infoButton, 'infoText', 'infoBg', 'infoHover', 'infoBorder', 'infoBorderHover');

            // 8. Update Primary Button Colors (which are theme-independent)
            modeToggleButton.classList.add('bg-red-700', 'hover:bg-red-600', 'border-red-900', 'hover:border-red-800');
            breathButton.classList.add('bg-emerald-600', 'hover:bg-emerald-500', 'border-emerald-800', 'hover:border-emerald-700');
            challengeButton.classList.add('bg-indigo-700', 'hover:bg-indigo-600', 'border-indigo-900', 'hover:border-indigo-800');
            affirmationsButton.classList.add('bg-teal-600', 'hover:bg-teal-500', 'border-teal-800', 'hover:border-teal-700');

            // 9. Update Mode Button (if in heal mode)
            updateModeButton();

            // 10. Modal Wrappers
            const modalWrappers = [welcomeModal, checkinModal, sensoryChallengeModal, logModal, addNoteModal, affirmationsModal, settingsModal, overloadModal];
            modalWrappers.forEach(modal => {
                if (modal) {
                    modal.classList.remove(oppositeConfig.modalBg);
                    modal.classList.add(config.modalBg);
                }
            });

            // 11. Save preference and update state
            currentTheme = theme;
            localStorage.setItem('theme', theme);

            // 12. Redraw canvas to update background
            redrawStaticContent();
        }

        function toggleTheme() {
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            const initialTheme = savedTheme && THEMES[savedTheme] ? savedTheme : 'dark';
            applyTheme(initialTheme);
        }

        function drawTemporaryLine(points) {
            activeCtx.shadowBlur = 0;
            if (isHealMode) {
                activeCtx.strokeStyle = HEAL_COLOR;
                activeCtx.lineWidth = HEAL_WIDTH;
                activeCtx.lineCap = 'round';
                activeCtx.lineJoin = 'round';
                activeCtx.shadowColor = HEAL_GLOW_COLOR;
                activeCtx.shadowBlur = 15;
            } else {
                activeCtx.strokeStyle = LINE_COLOR;
                activeCtx.lineWidth = MAX_CUT_WIDTH;
                activeCtx.lineCap = 'round';
                activeCtx.lineJoin = 'round';
                activeCtx.shadowBlur = 0;
            }
            activeCtx.globalAlpha = 1.0;
            activeCtx.beginPath();
            if (points.length > 0) {
                activeCtx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    activeCtx.lineTo(points[i].x, points[i].y);
                }
            }
            activeCtx.stroke();
            activeCtx.shadowBlur = 0;
        }

        function calculatePathLength(points) {
            let length = 0;
            for (let i = 1; i < points.length; i++) {
                const p1 = points[i - 1];
                const p2 = points[i];
                length += Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            }
            return length;
        }

        function generateTaperedPoints(start, end, segmentCount) {
            const points = [];
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            for (let i = 0; i <= segmentCount; i++) {
                const t = i / segmentCount;
                points.push({
                    x: start.x + t * dx,
                    y: start.y + t * dy
                });
            }
            return points;
        }

        function draw(timestamp = 0) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            const deltaTimeSeconds = deltaTime / 1000;

            // 1. Handle Relief Draining
            if (isReliefActive) {
                const drainAmount = RELIEF_PER_SECOND * deltaTimeSeconds;
                appState.currentML -= drainAmount;
                reliefMLDrained += drainAmount;
                updateMeterDisplay();
            }

            // 2. Clear the ACTIVE canvas
            activeCtx.clearRect(0, 0, activeCanvas.width, activeCanvas.height);

            const tensionRatio = appState.currentML / MAX_ML;

            // 3. Apply Visual Tension Effects
            if (appState.settings.enableShake) {
                if (tensionRatio >= SHAKE_THRESHOLD) {
                    document.body.classList.add('shaking');
                } else {
                    document.body.classList.remove('shaking');
                }
            } else {
                document.body.classList.remove('shaking');
            }

            let overlayOpacity = 0.0;
            if (tensionRatio > 0.05) {
                overlayOpacity = tensionRatio * MAX_RED_OPACITY;
            }
            tensionOverlay.style.backgroundColor = `rgba(139, 0, 0, ${overlayOpacity.toFixed(3)})`;

            // 4. Drip generation (if enabled)
            if (appState.settings.enableDrips && !mlDripPaused) {
                const dynamicAcceleration = BASE_DRIP_ACCELERATION + (tensionRatio * (MAX_DRIP_ACCELERATION - BASE_DRIP_ACCELERATION));
                const dynamicGlobalDelay = MIN_GLOBAL_DELAY_MAX - (tensionRatio * (MIN_GLOBAL_DELAY_MAX - MIN_GLOBAL_DELAY_MIN));

                let dripGeneratedThisCycle = false;
                if ((timestamp - globalLastDripTime) > dynamicGlobalDelay) {
                    appState.cuts.forEach(cut => {
                        if (dripGeneratedThisCycle) return;
                        const dynamicCooldown = BASE_DRIP_COOLDOWN_MS - (tensionRatio * (BASE_DRIP_COOLDOWN_MS - MIN_DRIP_COOLDOWN_MS));
                        if ((timestamp - cut.lastDripTime) > dynamicCooldown) {
                            const t = Math.random();
                            const dripX = cut.start.x + t * (cut.end.x - cut.start.x);
                            let dripY = cut.start.y + t * (cut.end.y - cut.start.y);
                            dripY += 5;
                            activeDrips.push({
                                cutId: cut.id,
                                x: dripX,
                                y: dripY,
                                vY: DRIP_INITIAL_SPEED,
                                trail: [{ x: dripX, y: dripY }],
                                cutRef: cut
                            });
                            cut.lastDripTime = timestamp;
                            globalLastDripTime = timestamp;
                            dripGeneratedThisCycle = true;
                        }
                    });
                }

                // 5. Update and Draw ACTIVE Drips
                const dropsToKeep = [];
                activeDrips.forEach(drip => {
                    drip.vY += dynamicAcceleration;
                    drip.y += drip.vY;
                    drip.trail.push({ x: drip.x, y: drip.y });

                    if (drip.y > activeCanvas.height) {
                        drip.cutRef.completedTrails.push(drip.trail);
                        const poolY = activeCanvas.height - POOL_CENTER_OFFSET;
                        drip.cutRef.pools.push({ x: drip.x, y: poolY });

                        const trailLength = drip.trail.reduce((sum, p, index, arr) => {
                            if (index === 0) return 0;
                            const prev = arr[index - 1];
                            return sum + Math.sqrt(Math.pow(p.x - prev.x, 2) + Math.pow(p.y - prev.y, 2));
                        }, 0);
                        const mlAdded = trailLength * ML_ACCUMULATION_MULTIPLIER;
                        appState.currentML += mlAdded;

                        logMLChange('cut', mlAdded, `Cut ID ${drip.cutId} drip finished`);

                        drip.cutRef.totalML = (drip.cutRef.totalML || 0) + mlAdded;
                        updateMeterDisplay();
                        redrawStaticContent();
                    } else {
                        dropsToKeep.push(drip);
                        drawTrailSegments(activeCtx, drip.trail);
                    }
                });
                activeDrips = dropsToKeep;
            } else {
                // If drips are disabled, clear any existing ones
                activeDrips = [];
            }

            // 6. Draw temporary line
            if (isDrawing && startPoint && endPoint) {
                drawTemporaryLine(currentStrokePoints);
            }

            requestAnimationFrame(draw);
        }

        function resizeCanvas() {
            staticCanvas.width = window.innerWidth;
            staticCanvas.height = window.innerHeight;
            activeCanvas.width = window.innerWidth;
            activeCanvas.height = window.innerHeight;
            redrawStaticContent();
            if (!isDrawing) {
                // FIX: Ensure draw is called here to keep animation loop running
                draw();
            }
        }

        // =================================================================
        // FIREBASE / DATA PERSISTENCE
        // =================================================================

        function firebaseInit() {
            // Check if Firebase was loaded
            if (typeof window.initializeApp === 'undefined') { // Checking for global variable directly
                console.warn("Firebase libraries not loaded. App will start in local-only mode.");
                startLocalApp();
                return;
            }

            try {
                // DO NOT PROMPT FOR THESE
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                const authToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

                if (!firebaseConfig.apiKey) {
                    console.warn("Firebase config not found. App will start in local-only mode.");
                    startLocalApp(); // Start local mode if config is missing
                    return;
                }

                // Use globally accessible functions directly
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                // setLogLevel('Debug'); // Enable debug logging for Firestore

                // Set a timeout to ensure app starts even if auth is slow
                const authTimeout = setTimeout(() => {
                    if (!isFirebaseReady) {
                        console.warn("Firebase auth timed out. Starting in local-only mode.");
                        startLocalApp();
                    }
                }, FIREBASE_TIMEOUT_MS);

                onAuthStateChanged(auth, async (user) => {
                    clearTimeout(authTimeout); // Auth responded
                    if (isFirebaseReady) return; // Already handled

                    if (user) {
                        console.log("User is signed in:", user.uid);
                        userId = user.uid;
                        isFirebaseReady = true;
                        // User is signed in, load their data
                        loadDataFromFirestore();
                    } else if (authToken) {
                        // No user, but we have a token
                        console.log("Signing in with custom token...");
                        await signInWithCustomToken(auth, authToken);
                    } else {
                        // No user, no token
                        console.log("Signing in anonymously...");
                        await signInAnonymously(auth);
                    }
                });

            } catch (error) {
                console.error("Error initializing Firebase:", error);
                startLocalApp(); // Start local mode on any error
            }
        }

        function startLocalApp() {
            if (isFirebaseReady) return; // Prevent double-start
            isFirebaseReady = true; // Mark as "ready" (in local mode)
            console.log("Starting app in local-only mode.");
            // Apply all default states
            applyFullAppState();
        }

        function getDocRef() {
            // DO NOT PROMPT FOR THIS
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            // Use private user-specific collection
            return doc(db, 'artifacts', appId, 'users', userId, 'cmioy-session', 'userData');
        }

        async function loadDataFromFirestore() {
            if (!userId) {
                startLocalApp();
                return;
            }

            // Stop any previous listener
            if (unsubscribe) unsubscribe();

            const docRef = getDocRef();

            // Use onSnapshot to listen for real-time changes
            unsubscribe = onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    console.log("Firebase data loaded.");
                    const loadedData = docSnap.data();

                    // Merge loaded data with default state
                    appState = {
                        ...appState,
                        ...loadedData,
                        settings: {
                            ...appState.settings,
                            // Ensure hapticIntensity defaults if missing, otherwise use loaded
                            hapticIntensity: loadedData.settings?.hapticIntensity ?? 50,
                            ...(loadedData.settings || {}),
                        },
                    };

                } else {
                    console.log("No existing document found. Saving initial state.");
                    saveDatatoFirestore(); // Save the default state
                }

                // Re-apply state to the whole application
                applyFullAppState();

            }, (error) => {
                console.error("Error loading data from Firestore:", error);
                startLocalApp(); // Fallback to local mode on listener error
            });
        }

        function triggerSave() {
            if (!userId) return; // Don't save if not authenticated (local mode)

            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }

            saveTimeout = setTimeout(() => {
                saveDatatoFirestore();
                saveTimeout = null;
            }, DEBOUNCE_SAVE_MS);
        }

        async function saveDatatoFirestore() {
            if (!userId || isSaving) return;
            isSaving = true;
            console.log("Saving data to Firebase...");

            try {
                const docRef = getDocRef();
                // Remove complex/transient objects before saving
                const stateToSave = {
                    currentML: appState.currentML,
                    cuts: appState.cuts,
                    healLines: appState.healLines,
                    history: appState.history.map(h => ({ id: h.id, type: h.type })),
                    mlHistory: appState.mlHistory,
                    userAffirmations: appState.userAffirmations,
                    settings: appState.settings,
                    hasWelcomed: appState.hasWelcomed,
                    hasHealedOnce: appState.hasHealedOnce,
                    // NEW STREAK DATA
                    lastActivityDay: appState.lastActivityDay,
                    currentStreak: appState.currentStreak
                };
                await setDoc(docRef, stateToSave, { merge: true });
                console.log("Data saved successfully.");
            } catch (error) {
                console.error("Error saving data to Firestore:", error);
            }
            isSaving = false;
        }

        function applyFullAppState() {
            // ALWAYS reset ML to 0 on app start for a fresh session
            if (appState.currentML > 0) {
                appState.currentML = 0;
                if (userId) { // Only trigger save if we're connected
                    triggerSave();
                }
            }

            // Apply all settings from appState
            isHealMode = false; // Always reset mode on load
            strokesSinceLastPrompt = 0;

            // Restore settings
            languageSelector.value = appState.settings.language;
            updateLanguage(appState.settings.language);

            prioritizeAffirmations.checked = appState.settings.prioritizeAffirmations;

            toggleDrips.checked = appState.settings.enableDrips;
            toggleShake.checked = appState.settings.enableShake;

            // Restore Haptic setting
            const intensity = appState.settings.hapticIntensity = appState.settings.hapticIntensity ?? 50;
            hapticIntensitySlider.value = intensity;
            hapticIntensityValue.textContent = `${intensity}%`;


            // Ensure streak state defaults if not loaded
            if (typeof appState.currentStreak === 'undefined' || appState.currentStreak === null) {
                appState.currentStreak = 0;
            }
            if (typeof appState.lastActivityDay === 'undefined') {
                 appState.lastActivityDay = null;
            }

            // Update UI elements
            updateAffirmationsList();
            updateModeButton();
            redrawStaticContent(); // Redraws all cuts/heals
            updateMeterDisplay(); // Updates ML meter
        }

        // =================================================================
        // AUDIO AND HAPTIC FUNCTIONS
        // =================================================================

        function initializeAudio() {
            // Check if audio is already initialized
            if (cutSynth) return;
            if (typeof Tone === 'undefined') return; // Tone.js not loaded

            Tone.start();

            // 1. Cut Synth
            cutSynth = new Tone.MembraneSynth({
                pitchDecay: 0.01,
                octaves: 2,
                envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
            }).toDestination();
            cutSynth.volume.value = Tone.gainToDb(STATIC_SFX_VOLUME) + 6;

            // 2. Heal Synth
            healSynth = new Tone.PluckSynth({
                attackNoise: 0.5,
                dampening: 4000,
                resonance: 0.8
            }).toDestination();
            healSynth.volume.value = Tone.gainToDb(STATIC_SFX_VOLUME) + 6;

            // 3. Breath Noise and Filter (Breathing SFX)
            breathNoise = new Tone.Noise("pink").start(); // Using pink noise for a fuller sound
            breathNoise.volume.value = -Infinity; // Start muted

            breathFilter = new Tone.Filter({
                type: "lowpass",
                frequency: 100, // Starting low
                Q: 0.5
            }).toDestination();

            breathNoise.connect(breathFilter);

            audioMuted = false;
            console.log("Audio initialized.");
        }

        function playSound(type) {
            if (audioMuted) return;
            try {
                if (type === 'cut' && cutSynth) {
                    cutSynth.triggerAttackRelease("C1", "8n", Tone.now());
                } else if (type === 'heal' && healSynth) {
                    healSynth.triggerAttackRelease("C4", "8n", Tone.now());
                }
            } catch (e) {
                console.warn("Audio playback error:", e);
            }
        }

        function startBreathSound() {
            if (audioMuted || !breathNoise) return;

            // Fade in volume immediately
            breathNoise.volume.rampTo(Tone.gainToDb(STATIC_BREATH_VOLUME) + 6, 0.5);

            // Set up initial filter automation for the first inhale (State 0)
            const inhaleDuration = 4; // Matches breathInterval time
            const now = Tone.now();

            // Inhale: Filter sweeps up (mimics air rushing in)
            breathFilter.frequency.setValueAtTime(100, now);
            breathFilter.frequency.linearRampToValueAtTime(1000, now + inhaleDuration);
        }

        function updateBreathSound(state) {
            if (audioMuted || !breathNoise) return;
            const now = Tone.now();
            const duration = 4; // Matches breath interval

            if (state === 0) { // Inhale (Increase frequency)
                breathFilter.frequency.linearRampToValueAtTime(1000, now + duration);
            } else if (state === 1) { // Hold 1 (Slight drop or maintain high frequency)
                breathFilter.frequency.linearRampToValueAtTime(1200, now + duration); // Slight peak
            } else if (state === 2) { // Exhale (Decrease frequency)
                breathFilter.frequency.linearRampToValueAtTime(100, now + duration);
            } else if (state === 3) { // Hold 2 (Maintain low frequency)
                breathFilter.frequency.linearRampToValueAtTime(150, now + duration);
            }
        }

        function stopBreathSound() {
            if (!breathNoise) return;
            // Fade out volume and stop the noise
            breathNoise.volume.rampTo(-Infinity, 0.5);
            // Stop the filter movement
            breathFilter.frequency.cancelScheduledValues(Tone.now());
            // Move filter to base position after fade out
            setTimeout(() => {
                breathFilter.frequency.value = 100;
            }, 500);
        }

        function playHaptic(type) {
            const intensity = appState.settings.hapticIntensity / 100; // Normalized 0.0 to 1.0

            if (!window.navigator.vibrate || intensity === 0) return;

            const minDuration = 30;
            const maxDuration = 150;

            // Calculate dynamic duration based on intensity
            const baseDuration = minDuration + (intensity * (maxDuration - minDuration));

            try {
                if (type === 'cut') {
                    // Quick, sharp tap
                    window.navigator.vibrate(baseDuration);
                } else if (type === 'breath') {
                    // Gentle, pulsing pattern
                    const hapticPattern = [
                        baseDuration * 1.5, // Inhale pulse
                        baseDuration * 0.5, // Pause
                        baseDuration * 1.5  // Exhale pulse
                    ];
                    window.navigator.vibrate(hapticPattern);
                }
            } catch (e) {
                console.warn("Haptic feedback error:", e);
            }
        }

        // =================================================================
        // LOGGING AND MODALS
        // =================================================================

                function logMLChange(type, amount, detail, emotion = null, trigger = null) {
            appState.mlHistory.push({
                timestamp: Date.now(),
                type: type,
                amount: amount,
                detail: detail,
                emotion: emotion,
                trigger: trigger
            });
            if (appState.mlHistory.length > 100) {
                appState.mlHistory.shift();
            }
            // NEW: Update streak status on any successful log entry
            checkAndUpdateStreak();
            triggerSave();
        }

        function formatLogTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        function updateLogModal() {
            let totalMLIn = 0, totalMLOut = 0, cutCount = 0, reliefCount = 0, challengeCount = 0, undoCount = 0, noteCount = 0, quickLogCount = 0, positiveActionCount = 0;

            appState.mlHistory.forEach(entry => {
                if (entry.amount > 0) totalMLIn += entry.amount;
                else if (entry.amount < 0) totalMLOut += entry.amount;

                if (entry.type === 'cut') cutCount++;
                else if (entry.type === 'breath') reliefCount++;
                else if (entry.type === 'challenge') challengeCount++;
                else if (entry.type === 'undo') undoCount++;
                else if (entry.type === 'note') noteCount++;
                else if (entry.type === 'quick_log') quickLogCount++;
                else if (entry.type === 'positive_action') positiveActionCount++;
            });
            const netML = totalMLIn + totalMLOut;
            const totalReliefEvents = reliefCount + challengeCount + undoCount + quickLogCount;

            // Format streak display
            const streakText = getTranslation('logStreak').replace('{count}', appState.currentStreak);


            logSummaryEl.innerHTML = `
                <p class="text-lg font-extrabold text-gray-800 border-b border-gray-300 pb-2 mb-2">${streakText}</p>
                <p><span class="font-bold text-gray-700">${getTranslation('logSummaryAccumulation')}</span> <span class="text-red-700 font-extrabold">${(totalMLIn / ML_DISPLAY_FACTOR).toFixed(1)} ml</span> (${cutCount} ${getTranslation('logDrips')})</p>
                <p><span class="font-bold text-gray-700">${getTranslation('logSummaryRelief')}</span> <span class="text-green-700 font-extrabold">${(totalMLOut / ML_DISPLAY_FACTOR).toFixed(1)} ml</span> (${totalReliefEvents} relief actions)</p>
                <p class="text-sm text-gray-500 mt-1">Breaths: ${reliefCount}, Challenges: ${challengeCount}, Quick Logs: ${quickLogCount}, Positive Actions: ${positiveActionCount}, Undos: ${undoCount}</p>
                <p class="mt-4 text-xl font-extrabold text-center">${getTranslation('logSummaryNet')} <span class="${netML >= 0 ? 'text-red-700' : 'text-green-700'}">${(netML / ML_DISPLAY_FACTOR).toFixed(1)} ml</span></p>
            `;

            logDetailsEl.innerHTML = '';

            const combinedHistory = [...appState.mlHistory];
            combinedHistory.sort((a, b) => b.timestamp - a.timestamp);

            combinedHistory.forEach(entry => {
                const mlValue = (entry.amount / ML_DISPLAY_FACTOR).toFixed(2);
                const mlClass = entry.amount > 0 ? 'text-red-600 font-bold' : (entry.amount < 0 ? 'text-green-600 font-bold' : 'text-gray-500');

                let actionText, rowClass = "hover:bg-gray-50";

                if (entry.type === 'cut') actionText = getTranslation('logActionCut');
                else if (entry.type === 'breath') actionText = getTranslation('logActionBreath');
                else if (entry.type === 'challenge') actionText = getTranslation('logActionChallenge');
                else if (entry.type === 'undo') actionText = getTranslation('logActionUndo');
                else if (entry.type === 'reset') actionText = getTranslation('logActionReset');
                else if (entry.type === 'quick_log') { actionText = `<strong>${getTranslation('logActionQuick')}:</strong> <span class="italic text-gray-600">"${entry.detail}"</span>`; rowClass = "bg-blue-50 hover:bg-blue-100"; }
                else if (entry.type === 'positive_action') { actionText = `<strong>${getTranslation('logActionPositive')}:</strong> <span class="italic text-gray-600">"${entry.detail}"</span>`; rowClass = "bg-green-50 hover:bg-green-100"; }
                else if (entry.type === 'note') { actionText = `<strong>${getTranslation('logActionNote')}:</strong> <span class="italic text-gray-600">"${entry.detail}"</span>`; rowClass = "bg-yellow-50 hover:bg-yellow-100"; }
                else actionText = entry.type;

                const mlDisplay = (entry.type === 'note' || entry.type === 'quick_log' || entry.type === 'positive_action') ? '---' : `${mlValue} ml`;

                logDetailsEl.innerHTML += `
                    <tr class="${rowClass}">
                        <td class="py-2 px-3 text-gray-500">${formatLogTime(entry.timestamp)}</td>
                        <td class="py-2 px-3 text-gray-700">${actionText}</td>
                        <td class="py-2 px-3 text-right ${mlClass}">${mlDisplay}</td>
                    </tr>
                `;
            });
        }

        function showLogModal() {
            updateLogModal();
            logModal.classList.remove('hidden');
        }
        function hideLogModal() { logModal.classList.add('hidden'); }

        // --- micro-check modal open / close ---
function showMicroCheckModal() {
    if (!microCheckModal) return;

    // Once it's actually showing, it's no longer just "required"
    microCheckRequired = false;
    isMicroCheckActive = true;

    // 🔒 Pause ML drips while user is writing
    mlDripPaused = true;

    // Reset input state
    if (microCheckResponse) {
        microCheckResponse.value = '';
    }
    if (submitMicroCheckButton) {
        submitMicroCheckButton.disabled = true;
    }

    microCheckModal.classList.remove('hidden');
}

function hideMicroCheckModal() {
    if (!microCheckModal) return;

    microCheckModal.classList.add('hidden');
    isMicroCheckActive = false;

    // If we're NOT in the 30s cooldown, we can resume drips now
    if (!microCheckCooldownActive) {
        mlDripPaused = false;   // 🔓 allow drips again
    }
}

//  --- micro-check submit logic ---

function handleMicroCheckSubmit() {
    const text = microCheckResponse.value.trim();
    if (!text) return;

    // Log this as a neutral ML event (no direct ML change)
    logMLChange('micro_check', 0, text);
    hideMicroCheckModal();

    // Mark as completed so the micro-check only happens once per session
    microCheckCompleted = true;

    // 30-second cooldown where drawing is disabled
    microCheckCooldownActive = true;
    mlDripPaused = true;

    showTemporaryPopup("Drawing is paused for 30 seconds. Try using Affirmations, Challenge, or the breathing exercise to help you cope.");

    setTimeout(() => {
        microCheckCooldownActive = false;
        mlDripPaused = false;
        showTemporaryPopup("You can draw again now.");
    }, 30000);
}

// Enable the Continue button only when there is some text
microCheckResponse.addEventListener('input', () => {
    submitMicroCheckButton.disabled = microCheckResponse.value.trim().length === 0;
});

// Submit handler
submitMicroCheckButton.addEventListener('click', handleMicroCheckSubmit);
        // --- Quick Log Modal Logic ---
        function showQuickLogModal() {
             // Do not show if other core modals are visible
            if (!welcomeModal.classList.contains('hidden') || !overloadModal.classList.contains('hidden')) return;

            quickLogInput.value = '';
            quickLogModal.classList.remove('hidden');
            quickLogInput.focus();
        }

        function hideQuickLogModal() {
            quickLogModal.classList.add('hidden');
        }

                function saveQuickLog() {
            const noteText = quickLogInput.value.trim() || 'No detail recorded';

            const selectedEmotionBtn = document.querySelector('.quick-emotion-btn.selected');
            const selectedTriggerBtn = document.querySelector('.quick-trigger-btn.selected');
            const emotion = selectedEmotionBtn ? selectedEmotionBtn.getAttribute('data-emotion') : null;
            const trigger = selectedTriggerBtn ? selectedTriggerBtn.getAttribute('data-trigger') : null;

            if (!emotion || !trigger) {
                showNotification('microPause', 2500);
            }

            // Apply relief instantly
            appState.currentML = Math.max(0, appState.currentML - QUICK_LOG_ML_RELIEF);

            // Log the action with optional tags
            logMLChange('quick_log', -QUICK_LOG_ML_RELIEF, noteText, emotion, trigger);

            updateMeterDisplay();
            hideQuickLogModal();
            showNotification('copy', 1500); // Give a brief positive notification
        }

        // --- Positive Action Modal Logic ---
        function showPositiveActionModal() {
            logModal.classList.add('hidden');
            positiveActionInput.value = '';
            positiveActionModal.classList.remove('hidden');
            positiveActionInput.focus();
        }

        function hidePositiveActionModal() {
            positiveActionModal.classList.add('hidden');
            logModal.classList.remove('hidden'); // Return to the log screen
            updateLogModal(); // Refresh the log
        }

        function savePositiveAction() {
            const actionText = positiveActionInput.value.trim();
            if (actionText) {
                // Log the action with 0 ML change, and apply minor relief
                appState.currentML = Math.max(0, appState.currentML - POSITIVE_ACTION_ML_RELIEF);
                logMLChange('positive_action', -POSITIVE_ACTION_ML_RELIEF, actionText);
                updateMeterDisplay();
                hidePositiveActionModal();
                showNotification('heal', 1500);
            }
        }
// --- Grounding / Check-Out Modal Logic ---
function showGroundingModal() {
    if (!groundingModal) return;

    isGroundingActive = true;

    if (groundingCommitInput) {
        groundingCommitInput.value = '';
    }

    groundingModal.classList.remove('hidden');
}

function closeGroundingModal(saveCommitment) {
    if (!groundingModal) return;

    groundingModal.classList.add('hidden');
    isGroundingActive = false;

    if (saveCommitment && groundingCommitInput) {
        const commitText = groundingCommitInput.value.trim();
        if (commitText) {
            // Log as a zero-ML grounding event
            logMLChange('grounding_checkout', 0, commitText);
            if (typeof triggerSave === 'function') {
                triggerSave();
            }
        }
    }
}
        // --- Add Note Modal Logic ---
        function showAddNoteModal() {
            logModal.classList.add('hidden');
            noteInput.value = '';
            addNoteModal.classList.remove('hidden');
            noteInput.focus();
        }
        function hideAddNoteModal() {
            addNoteModal.classList.add('hidden');
            logModal.classList.remove('hidden'); // Return to the log screen
            updateLogModal(); // Refresh the log
        }
                function saveNote() {
            const noteText = noteInput.value.trim();
            if (noteText) {
                const selectedEmotionBtn = document.querySelector('.note-emotion-btn.selected');
                const selectedTriggerBtn = document.querySelector('.note-trigger-btn.selected');
                const emotion = selectedEmotionBtn ? selectedEmotionBtn.getAttribute('data-emotion') : null;
                const trigger = selectedTriggerBtn ? selectedTriggerBtn.getAttribute('data-trigger') : null;

                if (!emotion || !trigger) {
                    showNotification('microPause', 2500);
                }

                logMLChange('note', 0, noteText, emotion, trigger);
                hideAddNoteModal();
            }
        }

                // --- Emotion & Trigger Tag Selection (Quick Log + Note) ---
        document.addEventListener('click', (e) => {
            const quickEmotionBtn = e.target.closest('.quick-emotion-btn');
if (quickEmotionBtn) {
    const group = quickEmotionBtn.closest('div').querySelectorAll('.quick-emotion-btn');

    let emotionValue = quickEmotionBtn.getAttribute('data-emotion');
    const isOther = quickEmotionBtn.classList.contains('emotion-other-btn');

    if (isOther) {
        // Use previous custom value as default if available
        const previous =
            emotionValue && emotionValue !== 'Other'
                ? emotionValue
                : '';

        const custom = prompt(
            "Type the main emotion you’re feeling right now (e.g. guilt, grief, frustration):",
            previous
        );

        // If cancelled or empty, do nothing (keep previous selection)
        if (!custom || !custom.trim()) {
            return;
        }

        emotionValue = custom.trim();
        quickEmotionBtn.setAttribute('data-emotion', emotionValue);
        quickEmotionBtn.textContent = emotionValue;
    }

    // Now update selection styling
    group.forEach(btn => btn.classList.remove('selected', 'bg-blue-600', 'border-blue-400'));
    quickEmotionBtn.classList.add('selected', 'bg-blue-600', 'border-blue-400');
}

const noteEmotionBtn = e.target.closest('.note-emotion-btn');
if (noteEmotionBtn) {
    const group = noteEmotionBtn.closest('div').querySelectorAll('.note-emotion-btn');

    let emotionValue = noteEmotionBtn.getAttribute('data-emotion');
    const isOther = noteEmotionBtn.classList.contains('emotion-other-btn');

    if (isOther) {
        const previous =
            emotionValue && emotionValue !== 'Other'
                ? emotionValue
                : '';

        const custom = prompt(
            "Type the main emotion for this note (e.g. guilt, grief, frustration):",
            previous
        );

        if (!custom || !custom.trim()) {
            return;
        }

        emotionValue = custom.trim();
        noteEmotionBtn.setAttribute('data-emotion', emotionValue);
        noteEmotionBtn.textContent = emotionValue;
    }

    group.forEach(btn => btn.classList.remove('selected', 'bg-blue-100', 'border-blue-500'));
    noteEmotionBtn.classList.add('selected', 'bg-blue-100', 'border-blue-500');
}

        });

// --- Affirmations Modal Logic ---
        function showAffirmationsModal() {
            updateAffirmationsList();
            affirmationsModal.classList.remove('hidden');
        }
        function hideAffirmationsModal() { affirmationsModal.classList.add('hidden'); }
        function addAffirmation() {
            const text = affirmationInput.value.trim();
            if (text && !appState.userAffirmations.includes(text)) {
                appState.userAffirmations.push(text);
                updateAffirmationsList();
                triggerSave();
                affirmationInput.value = '';
            }
        }
        function removeAffirmation(index) {
            appState.userAffirmations.splice(index, 1);
            updateAffirmationsList();
            triggerSave();
        }
        function clearAffirmations() {
            appState.userAffirmations = [];
            updateAffirmationsList();
            triggerSave();
        }
        function updateAffirmationsList() {
            affirmationsList.innerHTML = '';
            if (appState.userAffirmations.length === 0) {
                // FIX: Use getTranslation directly to prevent recursive call to updateLanguage
                const placeholderText = getTranslation('affirmPlaceholder');
                affirmationsList.innerHTML = `<li class="p-3 text-gray-500 italic">${placeholderText}</li>`;
                return;
            }
            appState.userAffirmations.forEach((text, index) => {
                const li = document.createElement('li');
                li.className = 'p-3 flex justify-between items-center text-gray-800 text-sm md:text-base';
                li.textContent = text;
                const removeBtn = document.createElement('button');
                removeBtn.className = 'ml-4 py-1 px-2 bg-red-100 hover:bg-red-200 text-red-700 text-xs font-semibold rounded-md transition-all';
                removeBtn.textContent = getTranslation('affirmRemove');
                removeBtn.onclick = () => removeAffirmation(index);
                li.appendChild(removeBtn);
                affirmationsList.appendChild(li);
            });
        }

        // --- Settings Modal Logic ---
        function showSettingsModal() {
            settingsModal.classList.remove('hidden');
        }
        function hideSettingsModal() { settingsModal.classList.add('hidden'); }

        // --- Haptic Logic ---
        hapticIntensitySlider.addEventListener('input', (e) => {
            const intensity = parseInt(e.target.value, 10);
            appState.settings.hapticIntensity = intensity;
            hapticIntensityValue.textContent = `${intensity}%`;

            // Provide a test vibration when the slider is moved (if intensity > 0)
            if (intensity > 0) {
                playHaptic('cut');
            }

            triggerSave();
        });


        // --- Welcome Modal Logic ---
        function showWelcomeModal() { welcomeModal.classList.remove('hidden'); }
        function hideWelcomeModal() {
            appState.hasWelcomed = true;
            welcomeModal.classList.add('hidden');
        }

        // --- Check-in Modal Logic ---
        function showMentalHealthPrompt() {
            let message = '';
            const usePersonal = appState.settings.prioritizeAffirmations && appState.userAffirmations.length > 0;

            if (usePersonal) {
                const randomIndex = Math.floor(Math.random() * appState.userAffirmations.length);
                message = appState.userAffirmations[randomIndex];
            } else {
                const randomIndex = Math.floor(Math.random() * encouragingMessages.length);
                message = encouragingMessages[randomIndex];
            }

            randomEncouragementEl.textContent = message;
            checkinModal.classList.remove('hidden');
        }
        function hideMentalHealthPrompt() { checkinModal.classList.add('hidden'); }

        // --- Challenge Logic ---
        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = seconds % 60;
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }
        function showSensoryChallenge() {
            // Check if any modal is active
            if (isDrawing || isReliefActive || !checkinModal.classList.contains('hidden') || !welcomeModal.classList.contains('hidden') || !quickLogModal.classList.contains('hidden') || !positiveActionModal.classList.contains('hidden')) return;

            isChallengeActive = true;

            const challengeKey = SENSORY_CHALLENGES[Math.floor(Math.random() * SENSORY_CHALLENGES.length)];

            if (challengeKey === 'focus_challenge') {
                challengeTaskEl.textContent = getTranslation('challengeFocus');
                startFocusChallenge();
                startChallengeTimer(FOCUS_CHALLENGE_DURATION / 1000);
            } else {
                challengeTaskEl.textContent = challengeKey;
                startChallengeTimer(CHALLENGE_TIME_SECONDS);
            }

            completeChallengeButton.disabled = true;
            completeChallengeButton.classList.add('opacity-50', 'cursor-not-allowed');
            completeChallengeButton.classList.remove('bg-green-600', 'hover:bg-green-700');
            sensoryChallengeModal.classList.remove('hidden');
        }

        function startChallengeTimer(duration) {
            let timeLeft = duration;
            challengeTimerEl.textContent = formatTime(timeLeft);
            clearInterval(challengeTimerInterval);

            challengeTimerInterval = setInterval(() => {
                timeLeft--;
                challengeTimerEl.textContent = formatTime(timeLeft);
                if (timeLeft <= 0) {
                    clearInterval(challengeTimerInterval);
                    if (focusTarget) {
                        stopFocusChallenge(true);
                    } else {
                        completeChallengeButton.disabled = false;
                        completeChallengeButton.classList.remove('opacity-50', 'cursor-not-allowed');
                        completeChallengeButton.classList.add('bg-green-600', 'hover:bg-green-700');
                        challengeTimerEl.classList.remove('text-red-500');
                        challengeTimerEl.classList.add('text-green-500');
                        // Show post-relief grounding check-out after a successful challenge
    showGroundingModal();
                    }
                }
            }, 1000);
        }

        function completeChallenge() {
            if (completeChallengeButton.disabled) return;
            clearInterval(challengeTimerInterval);
            appState.currentML -= ML_REDUCTION_PER_CHALLENGE;
            logMLChange('challenge', -ML_REDUCTION_PER_CHALLENGE, 'Sensory Challenge Complete');
            updateMeterDisplay();
            sensoryChallengeModal.classList.add('hidden');
            isChallengeActive = false;
            challengeTimerEl.classList.add('text-red-500');
            challengeTimerEl.classList.remove('text-green-500');
        // ✅ Transition into the grounding check-out
    showGroundingModal();
}

        function cancelChallenge() {
            clearInterval(challengeTimerInterval);
            stopFocusChallenge(false); // Stop focus game if running
            sensoryChallengeModal.classList.add('hidden');
            isChallengeActive = false;
            challengeTimerEl.classList.add('text-red-500');
            challengeTimerEl.classList.remove('text-green-500');
            showMentalHealthPrompt();
        }

        function startFocusChallenge() {
            if (focusTarget) return; // Already running
            focusTarget = document.createElement('div');
            focusTarget.id = 'focusTarget';
            document.body.appendChild(focusTarget);

            focusTimeElapsed = 0;
            let targetX = Math.random() * (window.innerWidth - 60);
            let targetY = Math.random() * (window.innerHeight - 60);
            focusTarget.style.transform = `translate(${targetX}px, ${targetY}px)`;

            // Move target periodically
            focusTimer = setInterval(() => {
                targetX = Math.random() * (window.innerWidth - 60);
                targetY = Math.random() * (window.innerHeight - 60);
                focusTarget.style.transform = `translate(${targetX}px, ${targetY}px)`;
            }, 1000);

            // Track mouse/touch
            const onFocusMove = (e) => {
                if (!focusTarget) return;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const rect = focusTarget.getBoundingClientRect();

                if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
                    focusTarget.classList.add('success');
                    focusTimeElapsed += 100; // Increment time
                    if (focusTimeElapsed >= FOCUS_CHALLENGE_DURATION) {
                        // Success handled by timer logic
                    }
                } else {
                    focusTarget.classList.remove('success');
                    focusTimeElapsed = 0; // Reset time
                }
            };

            window.addEventListener('mousemove', onFocusMove);
            window.addEventListener('touchmove', onFocusMove, { passive: false });

            // Store cleanup function
            focusTarget.cleanup = () => {
                window.removeEventListener('mousemove', onFocusMove);
                window.removeEventListener('touchmove', onFocusMove);
            };
        }

        function stopFocusChallenge(success) {
            if (!focusTarget) return;

            clearInterval(challengeTimerInterval);
            clearInterval(focusTimer);
            focusTarget.cleanup(); // Remove event listeners
            document.body.removeChild(focusTarget);
            focusTarget = null; // CRITICAL: Reset the variable

            if (success) {
                appState.currentML -= ML_REDUCTION_PER_CHALLENGE;
                logMLChange('challenge', -ML_REDUCTION_PER_CHALLENGE, 'Focus Challenge Complete');
                updateMeterDisplay();
            // ✅ Grounding after a successful focus challenge
    showGroundingModal();
}

            sensoryChallengeModal.classList.add('hidden');
            isChallengeActive = false;
            challengeTimerEl.classList.add('text-red-500');
            challengeTimerEl.classList.remove('text-green-500');

            if (!success) {
                showMentalHealthPrompt();
            }
        }


        // --- Main Action Handlers ---
        function clearCuts() {
            if (isChallengeActive) return;
            if (appState.currentML > 0) {
                logMLChange('reset', -appState.currentML, 'Full canvas cleared');
            }
            appState.cuts = [];
            appState.healLines = [];
            appState.history = [];
            appState.mlHistory = [];
            activeDrips = [];
            appState.currentML = 0;
            strokesSinceLastPrompt = 0;
            hideMentalHealthPrompt();
            redrawStaticContent();
            if (!isDrawing) draw();
            triggerSave();
        }

        function undoLastCut() {
            if (isChallengeActive) return;
            if (appState.history.length === 0) return;

            const lastStroke = appState.history.pop();
            const strokeType = lastStroke.type;
            const strokeIdToRemove = lastStroke.id;

            if (strokeType === 'cut') {
                const cutIndex = appState.cuts.findIndex(c => c.id === strokeIdToRemove);
                if (cutIndex > -1) {
                    const cut = appState.cuts.splice(cutIndex, 1)[0];
                    const mlRemoved = cut.totalML || 0;
                    appState.currentML -= mlRemoved;
                    logMLChange('undo', -mlRemoved, `Undone Cut ID ${cut.id}`);
                    activeDrips = activeDrips.filter(drip => drip.cutId !== strokeIdToRemove);
                }
            } else if (strokeType === 'heal') {
                const healIndex = appState.healLines.findIndex(h => h.id === strokeIdToRemove);
                if (healIndex > -1) {
                    appState.healLines.splice(healIndex, 1);
                }
            }

            redrawStaticContent();
            draw();
            triggerSave();
        }

        function updateModeButton() {
            const lang = appState.settings.language;
            if (isHealMode) {
                modeToggleButton.querySelector('span').textContent = getTranslation('healMode');
                modeToggleButton.classList.remove('bg-red-700', 'hover:bg-red-600', 'border-red-900', 'hover:border-red-800');
                modeToggleButton.classList.add('bg-amber-400', 'hover:bg-amber-300', 'text-gray-900', 'border-amber-600', 'hover:border-amber-500');
            } else {
                modeToggleButton.querySelector('span').textContent = getTranslation('cutMode');
                modeToggleButton.classList.remove('bg-amber-400', 'hover:bg-amber-300', 'text-gray-900', 'border-amber-600', 'hover:border-amber-500');
                modeToggleButton.classList.add('bg-red-700', 'hover:bg-red-600', 'border-red-900', 'hover:border-red-800', 'text-white');
            }
        }

        // --- Relief Logic ---
        function startRelief() {
            // CRITICAL FIX: Prevent re-entry if relief is already active
            if (isChallengeActive || isReliefActive) return;

            // If any modal related to logging/coping is open, hide it
            if (!overloadModal.classList.contains('hidden')) {
                overloadModal.classList.add('hidden');
            }
             if (!quickLogModal.classList.contains('hidden')) {
                quickLogModal.classList.add('hidden');
            }
             if (!positiveActionModal.classList.contains('hidden')) {
                positiveActionModal.classList.add('hidden');
            }


            isReliefActive = true;
            reliefMLDrained = 0;
            breathButton.classList.add('bg-emerald-700', 'animate-pulse');

            // Start Guided Breathing
            breathOverlay.classList.add('visible');
            startBreathSound();
            playHaptic('breath');
            breathState = 0;
            breathText.textContent = getTranslation('breatheIn');
            breathText.classList.add('visible');
            breathCircle.classList.remove('breathe-out'); // Ensure it's ready to expand
            breathCircle.classList.add('breathe-in');
            updateBreathSound(0); // Initial sound setting

            clearInterval(breathInterval);
            breathInterval = setInterval(() => {
                breathState = (breathState + 1) % 4;
                breathText.classList.remove('visible');
                updateBreathSound(breathState); // Update sound filter based on new state

                // We add a slight delay for the text to fade in *after* the state change
                setTimeout(() => {
                    if (breathState === 0) { // In
                        breathText.textContent = getTranslation('breatheIn');
                        breathCircle.classList.add('breathe-in');
                        breathCircle.classList.remove('breathe-out');
                    } else if (breathState === 1) { // Hold
                        breathText.textContent = getTranslation('breatheHold');
                    } else if (breathState === 2) { // Out
                        breathText.textContent = getTranslation('breatheOut');
                        breathCircle.classList.add('breathe-out');
                        breathCircle.classList.remove('breathe-in');
                    } else { // Hold
                        breathText.textContent = getTranslation('breatheHold');
                    }
                    breathText.classList.add('visible');
                }, 500); // This delay matches the text fade-out time

            }, 4000); // 4-second intervals
        }

        function endRelief() {
    if (!isReliefActive) return;
    clearInterval(breathInterval);
    isReliefActive = false;
    breathButton.classList.remove('bg-emerald-700', 'animate-pulse');

    breathOverlay.classList.remove('visible');
    breathCircle.classList.remove('breathe-in');
    breathCircle.classList.add('breathe-out');
    breathText.classList.remove('visible');
    stopBreathSound();

    if (reliefMLDrained > 0) {
        logMLChange('breath', -reliefMLDrained, 'Take a Breath Session');
        triggerSave();
    }
    reliefMLDrained = 0;

    // ✅ After a successful breathing session, guide into grounding
    showGroundingModal();
}

        // --- Input Handlers (Event listeners defined below) ---
        function onMouseDown(e) {
            if (e.button !== 0) return; // Only left click
             //  Block drawing during micro-check cooldown (mouse)
    if (microCheckCooldownActive) {
        showTemporaryPopup(
            "Drawing is resting for 30 seconds after your check-in. Try Affirmations, Challenge, or the breathing exercise meanwhile."
        );
        return;
    }
            // Check if any modal is active
            if (isChallengeActive || !overloadModal.classList.contains('hidden') || !welcomeModal.classList.contains('hidden') || !emailSelectModal.classList.contains('hidden') || !quickLogModal.classList.contains('hidden') || !positiveActionModal.classList.contains('hidden')) {
                return;
            }

            // First interaction: unlock audio
            if (audioMuted) initializeAudio();

            // Check if 100% ML
            if (appState.currentML >= MAX_ML) {
                overloadModal.classList.remove('hidden');
                return;
            }

            // Also prevent drawing during breath session
            if (isReliefActive) return;

            isDrawing = true;
            startPoint = { x: e.clientX, y: e.clientY };
            endPoint = startPoint;
            currentStrokePoints = [startPoint];
        }

        function onTouchStart(e) {
        // 🔒 Block drawing during micro-check cooldown (touch)
    if (microCheckCooldownActive) {
        e.preventDefault();
        showTemporaryPopup(
            "Drawing is resting for 30 seconds after your check-in. Try Affirmations, Challenge, or the breathing exercise meanwhile."
        );
        return;
    }

            if (isChallengeActive || !overloadModal.classList.contains('hidden') || !welcomeModal.classList.contains('hidden') || !emailSelectModal.classList.contains('hidden') || !quickLogModal.classList.contains('hidden') || !positiveActionModal.classList.contains('hidden')) {
                return;
            }

            // First interaction: unlock audio
            if (audioMuted) initializeAudio();

            // Check if 100% ML
            if (appState.currentML >= MAX_ML) {
                overloadModal.classList.remove('hidden');
                return;
            }

            // Also prevent drawing during breath session
            if (isReliefActive) return;

            e.preventDefault();
            isDrawing = true;
            const touch = e.touches[0];
            startPoint = { x: touch.clientX, y: touch.clientY };
            endPoint = startPoint;
            currentStrokePoints = [startPoint];
        }

        function onMouseMove(e) {
        // 🔒 Block drawing during micro-check cooldown
    if (microCheckCooldownActive) {
        showTemporaryPopup(
            "Drawing is resting for 30 seconds after your check-in. Try Affirmations, Challenge, or the breathing exercise meanwhile."
        );
        return;
    }
            if (!isDrawing) return;
            endPoint = { x: e.clientX, y: e.clientY };
            if (isHealMode) {
                currentStrokePoints.push(endPoint);
            } else {
                currentStrokePoints = [startPoint, endPoint];
            }
            draw();
        }

        function onTouchMove(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const touch = e.touches[0];
            endPoint = { x: touch.clientX, y: touch.clientY };
            if (isHealMode) {
                currentStrokePoints.push(endPoint);
            } else {
                currentStrokePoints = [startPoint, endPoint];
            }
            draw();
        }

        function finalizeStroke() {
            if (!isDrawing || isChallengeActive || isReliefActive) return;
            isDrawing = false;

            const strokeLength = calculatePathLength(currentStrokePoints);
            if (strokeLength < 10) { // Ignore tiny accidental clicks
                currentStrokePoints = [];
                draw(); // Clear active canvas
                return;
            }

            strokeIdCounter++;
            if (isHealMode) {
                // --- HEAL MODE LOGIC ---
                playSound('heal');
                const newHeal = {
                    id: strokeIdCounter,
                    type: 'heal',
                    points: currentStrokePoints,
                };
                appState.healLines.push(newHeal);
                appState.history.push({ id: strokeIdCounter, type: 'heal' });

                const cutsInfluencedThisStroke = new Set();
                for (let i = appState.cuts.length - 1; i >= 0; i--) {
                    const cut = appState.cuts[i];
                    const cutMidX = (cut.start.x + cut.end.x) / 2;
                    const cutMidY = (cut.start.y + cut.end.y) / 2;
                    let isNearCut = false;
                    for (const healPoint of currentStrokePoints) {
                        const distance = Math.sqrt(
                            Math.pow(cutMidX - healPoint.x, 2) +
                            Math.pow(cutMidY - healPoint.y, 2)
                        );
                        if (distance < HEALING_RADIUS) {
                            isNearCut = true;
                            break;
                        }
                    }
                    if (isNearCut) {
                        if (!cutsInfluencedThisStroke.has(cut.id)) {
                            cut.currentHealStrokes++;
                            cutsInfluencedThisStroke.add(cut.id);
                        }
                        if (cut.currentHealStrokes >= cut.requiredHealStrokes) {
                            if (!PRESERVE_TENSION_ON_CUT_HEAL) {
                                appState.currentML -= cut.totalML || 0;
                            }
                            appState.cuts.splice(i, 1);
                            activeDrips = activeDrips.filter(drip => drip.cutId !== cut.id);

                            // Show "Heal Metaphor" notification
                            if (!appState.hasHealedOnce) {
                                showNotification('heal', 7000);
                                appState.hasHealedOnce = true;
                            }
                        }
                    }
                }
                redrawStaticContent();
                drawHealLineSegments(staticCtx, newHeal);
            } else {
                // --- CUT MODE LOGIC ---
                playSound('cut');
                playHaptic('cut');
                if (appState.cuts.length >= MAX_PERMANENT_CUTS) {
                    const oldestCut = appState.cuts.shift();
                    activeDrips = activeDrips.filter(drip => drip.cutId !== oldestCut.id);
                    redrawStaticContent();
                }
                const newCut = {
                    id: strokeIdCounter,
                    type: 'cut',
                    start: startPoint,
                    end: endPoint,
                    smoothPoints: generateTaperedPoints(startPoint, endPoint, SEGMENTS),
                    lastDripTime: -BASE_DRIP_COOLDOWN_MS,
                    completedTrails: [],
                    pools: [],
                    totalML: 0,
                    requiredHealStrokes: Math.floor(Math.random() * (MAX_HEAL_STROKES - MIN_HEAL_STROKES + 1)) + MIN_HEAL_STROKES,
                    currentHealStrokes: 0,
                };
                appState.cuts.push(newCut);
                appState.history.push({ id: strokeIdCounter, type: 'cut' });
                redrawStaticContent();
                strokesSinceLastPrompt++;
                if (strokesSinceLastPrompt >= MAX_CUTS_BEFORE_PROMPT) {
                    showMentalHealthPrompt();
                    strokesSinceLastPrompt = 0;
                }
            }

            startPoint = null;
            endPoint = null;
            currentStrokePoints = [];
            updateMeterDisplay();
            draw();
            logMLChange('cut', 0, 'New Cut Drawn'); // Log the cut to trigger streak check
            // Note: ML is added inside draw loop for cuts, but we log here to catch the activity.
            triggerSave(); // Queue a save
        }


        // --- Export Functions ---
        function getSessionSummary() {
            let totalMLIn = 0, totalMLOut = 0, cutCount = 0, reliefCount = 0, challengeCount = 0, undoCount = 0;
            appState.mlHistory.forEach(entry => {
                if (entry.amount > 0) totalMLIn += entry.amount;
                else if (entry.amount < 0) totalMLOut += entry.amount;
                if (entry.type === 'cut') cutCount++;
                if (entry.type === 'breath') reliefCount++;
                if (entry.type === 'challenge') challengeCount++;
                if (entry.type === 'undo') undoCount++;
            });
            const netML = totalMLIn + totalMLOut;

            const summary = `
Session Summary for "Cut Me Instead of You"
Generated: ${new Date().toLocaleString()}
Streak: ${appState.currentStreak} Day(s)
------------------------------------------------
Current Mental Load: ${(appState.currentML / ML_DISPLAY_FACTOR).toFixed(1)} ml / ${(MAX_ML / ML_DISPLAY_FACTOR).toFixed(1)} ml

SESSION TOTALS:
- Total Accumulated: ${(totalMLIn / ML_DISPLAY_FACTOR).toFixed(1)} ml (${cutCount} drips)
- Total Relieved: ${(totalMLOut / ML_DISPLAY_FACTOR).toFixed(1)} ml (${reliefCount} breaths, ${challengeCount} challenges, ${undoCount} undos)
- Net Change: ${(netML / ML_DISPLAY_FACTOR).toFixed(1)} ml

SESSION LOG:
${appState.mlHistory.map(entry => {
    if (entry.type === 'note' || entry.type === 'quick_log' || entry.type === 'positive_action') {
        let typeLabel = getTranslation(entry.type === 'note' ? 'logActionNote' : entry.type === 'quick_log' ? 'logActionQuick' : 'logActionPositive').split('(')[0].trim().toUpperCase();
        return `[${formatLogTime(entry.timestamp)}] ${typeLabel}: ${entry.detail}`;
    }
    const mlValue = (entry.amount / ML_DISPLAY_FACTOR).toFixed(2);
    return `[${formatLogTime(entry.timestamp)}] ${entry.type.padEnd(10, ' ')} | ${mlValue} ml`;
}).join('\n')}
            `;
            return summary.trim();
        }

        function exportToPdf() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const summary = getSessionSummary();

            doc.setFont("helvetica", "normal");
            doc.setFontSize(10);
            doc.text(summary, 10, 10);
            doc.save("CMIOY_Session_Report.pdf");
        }

        function exportToCsv() {
            const data = appState.mlHistory.map(entry => ({
                timestamp: new Date(entry.timestamp).toISOString(),
                time: formatLogTime(entry.timestamp),
                action_type: entry.type,
                ml_change: (entry.amount / ML_DISPLAY_FACTOR).toFixed(3),
                detail: entry.detail || ''
            }));
            const csv = Papa.unparse(data);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "CMIOY_Session_Log.csv");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- New Email Selection Logic ---
        function showEmailSelectModal() {
            logModal.classList.add('hidden'); // Hide the log modal first
            emailSelectModal.classList.remove('hidden');
        }

        function handleEmailExport(clientType) {
            const summary = getSessionSummary();
            const subject = encodeURIComponent('Session Report - Cut Me Instead of You');
            const body = encodeURIComponent('Please paste the session summary below (Ctrl+V / Cmd+V).');
            let uri;

            // 1. Copy summary to clipboard first (Crucial for mobile)
            try {
                navigator.clipboard.writeText(summary).then(() => {
                    showNotification('email');

                    // 2. Adjust URI based on client selection
                    if (clientType === 'gmail') {
                        uri = `https://mail.google.com/mail/u/0/?view=cm&fs=1&su=${subject}&body=${body}`;
                    } else if (clientType === 'outlook') {
                        // NOTE: mailto is often more reliable than ms-outlook on generic browsers
                        uri = `mailto:?subject=${subject}&body=${body}`;
                    } else {
                        // Default mailto:
                        uri = `mailto:?subject=${subject}&body=${body}`;
                    }

                    // 3. Open link
                    window.open(uri, '_blank');

                    hideEmailSelectModal();

                }).catch(err => {
                    console.error('Failed to copy text:', err);
                    // Use simple mailto if copy failed
                    window.open(`mailto:?subject=${subject}&body=${body}`, '_blank');
                    hideEmailSelectModal();
                });
            } catch (err) {
                console.error('Clipboard access denied:', err);
                // Fallback if clipboard access fails entirely
                window.open(`mailto:?subject=${subject}&body=${body}`, '_blank');
                hideEmailSelectModal();
            }
        }

        function hideEmailSelectModal() {
            emailSelectModal.classList.add('hidden');
            logModal.classList.remove('hidden'); // Re-show log modal for context
        }

        function exportToCopy() {
            const summary = getSessionSummary();
            try {
                navigator.clipboard.writeText(summary).then(() => {
                    showNotification('copy');
                });
            } catch (err) {
                console.error('Failed to copy:', err);
            }
        }

        // --- Notification Helpers ---
        function showNotification(type, duration = 3000) {
            let element, text;
            if (type === 'heal') {
                element = healNotification;
            } else {
                element = notificationBox;
                if (type === 'copy') text = getTranslation('notifyCopied');
                if (type === 'email') text = getTranslation('notifyEmail');
                notificationText.textContent = text;
            }

            element.classList.remove('hidden', 'translate-x-full');
            element.classList.add('translate-x-0');

            setTimeout(() => {
                element.classList.remove('translate-x-0');
                element.classList.add('translate-x-full');
                setTimeout(() => element.classList.add('hidden'), 300);
            }, duration);
        }

        // === Splash Screen Dismissal ===

        function dismissSplashScreen(e) {
            // Prevent accidental triggering from button clicks (only allow direct body/div/html taps)
            if (e && e.target.tagName !== 'DIV' && e.target.tagName !== 'BODY' && e.target.tagName !== 'HTML') return;

            if (splashScreen.classList.contains('fade-out')) return;

            if (splashTimerId) {
                clearTimeout(splashTimerId);
            }
            splashScreen.classList.add('fade-out');

            // Immediately change pointer events to auto to allow interaction behind the splash
            splashScreen.style.pointerEvents = 'none';

            // Remove listeners immediately to prevent accidental re-triggering
            document.body.removeEventListener('mousedown', dismissSplashScreen);
            document.body.removeEventListener('touchstart', dismissSplashScreen);

            setTimeout(() => {
                splashScreen.classList.add('hidden');
                // Show welcome modal once splash is gone
                welcomeModal.classList.remove('hidden');
            }, 1000);
        }

        // === App Initialization Sequence ===
        function initSequence() {
            try {
                // 1. Initial UI Setup (Theme and Canvas)
                loadTheme();
                resizeCanvas();
                // draw() is called inside resizeCanvas, so we skip it here.

                // 2. Start Splash Screen Timer
                splashTimerId = setTimeout(() => {
                    dismissSplashScreen();
                }, 2500);

                // 3. Tap-to-Dismiss Listeners (Trigger function only once)
                // Use capture phase (true) to ensure we catch clicks anywhere on the body
                document.body.addEventListener('mousedown', dismissSplashScreen, { once: true, capture: true });
                document.body.addEventListener('touchstart', dismissSplashScreen, { once: true, capture: true });

                // 4. Initialize Firebase/Persistence
                // NOTE: This checks for the globally exposed functions from the first script tag.
                if (typeof window.initializeApp !== 'undefined') {
                    firebaseInit();
                } else {
                    // Fallback in case the firebase-ready event is needed
                    window.addEventListener('firebase-ready', firebaseInit);
                }
            } catch (e) {
                console.error("Critical error during app init (Startup blocked):", e);
                // Ensure the app starts even if init fails
                startLocalApp();
                dismissSplashScreen(); // Force dismiss splash on hard error
            }
        }

        // === Event Listeners (Defined after all required functions) ===
        window.addEventListener('resize', resizeCanvas);
// --- Grounding ---
if (skipGroundingButton) {
    skipGroundingButton.addEventListener('click', () => closeGroundingModal(false));
}
if (confirmGroundingButton) {
    confirmGroundingButton.addEventListener('click', () => closeGroundingModal(true));
}

        // --- Input Listeners ---
        activeCanvas.addEventListener('mousedown', onMouseDown);
        activeCanvas.addEventListener('mousemove', onMouseMove);
        activeCanvas.addEventListener('mouseup', finalizeStroke);
        activeCanvas.addEventListener('mouseleave', () => { if (isDrawing) finalizeStroke(); });

        activeCanvas.addEventListener('touchstart', onTouchStart, { passive: false });
        activeCanvas.addEventListener('touchmove', onTouchMove, { passive: false });
        activeCanvas.addEventListener('touchend', finalizeStroke);
        activeCanvas.addEventListener('touchcancel', finalizeStroke);

        activeCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // --- ML Meter Quick Log Trigger
        mlMeterContainerEl.addEventListener('click', showQuickLogModal);

        // --- Quick Log Listeners
        saveQuickLogButton.addEventListener('click', saveQuickLog);
        cancelQuickLogButton.addEventListener('click', hideQuickLogModal);

        // --- Positive Action Listeners
        logPositiveActionButton.addEventListener('click', showPositiveActionModal);
        savePositiveActionButton.addEventListener('click', savePositiveAction);
        cancelPositiveActionButton.addEventListener('click', hidePositiveActionModal);

        // --- Button Listeners ---
        clearButton.addEventListener('click', clearCuts);
        undoButton.addEventListener('click', undoLastCut);
        themeToggleButton.addEventListener('click', toggleTheme);
        modeToggleButton.addEventListener('click', () => {
            if (isChallengeActive) return;
            isHealMode = !isHealMode;
            updateModeButton();
        });

        // --- Relief Listeners ---
        breathButton.addEventListener('mousedown', startRelief);
        breathButton.addEventListener('mouseup', endRelief);
        breathButton.addEventListener('mouseleave', endRelief);
        breathButton.addEventListener('touchstart', (e) => { e.preventDefault(); startRelief(); }, { passive: false });
        breathButton.addEventListener('touchend', (e) => { e.preventDefault(); endRelief(); });
        breathButton.addEventListener('touchcancel', (e) => { e.preventDefault(); endRelief(); });

        // --- Overload Listeners ---
        overloadBreathButton.addEventListener('click', startRelief);
        overloadChallengeButton.addEventListener('click', () => {
            overloadModal.classList.add('hidden');
            showSensoryChallenge();
        });

        // --- Challenge Listeners ---
        challengeButton.addEventListener('click', showSensoryChallenge);
        completeChallengeButton.addEventListener('click', completeChallenge);
        cancelChallengeButton.addEventListener('click', cancelChallenge);

        // --- Modal Listeners ---
        closeWelcomeModal.addEventListener('click', hideWelcomeModal);
        closeCheckinModal.addEventListener('click', hideMentalHealthPrompt);
        logButton.addEventListener('click', showLogModal);
        closeLogModal.addEventListener('click', hideLogModal);
        infoButton.addEventListener('click', showWelcomeModal);

        // --- Log Note Listeners ---
        addLogNoteButton.addEventListener('click', showAddNoteModal);
        saveNoteButton.addEventListener('click', saveNote);
        cancelNoteButton.addEventListener('click', hideAddNoteModal);

        // --- Affirmation Listeners ---
        affirmationsButton.addEventListener('click', showAffirmationsModal);
        closeAffirmationsModal.addEventListener('click', hideAffirmationsModal);
        addAffirmationButton.addEventListener('click', addAffirmation);
        clearAffirmationsButton.addEventListener('click', clearAffirmations);
        prioritizeAffirmations.addEventListener('change', (e) => {
            appState.settings.prioritizeAffirmations = e.target.checked;
            triggerSave();
        });

        // --- Settings Listeners ---
        settingsButton.addEventListener('click', showSettingsModal);
        closeSettingsModal.addEventListener('click', hideSettingsModal);
        toggleDrips.addEventListener('change', (e) => {
            appState.settings.enableDrips = e.target.checked;
            if (!appState.settings.enableDrips) {
                activeDrips = [];
            }
            redrawStaticContent();
            triggerSave();
        });
        toggleShake.addEventListener('change', (e) => {
            appState.settings.enableShake = e.target.checked;
            if (!appState.settings.enableShake) {
                document.body.classList.remove('shaking');
            }
            triggerSave();
        });

        // --- Haptic Listeners ---
        hapticIntensitySlider.addEventListener('input', (e) => {
            const intensity = parseInt(e.target.value, 10);
            appState.settings.hapticIntensity = intensity;
            hapticIntensityValue.textContent = `${intensity}%`;

            // Provide a test vibration when the slider is moved (if intensity > 0)
            if (intensity > 0) {
                playHaptic('cut');
            }

            triggerSave();
        });

// --- Language Selector Listener ---
languageSelector.addEventListener('change', (e) => {
    const newLang = e.target.value;
    appState.settings.language = newLang;
    updateLanguage(newLang);
    triggerSave();
});

        // --- Export Listeners ---
        exportPdfButton.addEventListener('click', exportToPdf);
        exportCsvButton.addEventListener('click', exportToCsv);
        exportEmailButton.addEventListener('click', showEmailSelectModal);
        exportCopyButton.addEventListener('click', exportToCopy);

        // --- Email Select Listeners ---
        closeEmailSelectModal.addEventListener('click', hideEmailSelectModal);
        emailGmailButton.addEventListener('click', () => handleEmailExport('gmail'));
        emailOutlookButton.addEventListener('click', () => handleEmailExport('outlook'));
        emailMailtoButton.addEventListener('click', () => handleEmailExport('mailto'));


        // Use window.onload to ensure all DOM elements are loaded before calling initSequence
        window.onload = initSequence;
    // Use window load event to start app safely
window.addEventListener('load', () => {
    try {
        initSequence();
    } catch (e) {
        console.error('Init failed, starting local fallback:', e);
        try {
            startLocalApp();
        } catch (_) {}
        try {
            dismissSplashScreen();
        } catch (_) {
            const splash = document.getElementById('splashScreen');
            if (splash) splash.classList.add('hidden');
        }
    }
});

    </script>
<!-- === Reflection Prompt Banner Add-on (Safe, Standalone) === -->
<script>
/* CMIOY Reflection Prompt Add-on (Safe Version)
   - Does NOT change tag selection logic
   - Only shows a small banner when certain emotions are tagged
   - Works with both Quick Log & Add Note tag buttons
*/
(function () {
    // --- 1. Create banner if needed ---
    function cmioyEnsureReflectionBanner() {
        if (document.getElementById("cmioyReflectionBanner")) return;

        const el = document.createElement("div");
        el.id = "cmioyReflectionBanner";
        el.className =
            "fixed bottom-6 left-1/2 -translate-x-1/2 max-w-xs w-11/12 " +
            "bg-gray-900 text-gray-100 text-xs rounded-xl shadow-xl px-3 py-2 " +
            "border border-gray-600 z-[9999] opacity-0 pointer-events-none " +
            "transition-opacity duration-300";
        el.innerHTML =
            '<p id="cmioyReflectionText" class="leading-snug text-[11px]"></p>';
        document.body.appendChild(el);
    }

    // --- 2. Show a reflection prompt for a given emotion ---
    function cmioyShowReflectionPrompt(emotion) {
        const prompts = {
    "Shame":
        "This feeling is about your pain, not your worth. What would you say to someone you cared about if they felt this?",
    "Anger":
        "Your anger is protecting something important. What might it be defending for you right now?",
    "Emptiness":
        "Feeling flat doesn’t mean you’re broken. What is one tiny thing that still exists in your world (a sound, a color, a texture)?",
    "Anxiety":
        "Your body is reacting as if there’s danger. Is there one thing in this moment that feels even a little bit safe?",
    "Sadness":
        "Your sadness shows that something matters to you. What is one small thing this sadness is pointing toward?",
    "Overwhelmed":
        "Everything might feel like too much at once. Is there one tiny piece you can put down or postpone, even just for now?"
};

        const msg = prompts[emotion];
        if (!msg) return; // no prompt configured for this emotion

        cmioyEnsureReflectionBanner();

        const banner = document.getElementById("cmioyReflectionBanner");
        const textEl = document.getElementById("cmioyReflectionText");
        if (!banner || !textEl) return;

        textEl.textContent = msg;

        // Fade in
        banner.classList.remove("opacity-0");
        banner.classList.add("opacity-100");
        banner.style.pointerEvents = "auto";

        // Fade out after 6s
        setTimeout(() => {
            banner.classList.add("opacity-0");
            banner.classList.remove("opacity-100");
            banner.style.pointerEvents = "none";
        }, 6000);
    }

    // --- 3. Attach reflection logic to existing tag buttons ---
    function cmioyAttachReflectionToEmotionButtons() {
        // We ONLY hook into your tag buttons to avoid breaking anything else
        const buttons = document.querySelectorAll(
            ".quick-emotion-btn, .note-emotion-btn"
        );

        buttons.forEach((btn) => {
            // Prevent multiple listeners if called again
            if (btn.dataset.cmioyReflectionBound === "1") return;
            btn.dataset.cmioyReflectionBound = "1";

            btn.addEventListener("click", () => {
                // Try to read emotion from data-emotion on the button OR inner span
                let emotion = btn.dataset.emotion;
                if (!emotion) {
                    const inner = btn.querySelector("[data-emotion]");
                    if (inner) emotion = inner.getAttribute("data-emotion");
                }
                if (!emotion) {
                    // last fallback: use visible text
                    emotion = btn.textContent.trim();
                }

                cmioyShowReflectionPrompt(emotion);
            });
        });
    }

    // --- 4. Initialise add-on safely ---
    function cmioyInitReflectionAddon() {
        try {
            cmioyEnsureReflectionBanner();
            cmioyAttachReflectionToEmotionButtons();
        } catch (err) {
            console.warn("CMIOY reflection add-on error:", err);
        }
    }

    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", cmioyInitReflectionAddon);
    } else {
        cmioyInitReflectionAddon();
    }
})();
// Lightweight toast-style popup for short messages
function showTemporaryPopup(message) {
    let popup = document.getElementById('cmioy-temp-popup');

    // Create the popup element once and reuse it
    if (!popup) {
        popup = document.createElement('div');
        popup.id = 'cmioy-temp-popup';
        popup.className = [
            'fixed',
            'left-1/2',
            'bottom-6',
            'transform',
            '-translate-x-1/2',
            'bg-gray-900',
            'text-white',
            'px-4',
            'py-2',
            'rounded-xl',
            'shadow-lg',
            'text-sm',
            'z-[200]',
            'opacity-0',
            'transition-opacity',
            'duration-200'
        ].join(' ');

        document.body.appendChild(popup);
    }

    popup.textContent = message;
    popup.classList.remove('opacity-0');

    // Clear any previous timer so multiple calls don’t fight
    if (popup._hideTimeout) {
        clearTimeout(popup._hideTimeout);
    }

    popup._hideTimeout = setTimeout(() => {
        popup.classList.add('opacity-0');
    }, 3500);
}

</script>

</body>
</html>