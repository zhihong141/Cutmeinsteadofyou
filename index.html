        <!DOCTYPE html>
        <html lang="en">
        <head>
  <meta charset="UTF-8" />
  <!-- CRITICAL for Mobile: Ensures full-screen and blocks pinch-to-zoom -->
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
  <title>Cut Me Instead of You</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com" defer></script>

  <!-- Firebase Libraries - Simplified for Mobile Module Loading -->
  <script type="module">
    (async () => {
      try {
        const { initializeApp } = await import(
          "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js"
        );
        const {
          getAuth,
          signInAnonymously,
          signInWithCustomToken,
          onAuthStateChanged,
        } = await import(
          "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js"
        );
        const {
          getFirestore,
          doc,
          getDoc,
          setDoc,
          onSnapshot,
          setLogLevel,
        } = await import(
          "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"
        );

        // Expose Firebase pieces globally for the rest of your app
        window.initializeApp = initializeApp;
        window.getAuth = getAuth;
        window.signInAnonymously = signInAnonymously;
        window.signInWithCustomToken = signInWithCustomToken;
        window.onAuthStateChanged = onAuthStateChanged;
        window.getFirestore = getFirestore;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.onSnapshot = onSnapshot;
        window.setLogLevel = setLogLevel;

        window.dispatchEvent(new Event("firebase-ready"));
      } catch (e) {
        console.error("Failed to load Firebase modules.", e);
        window.dispatchEvent(new Event("firebase-ready"));
      }
    })();
  </script>

  <!-- Helper Libraries for Export and Sound (no inline JS here) -->
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
    defer
  ></script>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"
    defer
  ></script>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"
    defer
  ></script>

  <style>
    html {
  /* Make the root element fill the device viewport */
  width: 100vw;
  height: 100dvh; /* dynamic viewport: better for mobile browser UI */
}

body {
  margin: 0;
  padding: 0;

  /* Hard-clamp the app to the visible phone screen */
  width: 100vw;
  height: 100dvh;
  max-width: 100vw;
  max-height: 100dvh;

  overflow: hidden; /* no scrolling / no extra space */

  font-family: "Inter", sans-serif;
  transition: background-color 0.3s ease-out;

  /* Prevents iOS/Android pull-to-refresh on scroll */
  overscroll-behavior-y: contain;
}
    .canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      /* Critical for touch drawing: blocks scrolling/zooming */
      touch-action: none;
    }
    #staticCanvas,
    #activeCanvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }
    #activeCanvas {
      cursor: crosshair;
    }
                /* ML Meter is positioned bottom-left, optimized for thumb access */
                #mlMeterContainer {
                    position: fixed;
                    bottom: 24px;
                    left: 24px;
                    width: 90px;
                    height: 90px;
                    border-radius: 50%;
                    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 50;
                    transition: background-color 0.3s, border-color 0.3s;
                    cursor: pointer; /* Added cursor for quick-log interaction */
                }
                #mlPercent {
                    font-weight: bold;
                    font-size: 1.1rem;
                    width: 75px;
                    height: 75px;
                    border-radius: 50%;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    user-select: none;
                    line-height: 1.1;
                    transition: background-color 0.3s, color 0.3s;
                }
                /* Screen Shake Animation */
                @keyframes shake {
                    0% { transform: translate(1px, 1px) rotate(0deg); }
                    10% { transform: translate(-1px, -2px) rotate(-1deg); }
                    20% { transform: translate(-3px, 0px) rotate(1deg); }
                    30% { transform: translate(3px, 2px) rotate(0deg); }
                    40% { transform: translate(1px, -1px) rotate(1deg); }
                    50% { transform: translate(-1px, 2px) rotate(-1deg); }
                    60% { transform: translate(-3px, 1px) rotate(0deg); }
                    70% { transform: translate(3px, 1px) rotate(-1deg); }
                    80% { transform: translate(-1px, -1px) rotate(1deg); }
                    90% { transform: translate(1px, 2px) rotate(0deg); }
                    100% { transform: translate(1px, -2px) rotate(-1deg); }
                }
                .shaking {
                    animation: shake 0.15s infinite alternate;
                }

                /* Guided Breathing Animation */
                #breathOverlay {
                    position: fixed;
                    inset: 0;
                    background-color: rgba(0, 0, 0, 0.85);
                    backdrop-filter: blur(10px);
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    z-index: 200;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    pointer-events: none;
                }
                #breathOverlay.visible {
                    opacity: 1;
                    pointer-events: auto;
                }
                #breathCircle {
                    width: 150px;
                    height: 150px;
                    background-color: #2dd4bf; /* Teal */
                    border-radius: 50%;
                    transition: transform 4s ease-in-out;
                    transform: scale(0.5);
                }
                #breathText {
                    font-size: 1.75rem;
                    font-weight: 600;
                    color: white;
                    margin-top: 40px;
                    opacity: 0;
                    transition: opacity 0.5s ease-in-out 0.3s;
                }
                #breathCircle.breathe-in { transform: scale(1.2); }
                #breathCircle.breathe-out { transform: scale(0.5); }
                #breathText.visible { opacity: 1; }

                /* Focus Challenge Target (Touch friendly) */
                #focusTarget {
                    position: absolute;
                    width: 80px; /* Increased size for touch */
                    height: 80px;
                    background-color: rgba(250, 204, 21, 0.8);
                    border: 4px solid white;
                    border-radius: 50%;
                    box-shadow: 0 0 15px white;
                    z-index: 120;
                    transition: transform 0.5s ease-out, background-color 0.2s ease;
                    cursor: pointer;
                }
                #focusTarget.success {
                    background-color: rgba(74, 222, 128, 0.8);
                }

                /* Splash Screen Style */
                #splashScreen {
                    position: fixed;
                    inset: 0;
                    background-color: #000000;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    z-index: 9999;
                    opacity: 1;
                    transition: opacity 1.0s ease-out;
                    color: white;
                    /* Allow clicks to dismiss */
                    pointer-events: auto;
                }
                #splashScreen.fade-out {
                    opacity: 0;
                }
                /* Email Selection Modal */
                .email-option-button {
                    transition: all 0.2s;
                    border-bottom: 4px solid;
                }
                /* Color overrides for email buttons */
                #emailGmail { background-color: #DB4437; border-color: #a1261d; }
                #emailGmail:hover { background-color: #c0392b; }
                #emailOutlook { background-color: #0078D4; border-color: #004b86; }
                #emailOutlook:hover { background-color: #0066c0; }
                #emailMailto { background-color: #6C757D; border-color: #495057; }
                #emailMailto:hover { background-color: #5a6268; }
            </style>
        </head>
        <body class="w-screen h-screen">

            <!-- === SPLASH SCREEN  === -->
            <div id="splashScreen">
                <h1 class="text-6xl sm:text-7xl font-extrabold text-white mb-4 tracking-wider">
                    SEVEN.FOUR
                </h1>
                <p class="text-sm sm:text-base text-gray-400">
                    &copy; 2025. A Visualization Tool.
                </p>
            </div>

            <!-- Header Bar - Mobile-First Layout -->
            <div id="header" class="fixed top-0 left-0 w-full p-4 backdrop-blur-sm z-50 shadow-2xl flex flex-col justify-start items-start space-y-3 border-b-2 border-gray-700">

                <!-- === TOP SECTION: Title and Description === -->
                <div class="w-full">
                    <h1 class="font-extrabold text-3xl leading-tight tracking-tight">
                        <!-- Use text-[#HEXCODE] for custom colors -->
                        <span data-lang="title1" class="text-[#C23B31] block">Cut Me</span>
                        <span data-lang="title2" class="text-[#F6C44F] block mt-1">Instead of You</span>
                    </h1>
                    <p id="headerDescription" data-lang="description" class="text-sm text-gray-400 mt-2 leading-relaxed">
                        A touch tool for visualizing and managing emotional tension.
                    </p>
                </div>

                <!-- === BUTTON CONTAINER - Forced 2-Column Grid (Now 2x5) === -->
                <div class="w-full grid grid-cols-2 gap-3 pt-3">

                    <!-- Group 1 & 2 (Primary Actions) - KEEP LARGE -->
                    <button id="modeToggleButton"
                            class="w-full py-3 text-sm font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                        <span data-lang="cutMode">Cut Mode</span>
                    </button>
                    <button id="breathButton"
                            class="w-full py-3 text-sm font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.5 7.5a.5.5 0 00-1 0v4.586l-1.293-1.293a.5.5 0 00-.707.707l2 2a.5.5 0 00.707 0l2-2a.5.5 0 00-.707-.707L10 12.086V7.5z" clip-rule="evenodd" />
                        </svg>
                        <span data-lang="takeBreath">Take a Breath</span>
                    </button>

                    <!-- Group 3 & 4 (Coping Tools) - KEEP LARGE -->
                    <button id="challengeButton"
                            class="w-full py-3 text-sm font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-4 w-4 mr-2">
                            <path d="M10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z" />
                            <path fill-rule="evenodd" d="M10 0a10 10 0 1 1 0 20 10 10 0 0 1 0-20ZM2 10a8 8 0 1 1 14.322 4.908l-2.072-2.072a3.996 3.996 0 0 0-5.83-5.83l-2.071 2.072A8 8 0 0 1 2 10Z" clip-rule="evenodd" />
                        </svg>
                        <span data-lang="challenge">Challenge</span>
                    </button>
                    <button id="affirmationsButton"
                            class="w-full py-3 text-sm font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-4 w-4 mr-2">
                            <path fill-rule="evenodd" d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-5.5-2.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM10 12a5.99 5.99 0 0 0-4.793 2.39A6.483 6.483 0 0 0 10 16.5a6.483 6.483 0 0 0 4.793-2.11A5.99 5.99 0 0 0 10 12Z" clip-rule="evenodd" />
                        </svg>
                        <span data-lang="affirmations">Affirmations</span>
                    </button>

                    <!-- Group 5 & 6 (Utility/Log & Settings) - COMPACTED -->
                    <button id="logButton"
                            class="w-full py-2 text-xs font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-3 w-3 mr-2">
                            <path fill-rule="evenodd" d="M2.5 4A1.5 1.5 0 0 0 1 5.5v10A1.5 1.5 0 0 0 2.5 17h15a1.5 1.5 0 0 0 1.5-1.5v-10A1.5 1.5 0 0 0 17.5 4h-15ZM10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z" clip-rule="evenodd" />
                        </svg>
                        <span data-lang="log">Log</span>
                    </button>
                    <button id="settingsButton"
                            class="w-full py-2 text-xs font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-3 w-3 mr-2">
                            <path fill-rule="evenodd" d="M11.07 2.232a.75.75 0 0 0-1.06-.03l-7.5 7.5a.75.75 0 0 0-.03 1.06l7.5 7.5a.75.75 0 1 0 1.09-1.03L4.85 10l6.25-6.22a.75.75 0 0 0-.03-1.06l-.03-.03Zm3.59 1.06a.75.75 0 0 1 0 1.06L18.15 10l-3.49 3.47a.75.75 0 1 1-1.06-1.06L16.03 10l-2.43-2.44a.75.75 0 0 1 1.06 0Z" clip-rule="evenodd" />
                        </svg>
                        <span data-lang="settings">Settings</span>
                    </button>

                    <!-- Group 7 & 8 (Undo/Clear) - COMPACTED -->
                    <button id="undoButton"
                            class="w-full py-2 text-xs font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-3 w-3 mr-2">
                            <path fill-rule="evenodd" d="M15.312 11.424A7.5 7.5 0 0 1 10 18.75a8.25 8.25 0 0 1-5.34-1.928.75.75 0 0 1 .982-1.127A6.75 6.75 0 0 0 10 17.25c2.43 0 4.67-1.144 6.22-3.048h-1.077a.75.75 0 0 1 0-1.5h2.5a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-1.091Z" clip-rule="evenodd" />
                            <path fill-rule="evenodd" d="M10 2.5a8.25 8.25 0 0 1 5.34 1.928.75.75 0 0 1-.982 1.127A6.75 6.75 0 0 0 10 3.75c-2.43 0-4.67 1.144-6.22 3.048h1.077a.75.75 0 0 1 0 1.5H2.5a.75.75 0 0 1-.75-.75v-2.5a.75.75 0 0 1 1.5 0v1.091Z" clip-rule="evenodd" />
                        </svg>
                        <span data-lang="undo">Undo</span>
                    </button>
                    <button id="clearButton"
                            class="w-full py-2 text-xs font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-3 w-3 mr-2">
                            <path fill-rule="evenodd" d="M8.75 1A2.75 2.75 0 0 0 6 3.75v.443c-.795.077-1.58.275-2.316.596l-.16.079A1.75 1.75 0 0 0 2.25 6.31v5.769c0 .762.486 1.48 1.218 1.833l1.112.541a.75.75 0 0 0 .615-1.365l-1.112-.541a.25.25 0 0 1-.129-.126V6.31c0-.214.133-.395.32-.485.342-.162.7-.294 1.07-.395.093-.025.184-.047.275-.067v6.61a.75.75 0 0 0 1.5 0V3.75c0-.621.504-1.125 1.125-1.125h2.5c.621 0 1.125.504 1.125 1.125V13h-.041a.75.75 0 0 0 0 1.5h.041c.414 0 .75-.336.75-.75V3.75c0-1.517-1.233-2.75-2.75-2.75h-2.5ZM6.75 3.75v.993c.277.037.55.09.818.157V3.75h-.818ZM10 4.125V3.75h.818v1.018c.268-.067.541-.12.818-.157V3.75h-.818ZM14.75 6.25a.75.75 0 0 0-1.5 0v.5a.75.75 0 0 0 1.5 0v-.5ZM13.25 8.75a.75.75 0 0 0-1.5 0v.5a.75.75 0 0 0 1.5 0v-.5ZM11.75 11.25a.75.75 0 0 0-1.5 0v.5a.75.75 0 0 0 1.5 0v-.5Z" clip-rule="evenodd" />
                        </svg>
                        <span data-lang="clearAll">Clear All</span>
                    </button>

                    <!-- Group 9 & 10 (Theme/Info) - COMPACTED -->
                    <button id="themeToggleButton"
                            class="w-full py-2 text-xs font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center">
                        <svg id="themeIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-3 w-3 mr-2">
                            <!-- Icon path set by JS -->
                        </svg>
                        <span id="themeText" data-lang-target="theme">Light Mode</span>
                    </button>
                    <button id="infoButton"
                            class="w-full py-2 text-xs font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center bg-gray-500 hover:bg-gray-600 border-gray-700 hover:border-gray-800 text-white">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-3 w-3 mr-2">
                            <path fill-rule="evenodd" d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0ZM8.948 7.61a.5.5 0 0 1-.163.593L7.765 9.176a.75.75 0 0 0 0 1.148l1.02 1.02a.75.75 0 0 0 1.148 0l1.02-1.02a.5.5 0 0 1 .593.163l1.183 1.183a.75.75 0 1 0 1.06-1.06l-1.183-1.183a.5.5 0 0 1-.593-.163l-1.02-1.02a.75.75 0 0 0-1.148 0l-1.02 1.02a.75.75 0 0 0-1.148 0l-1.183-1.183a.5.5 0 0 1-.163-.593l1.183-1.183a.75.75 0 0 0-1.06-1.06Z" clip-rule="evenodd" />
                        </svg>
                        <span data-lang="info">Info</span>
                    </button>
                </div>
            </div>


            <!-- ML Meter Display (Position remains same, perfect for thumb) -->
            <div id="mlMeterContainer">
                <div id="mlPercent"></div>
            </div>

            <!-- Canvases -->
            <div class="canvas-container">
                <canvas id="staticCanvas"></canvas>
                <canvas id="activeCanvas"></canvas>
            </div>

            <!-- Tension Red Overlay -->
            <div id="tensionOverlay" class="fixed inset-0 pointer-events-none z-40"
                 style="background-color: rgba(139, 0, 0, 0); transition: background-color 0.5s ease-out;">
            </div>
            <!-- Guided Breathing Overlay -->
            <div id="breathOverlay">
                <div id="breathCircle"></div>
                <p id="breathText" data-lang="breatheIn">Breathe In...</p>
            </div>

            <!-- 100% ML Overload Modal (Uses w-full mobile-first sizing) -->
            <div id="overloadModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[130] hidden">
                <div class="bg-red-900 text-white p-6 rounded-xl shadow-2xl transition duration-300 border-4 border-red-500 w-11/12 max-w-sm space-y-4">
                    <h2 class="text-2xl font-extrabold text-red-300 mb-2 border-b-2 border-red-700 pb-2" data-lang="overloadTitle">
                        Mental Overload!
                    </h2>
                    <p class="text-red-200 font-medium text-lg" data-lang="overloadDesc">
                        Your Mental Load is at 100%. Drawing is disabled.
                    </p>
                    <p class="text-lg font-bold text-white" data-lang="overloadInstruct">
                        Please use a coping tool to relieve the tension.
                    </p>
                    <div class="flex flex-col space-y-3 pt-4">
                        <button id="overloadBreathButton"
                                class="w-full py-3 text-base font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center bg-emerald-600 hover:bg-emerald-500 border-emerald-800 hover:border-emerald-700 text-white">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.5 7.5a.5.5 0 00-1 0v4.586l-1.293-1.293a.5.5 0 00-.707.707l2 2a.5.5 0 00.707 0l2-2a.5.5 0 00-.707-.707L10 12.086V7.5z" clip-rule="evenodd" />
                            </svg>
                            <span data-lang="takeBreath">Take a Breath</span>
                        </button>
                        <button id="overloadChallengeButton"
                                class="w-full py-3 text-base font-semibold rounded-xl shadow-md transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-2 flex items-center justify-center bg-indigo-700 hover:bg-indigo-600 border-indigo-900 hover:border-indigo-800 text-white">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="h-5 w-5 mr-2">
                                <path d="M10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z" />
                                <path fill-rule="evenodd" d="M10 0a10 10 0 1 1 0 20 10 10 0 0 1 0-20ZM2 10a8 8 0 1 1 14.322 4.908l-2.072-2.072a3.996 3.996 0 0 0-5.83-5.83l-2.071 2.072A8 8 0 0 1 2 10Z" clip-rule="evenodd" />
                            </svg>
                            <span data-lang="challenge">Start a Challenge</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Quick-Log Trigger Modal (Tapping the ML Meter opens this) -->
            <div id="quickLogModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[125] hidden">
                <div class="bg-gray-800 text-white p-6 rounded-xl shadow-2xl border-4 border-gray-600 w-11/12 max-w-sm space-y-4">
                    <h2 class="text-2xl font-extrabold text-blue-300 border-b-2 border-gray-700 pb-2" data-lang="quickLogTitle">
                        Quick Check-in
                    </h2>
                    <p class="text-gray-300 text-base" data-lang="quickLogDesc">
                        What triggered this moment? Logging gives you a small pause.
                    </p>
                    <textarea id="quickLogInput" rows="3" class="w-full p-3 border-2 border-gray-600 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-700 text-white text-base" placeholder="e.g., Felt frustrated by work, Sudden anxiety..."></textarea>
                    <div class="space-y-2 pt-1">
                        <p class="text-gray-200 text-sm font-semibold">Primary Emotion</p>
                        <div class="flex flex-wrap gap-2">
            <button type="button"
                class="quick-emotion-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
                data-emotion="Shame">Shame</button>

            <button type="button"
                class="quick-emotion-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
                data-emotion="Anger">Anger</button>

            <button type="button"
                class="quick-emotion-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
                data-emotion="Sadness">Sadness</button>

            <button type="button"
                class="quick-emotion-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
                data-emotion="Anxiety">Anxiety</button>

            <button type="button"
                class="quick-emotion-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
                data-emotion="Emptiness">Emptiness</button>

            <button type="button"
                class="quick-emotion-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
                data-emotion="Overwhelmed">Overwhelmed</button>

                            <button type="button"
            class="quick-emotion-btn emotion-other-btn px-3 py-1 rounded-full border border-dashed border-gray-500 text-sm hover:bg-blue-600 hover:border-blue-400"
            data-emotion="Other">Other...</button>
        </div>
                    </div>
                    <div class="space-y-2">
                        <p class="text-gray-200 text-sm font-semibold">External Trigger</p>
                        <div class="flex flex-wrap gap-2">
                            <button type="button" class="quick-trigger-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-purple-600 hover:border-purple-400" data-trigger="Relationship Conflict">Relationship Conflict</button>
                            <button type="button" class="quick-trigger-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-purple-600 hover:border-purple-400" data-trigger="Financial Stress">Financial Stress</button>
                            <button type="button" class="quick-trigger-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-purple-600 hover:border-purple-400" data-trigger="Loneliness">Loneliness</button>
                            <button type="button" class="quick-trigger-btn px-3 py-1 rounded-full border border-gray-500 text-sm hover:bg-purple-600 hover:border-purple-400" data-trigger="Boredom">Boredom</button>
                        </div>
                    </div>

                    <div class="flex justify-between space-x-3 pt-2">
                        <button id="cancelQuickLogButton" class="py-2 px-4 bg-gray-600 hover:bg-gray-700 text-white font-semibold rounded-lg shadow border-b-4 border-gray-800 transition-all" data-lang="cancel">
                            Cancel
                        </button>
                        <button id="saveQuickLogButton" class="py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg shadow border-b-4 border-blue-800 transition-all" data-lang="saveQuickLog">
                            Log & Pause
                        </button>
                    </div>
                </div>
            </div>

            <!-- New: Positive Action Log Modal -->
            <div id="positiveActionModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[120] hidden">
                <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-green-400 w-11/12 max-w-md space-y-4">
                    <h2 class="text-2xl font-extrabold text-green-700 border-b border-green-300 pb-2" data-lang="positiveActionTitle">Log Positive Action</h2>
                    <p class="text-gray-600 text-base" data-lang="positiveActionDesc">Record an action you took that was positive, helpful, or neutral. This supports healthy habit building.</p>
                    <textarea id="positiveActionInput" rows="4" class="w-full p-3 border-2 border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-green-500 bg-gray-50 text-gray-900 text-base" placeholder-key="positiveActionPlaceholder"></textarea>
                    <div class="flex justify-end space-x-3">
                        <button id="cancelPositiveActionButton" class="py-2 px-5 bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold rounded-lg shadow border-b-4 border-gray-400 hover:border-gray-300 transition-all" data-lang="cancel">
                            Cancel
                        </button>
                        <button id="savePositiveActionButton" class="py-2 px-5 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-lg shadow border-b-4 border-green-800 hover:border-green-700 transition-all" data-lang="save">
                            Save
                        </button>
                    </div>
                </div>
            </div>

        <!-- Post-Relief Grounding / Check-Out Modal -->
        <div id="groundingModal"
             class="fixed inset-0 bg-gray-900/80 backdrop-blur-sm flex items-center justify-center z-[150] hidden">
          <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-indigo-400 w-11/12 max-w-md space-y-4">
            <h2 class="text-2xl font-extrabold text-indigo-800 border-b-2 border-gray-200 pb-2"
                data-lang="groundingTitle">
              Grounding Check-Out
            </h2>

            <p class="text-gray-700 text-base" data-lang="groundingIntro">
              Before you head back to your day, let‚Äôs do a short grounding check-out so you leave this space feeling a bit more settled.
            </p>

            <!-- Guided 5-4-3-2-1 grounding prompt -->
            <div class="bg-indigo-50 rounded-lg p-3 space-y-1 text-sm text-gray-800">
              <p data-lang="grounding5"><span class="font-semibold">5</span> things you can see.</p>
              <p data-lang="grounding4"><span class="font-semibold">4</span> things you can touch.</p>
              <p data-lang="grounding3"><span class="font-semibold">3</span> things you can hear.</p>
              <p data-lang="grounding2"><span class="font-semibold">2</span> things you can smell.</p>
              <p data-lang="grounding1"><span class="font-semibold">1</span> thing you can taste.</p>
            </div>

            <!-- Commitment Prompt -->
            <div class="space-y-2">
              <label for="groundingCommitInput"
                     class="block text-sm font-semibold text-gray-800"
                     data-lang="groundingCommitLabel">
                One small action you‚Äôll take next:
              </label>
              <textarea id="groundingCommitInput" rows="2"
                class="w-full border border-gray-300 rounded-lg p-2 text-sm focus:ring-2 focus:ring-indigo-400 focus:outline-none"
                placeholder-key="groundingCommitPlaceholder"></textarea>
              <p class="text-xs text-gray-500" data-lang="groundingExamples">
                This can be simple, like ‚ÄúI will stretch my shoulders‚Äù, ‚ÄúI will step away from my screen‚Äù, or ‚ÄúI will text my safety contact‚Äù.
              </p>
            </div>

            <div class="flex justify-end space-x-3">
              <button id="skipGroundingButton"
                      class="px-3 py-2 text-sm rounded-lg border border-gray-300 text-gray-600 hover:bg-gray-50"
                      data-lang="groundingSkip">
                Skip for now
              </button>
              <button id="confirmGroundingButton"
                      class="px-4 py-2 text-sm font-semibold rounded-lg bg-indigo-600 text-white hover:bg-indigo-700"
                      data-lang="groundingDone">
                Done, back to canvas
              </button>
            </div>
          </div>
        </div>

            <!-- Welcome / Content Warning Modal - ADJUSTED FOR SIZE -->
            <div id="welcomeModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[125] hidden">
                <div class="bg-yellow-200 p-6 rounded-xl shadow-2xl transition duration-300 border-4 border-yellow-500 w-11/12 max-w-lg transform">
                    <h2 class="text-xl font-extrabold text-gray-900 mb-4 border-b border-yellow-400 pb-2" data-lang="welcomeTitle">
                        Welcome - Please Read
                    </h2>
                    <p class="text-gray-800 mb-4 font-medium text-base" data-lang="welcomeIntent">
                        This is a tool, not a game. It's designed to be a safe alternative to help you visualize and manage overwhelming feelings.
                    </p>
                    <p class="text-gray-800 mb-6 font-medium text-base">
                        <strong class="text-red-700" data-lang="welcomeWarning">Content Warning:</strong>
                        <span data-lang="welcomeWarningText">This application contains metaphors for self-harm. If you are in crisis, please close this and use the resources below.</span>
                    </p>
                    <p class="text-gray-800 mb-6 font-medium text-base">
                        <strong data-lang="welcomeGoal">Your Goal:</strong>
                        <span data-lang="welcomeGoalText">Your goal is not to fill the screen, but to use the 'Breathe' and 'Challenge' tools to manage your 'Mental Load' (the meter at the bottom left). This is a tool for practicing relief.</span>
                    </p>
                    <div class="space-y-2 mb-6 text-center bg-yellow-100 p-4 rounded-lg border border-yellow-300">
                        <p class="text-base font-bold text-gray-900" data-lang="welcomeCrisisTitle">Immediate Crisis Support:</p>
                        <a href="https://www.iasp.info/crisis-centres/" target="_blank"
                           class="block text-lg font-extrabold text-red-600 hover:text-red-800 transition duration-150 underline decoration-2" data-lang="welcomeCrisisLink">
                            IASP International Help Finder
                        </a>
                        <p class="text-sm text-gray-700 mt-1" data-lang="welcomeCrisisUS">
                            (If you are in the US, dial 988)
                        </p>
                    </div>
                    <button id="closeWelcomeModal"
                            class="mt-6 w-full py-2.5 text-sm bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold rounded-xl shadow transition duration-150 ease-in-out border-b-4 border-yellow-700 hover:border-yellow-600"
                            data-lang="welcomeUnderstand">
                        I Understand
                    </button>
                </div>
            </div>

          <section class="border rounded-xl p-3 dark:border-gray-700">
            <h3 class="font-bold mb-1">Tips for Heal Mode</h3>
            <ul class="list-disc ml-5 space-y-1">
              <li>Slow, looping shapes or gentle shading.</li>
              <li>Pair with affirmations or a sensory challenge if you feel overloaded.</li>
            </ul>
          </section>

          <section class="text-xs text-gray-600 dark:text-gray-400">
            <p><strong>Reminder:</strong> This tool is a coping aid, not medical advice. If you‚Äôre in danger or thinking about self-harm, please seek immediate help.</p>
          </section>

            <!-- Version badge -->
    <div id="versionBadge"
         class="fixed right-4 text-xs text-gray-600 bg-gray-100/80 border border-gray-300 rounded px-2 py-0.5 backdrop-blur-sm z-[1000] pointer-events-none select-none"
         style="top: calc(env(safe-area-inset-top, 0px) + 0.75rem);">
      ver 1.5
    </div>

            <!-- Cut & Heal Guide Modal -->
    <div id="guideModal" class="fixed inset-0 bg-black/70 backdrop-blur-sm z-[150] hidden">
      <div class="mx-auto mt-10 w-11/12 max-w-xl rounded-2xl bg-white dark:bg-gray-900 dark:text-white shadow-2xl border-2 border-gray-200 dark:border-gray-700">
        <div class="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
          <h2 class="text-xl font-extrabold" data-lang="guideTitle">Guide: Cut &amp; Heal Modes</h2>
          <button id="closeGuideModal" class="px-3 py-1 rounded-lg bg-gray-800 text-white text-xs" data-lang="close">Close</button>
        </div>

        <div class="p-5 space-y-4 text-sm leading-6">
          <section>
            <h3 class="font-bold text-gray-900 dark:text-white mb-1" data-lang="guideDiffTitle">What‚Äôs the difference?</h3>
            <ul class="list-disc ml-5 space-y-1">
              <li><span class="font-semibold" data-lang="cutModeLabel">Cut Mode</span><span>: </span><span data-lang="cutModeDesc">draw fast red strokes to ‚Äúexternalize‚Äù urges.</span></li>
              <li><span class="font-semibold" data-lang="healModeLabel">Heal Mode</span><span>: </span><span data-lang="healModeDesc">slower, gentler input; no ‚Äúcut‚Äù pattern, intended for calm recovery doodles.</span></li>
            </ul>
          </section>

          <section class="border rounded-xl p-3 dark:border-gray-700">
            <h3 class="font-bold mb-1" data-lang="quickStartTitle">Quick Start</h3>
            <ol class="list-decimal ml-5 space-y-1">
              <li data-lang="quick1">Toggle <strong>Cut / Heal</strong> with the mode button.</li>
              <li data-lang="quick2">Press ‚éå <strong>Undo</strong> to remove the last stroke, or <strong>Clear All</strong> to wipe the canvas.</li>
              <li data-lang="quick3">Use the <strong>Breath</strong> button anytime to steady yourself.</li>
              <li data-lang="quick4"><strong>Affirmation</strong> check-in to write encouragement words to help you.</li>
              <li data-lang="quick5">Use <strong>Challenge</strong> to distract those thoughts of anxiety or self-harm urges.</li>
            </ol>
          </section>

          <section class="border rounded-xl p-3 dark:border-gray-700">
            <h3 class="font-bold mb-1" data-lang="cutTipsTitle">Tips for Cut Mode</h3>
            <ul class="list-disc ml-5 space-y-1">
              <li data-lang="cutTip1">Short, sharp strokes = better ‚Äúrelease‚Äù feel.</li>
              <li data-lang="cutTip2">Zoom your attention to the stroke + breath cycle (exhale while drawing).</li>
            </ul>
          </section>

          <section class="border rounded-xl p-3 dark:border-gray-700">
            <h3 class="font-bold mb-1" data-lang="healTipsTitle">Tips for Heal Mode</h3>
            <ul class="list-disc ml-5 space-y-1">
              <li data-lang="healTip1">Slow, looping shapes or gentle shading.</li>
              <li data-lang="healTip2">Pair with affirmations or a sensory challenge if you feel overloaded.</li>
            </ul>
          </section>

          <section class="text-xs text-gray-600 dark:text-gray-400">
            <p><strong data-lang="reminderLabel">Reminder:</strong> <span data-lang="reminderText">This tool is a coping aid, not medical advice. If you‚Äôre in danger or thinking about self-harm, please seek immediate help.</span></p>
          </section>

          <div class="pt-2 flex flex-wrap gap-2">
            <button id="openInfoFromGuide" class="px-3 py-2 rounded-lg text-xs bg-gray-200 hover:bg-gray-300 dark:bg-gray-800 dark:hover:bg-gray-700" data-lang="appInfoBtn">
              App Info / Content Notice
            </button>
          </div>
        </div>
      </div>
    </div>


            <!-- Overload Check in -->
        <div id="microCheckModal" class="fixed inset-0 bg-red-900/95 backdrop-blur-sm flex items-center justify-center z-[140] hidden">
            <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-red-600 w-11/12 max-w-md space-y-4">
                <div class="bg-red-100 border-l-4 border-red-500 p-4 mb-4">
                    <h3 class="text-lg font-bold text-red-800">Mental Load Alert</h3>
                    <p class="text-red-700 mt-1">Your Mental Load has reached 60%. Take a moment to pause.</p>
                </div>

                <h2 class="text-2xl font-extrabold text-gray-900 border-b-2 border-gray-300 pb-3">
                    Quick Self-Check
                </h2>

                <p class="text-gray-800 text-lg font-medium">
                    What is one thing you can tell yourself right now about this feeling?
                    <span class="block text-sm text-gray-500 mt-2">(e.g., 'This feeling is temporary')</span>
                </p>

                <textarea id="microCheckResponse" rows="3" class="w-full p-3 border-2 border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-red-500 bg-gray-50 text-gray-900 text-base" placeholder="Type your response here..."></textarea>

                <button id="submitMicroCheckButton"
                        class="w-full py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow-lg transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-4 border-red-800 disabled:opacity-50 disabled:cursor-not-allowed"
                        disabled>
                    Continue
                </button>
            </div>
        </div>

            <!-- Mental Health Check-in Modal -->
            <div id="checkinModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[100] hidden">
                <div class="bg-yellow-200 p-6 rounded-xl shadow-2xl transition duration-300 border-4 border-yellow-500 w-11/12 max-w-sm transform rotate-1">
                    <h2 class="text-2xl font-extrabold text-gray-900 mb-3 border-b border-yellow-400 pb-2" data-lang="checkinTitle">Checking In...</h2>
                    <p id="randomEncouragement" class="text-gray-800 mb-6 font-medium text-lg">
                        <!-- Content injected by JavaScript -->
                    </p>
                    <p class="text-sm text-gray-700 mb-6 italic border-t border-yellow-300 pt-4" data-lang="checkinRemember">
                        Remember, whatever you're going through, you don't have to face it alone. Please look up a local crisis center or hotline immediately.
                    </p>
                    <div class="space-y-2 mb-6 text-center">
                        <p class="text-base font-bold text-gray-900" data-lang="welcomeCrisisTitle">Immediate Crisis Support:</p>
                        <a href="https://www.iasp.info/crisis-centres/" target="_blank"
                           class="block text-xl font-extrabold text-red-600 hover:text-red-800 transition duration-150 underline decoration-2" data-lang="welcomeCrisisLink">
                            IASP International Help Finder
                        </a>
                        <p class="text-xs text-gray-700 mt-1" data-lang="welcomeCrisisUS">
                            If you are in the US, dial <strong>988</strong>. Find resources specific to your country using the link above.
                        </p>
                    </div>
                    <button id="closeCheckinModal"
                            class="mt-6 w-full py-3 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold rounded-xl shadow transition duration-150 ease-in-out border-b-4 border-yellow-700 hover:border-yellow-600"
                            data-lang="checkinClose">
                        I'm Okay / Close
                    </button>
                </div>
            </div>
            <!-- Sensory Challenge Modal -->
            <div id="sensoryChallengeModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[110] hidden">
                <div class="bg-indigo-900 text-white p-6 rounded-xl shadow-2xl transition duration-300 border-4 border-indigo-500 w-11/12 max-w-sm space-y-4">
                    <h2 class="text-2xl font-extrabold text-indigo-400 mb-2 border-b-2 border-indigo-700 pb-2" data-lang="challengeTitle">
                        CRISIS: Sensory Challenge!
                    </h2>
                    <p class="text-indigo-200 font-medium text-lg" data-lang="challengeDesc">
                        Override the urge by using an intense coping skill.
                    </p>
                    <div class="bg-indigo-800 p-4 rounded-lg border-2 border-indigo-500">
                        <p class="text-xl font-bold text-indigo-300 mb-2" data-lang="challengeTaskTitle">Your Task:</p>
                        <p id="challengeTask" class="text-2xl font-extrabold text-white italic">
                            <!-- Task injected by JavaScript -->
                        </p>
                    </div>
                    <div class="text-center bg-gray-800 p-4 rounded-lg">
                        <p class="text-lg font-semibold text-gray-300" data-lang="challengeTime">Time remaining:</p>
                        <p id="challengeTimer" class="text-5xl font-extrabold text-red-500 tracking-widest">
                            --:--
                        </p>
                    </div>
                    <p class="text-xs text-gray-400 pt-2 text-center" data-lang="challengeInstruct">
                        <strong>Start the task NOW.</strong> Press the button below only when the time runs out.
                    </p>
                    <button id="completeChallengeButton"
                            class="mt-4 w-full py-3 text-base bg-green-700 hover:bg-green-600 text-white font-bold rounded-xl shadow-lg transition duration-150 ease-in-out opacity-50 cursor-not-allowed border-b-4 border-green-900"
                            disabled data-lang="challengeComplete">
                        Complete Challenge (Wait for timer)
                    </button>
                    <button id="anotherChallengeButton"
                class="mt-2 w-full py-2 bg-indigo-700 hover:bg-indigo-600 text-white font-semibold rounded-xl shadow transition duration-150 ease-in-out text-sm border-b-4 border-indigo-900" data-lang="anotherChallenge">
            This one doesn‚Äôt fit right now ‚Äì show another
        </button>
                    <button id="cancelChallengeButton"
                            class="w-full py-2 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow transition duration-150 ease-in-out text-sm border-b-4 border-red-800"
                            data-lang="challengeCancel">
                        Cancel (I need immediate help)
                    </button>
                </div>
            </div>

                <!-- Challenge Prepare Modal (30s countdown before challenge starts) -->
                <div id="challengePrepModal"
                     class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-[145] hidden opacity-0 transition-opacity duration-500">
                    <div class="bg-white rounded-2xl shadow-2xl p-6 max-w-md w-11/12 text-center space-y-4">
                        <h2 class="text-2xl font-bold text-gray-900" data-lang="challengePrepTitle">
                            Get Ready
                        </h2>
                        <!-- üîπ New: show what challenge is coming -->
                        <p id="challengePrepTask" class="text-sm text-gray-900 font-medium">
                            <!-- This will be filled with the challenge text via JS -->
                        </p>
                        <p class="text-sm text-gray-700" data-lang="challengePrepBody">
                            Your challenge will start in
                            <span id="challengePrepCountdown" class="font-semibold">30</span>
                            seconds. Take a breath and get into position.
                        </p>
                         <!-- Optional: direct cancel from prep -->
                <button id="challengePrepCancelButton"
                        class="w-full py-2 rounded-lg border border-red-500 text-red-600 font-semibold hover:bg-red-50">
                    Cancel challenge (I need something else)
                </button>
                        <button id="challengePrepChangeButton"
                        class="hidden w-full py-2 bg-indigo-600 hover:bg-indigo-500 text-white font-semibold rounded-lg shadow border-b-4 border-indigo-900 transition-all">
                    Change challenge
                </button>

                <button id="challengePrepStartButton"
                        class="w-full py-2 bg-yellow-500 hover:bg-yellow-400 text-gray-900 font-extrabold rounded-lg shadow border-b-4 border-yellow-700 transition-all">
                    Start now
                </button>
                    </div>
                </div>

                <!-- ML History Log Modal - OPTIMIZED FOR MOBILE -->
            <div id="logModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[115] hidden">
                <div class="bg-white p-4 rounded-xl shadow-2xl border-4 border-gray-400 w-11/12 max-w-sm space-y-4">
                    <div class="flex flex-col justify-between items-start border-b-2 border-gray-300 pb-2 space-y-2">
                        <h2 class="text-xl font-extrabold text-gray-900" data-lang="logTitle">
                            Activity Log
                        </h2>
                        <!-- Buttons split for space and clarity -->
                        <div class="flex space-x-2 w-full">
                            <button id="addLogNoteButton" class="py-2 px-3 flex-1 bg-blue-600 hover:bg-blue-700 text-white text-xs font-semibold rounded-lg shadow-md border-b-4 border-blue-800 hover:border-blue-700 transition-all transform active:translate-y-0" data-lang="logAddNote">
                                Add Note
                            </button>
                            <!-- NEW: Button for Positive Action -->
                            <button id="logPositiveActionButton" class="py-2 px-3 flex-1 bg-green-600 hover:bg-green-700 text-white text-xs font-semibold rounded-lg shadow-md border-b-4 border-green-800 hover:border-green-700 transition-all transform active:translate-y-0" data-lang="logPositiveAction">
                                Log Action
                            </button>
                        </div>
                    </div>
                    <div id="logSummary" class="bg-gray-100 p-3 rounded-lg border border-gray-200 text-sm shadow-inner">
                        <!-- Summary injected by JavaScript -->
                    </div>
                    <div class="max-h-40 overflow-y-auto border border-gray-300 rounded-lg shadow-md">
                        <table class="w-full text-left text-xs">
                            <thead>
                                <tr class="text-gray-600 uppercase tracking-wider sticky top-0 bg-gray-50 border-b border-gray-300">
                                    <th class="py-1 px-2 w-1/4" data-lang="logTime">Time</th>
                                    <th class="py-1 px-2 w-1/2" data-lang="logAction">Action</th>
                                    <th class="py-1 px-2 w-1/4 text-right" data-lang="logChange">ML Change</th>
                                </tr>
                            </thead>
                            <tbody id="logDetails" class="divide-y divide-gray-100">
                                <!-- Log entries injected by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                    <!-- Export Options -->
                    <div>
                        <h3 class="text-base font-semibold text-gray-800 mb-2" data-lang="logExportTitle">Export Session</h3>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="exportPdfButton" class="w-full py-2 px-2 text-xs font-medium rounded-lg shadow transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-2 bg-red-600 hover:bg-red-700 text-white border-red-800" data-lang="logExportPDF">
                                Save as PDF
                            </button>
                            <button id="exportCsvButton" class="w-full py-2 px-2 text-xs font-medium rounded-lg shadow transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-2 bg-green-600 hover:bg-green-700 text-white border-green-800" data-lang="logExportCSV">
                                Save as CSV
                            </button>
                            <button id="exportEmailButton" class="w-full py-2 px-2 text-xs font-medium rounded-lg shadow transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-2 bg-blue-600 hover:bg-blue-700 text-white border-blue-800" data-lang="logExportEmail">
                                Email Report
                            </button>
                            <button id="exportCopyButton" class="w-full py-2 px-2 text-xs font-medium rounded-lg shadow transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-2 bg-gray-600 hover:bg-gray-700 text-white border-gray-800" data-lang="logExportCopy">
                                Copy Summary
                            </button>
                        </div>
                    </div>
                    <button id="closeLogModal"
                            class="mt-2 w-full py-2 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-xl shadow-lg transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-4 border-gray-800"
                            data-lang="close">
                        Close Log
                    </button>
                </div>
            </div>

            <!-- Email Selection Modal (New Element) -->
            <div id="emailSelectModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[120] hidden">
                <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-blue-400 w-11/12 max-w-md space-y-6">
                    <h2 class="text-2xl font-extrabold text-gray-900 border-b-2 border-gray-300 pb-3" data-lang="emailTitle">
                        Select Email Client
                    </h2>
                    <p class="text-gray-700 text-base" data-lang="emailDesc">
                        Choose your preferred email client. The session summary will be copied to your clipboard first.
                    </p>
                    <div class="grid grid-cols-1 gap-3">
                        <button id="emailGmail" class="email-option-button w-full py-3 text-base font-bold text-white rounded-xl shadow-md transform active:translate-y-0 active:shadow-sm">
                            Gmail
                        </button>
                        <button id="emailOutlook" class="email-option-button w-full py-3 text-base font-bold text-white rounded-xl shadow-md transform active:translate-y-0 active:shadow-sm">
                            Outlook / Office 365
                        </button>
                        <button id="emailMailto" class="email-option-button w-full py-3 text-base font-bold text-white rounded-xl shadow-md transform active:translate-y-0 active:shadow-sm">
                            Default Mail App (Apple Mail, Samsung Mail, etc.)
                        </button>
                    </div>
                    <button id="closeEmailSelectModal"
                            class="mt-5 w-full py-3 bg-gray-400 hover:bg-gray-500 text-gray-900 font-bold rounded-xl shadow-lg border-b-4 border-gray-600 transition-all"
                            data-lang="cancel">
                        Cancel
                    </button>
                </div>
            </div>

            <!-- Add Note Modal -->
            <div id="addNoteModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[120] hidden">
                <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-gray-400 w-11/12 max-w-md space-y-4">
                    <h2 class="text-2xl font-extrabold text-gray-900 border-b border-gray-300 pb-2" data-lang="noteTitle">Add Journal Note</h2>
                    <p class="text-gray-600 text-base" data-lang="noteDesc">Add a note about what you're feeling or what triggered this moment. It will be saved in your log.</p>
                    <textarea id="noteInput" rows="4" class="w-full p-3 border-2 border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-50 text-gray-900 text-base" placeholder-key="notePlaceholder"></textarea>
                    <div class="space-y-2 pt-1">
                        <p class="text-gray-700 text-sm font-semibold">Primary Emotion</p>
                        <div class="flex flex-wrap gap-2">
            <button type="button"
                class="note-emotion-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
                data-emotion="Shame">Shame</button>

            <button type="button"
                class="note-emotion-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
                data-emotion="Anger">Anger</button>

            <button type="button"
                class="note-emotion-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
                data-emotion="Sadness">Sadness</button>

            <button type="button"
                class="note-emotion-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
                data-emotion="Anxiety">Anxiety</button>

            <button type="button"
                class="note-emotion-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
                data-emotion="Emptiness">Emptiness</button>

            <button type="button"
                class="note-emotion-btn px-3 py-1 rounded-full border border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
                data-emotion="Overwhelmed">Overwhelmed</button>

                            <button type="button"
            class="note-emotion-btn emotion-other-btn px-3 py-1 rounded-full border border-dashed border-gray-400 text-sm hover:bg-blue-100 hover:border-blue-500"
            data-emotion="Other">Other...</button>
        </div>
                    </div>

                    <div class="flex justify-end space-x-3">
                        <button id="cancelNoteButton" class="py-2 px-5 bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold rounded-lg shadow border-b-4 border-gray-400 hover:border-gray-300 transition-all" data-lang="cancel">
                            Cancel
                        </button>
                        <button id="saveNoteButton" class="py-2 px-5 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg shadow border-b-4 border-blue-800 hover:border-blue-700 transition-all" data-lang="save">
                            Save
                        </button>
                    </div>
                </div>
            </div>

            <!-- Affirmations Modal -->
            <div id="affirmationsModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[115] hidden">
                <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-gray-400 w-11/12 max-w-lg space-y-6">
                    <h2 class="text-2xl font-extrabold text-gray-900 border-b-2 border-gray-300 pb-3" data-lang="affirmTitle">
                        Personalized Affirmations
                    </h2>
                    <p class="text-gray-600 text-base" data-lang="affirmDesc">
                        Add personalized affirmations that will appear during your check-ins. These words of encouragement can help you through difficult moments.
                    </p>

                    <!-- Add New Affirmation -->
                    <div class="flex space-x-3">
                        <input type="text" id="affirmationInput" placeholder-key="affirmPlaceholder" class="flex-grow p-3 border-2 border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-teal-500 bg-gray-50 text-gray-900 text-base">
                        <button id="addAffirmationButton" class="py-2 px-5 bg-teal-600 hover:bg-teal-700 text-white font-semibold rounded-lg shadow border-b-4 border-teal-800 hover:border-teal-700 transition-all" data-lang="add">
                            Add
                        </button>
                    </div>

                    <!-- Prioritize Checkbox -->
                    <div class="flex items-center space-x-3 bg-gray-100 p-3 rounded-lg border border-gray-200">
                        <input type="checkbox" id="prioritizeAffirmations" class="w-5 h-5 text-teal-600 rounded border-gray-300 focus:ring-teal-500">
                        <label for="prioritizeAffirmations" class="font-medium text-gray-700 text-base" data-lang="affirmPrioritize">
                            Prioritize my affirmations during high tension moments
                        </label>
                    </div>

                    <!-- Saved Affirmations List -->
                    <div class="max-h-60 overflow-y-auto border border-gray-300 rounded-lg shadow-md p-2 space-y-2 bg-gray-50">
                        <ul id="affirmationsList" class="divide-y divide-gray-200">
                            <!-- Affirmations will be injected here -->
                        </ul>
                    </div>

                    <div class="flex justify-between">
                        <button id="clearAffirmationsButton" class="py-2 px-4 bg-red-600 hover:bg-red-700 text-white text-sm font-semibold rounded-lg shadow border-b-4 border-red-800 hover:border-red-700 transition-all" data-lang="affirmClear">
                            Clear All
                        </button>
                        <button id="closeAffirmationsModal" class="py-2 px-5 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-xl shadow-lg border-b-4 border-gray-800 transition-all" data-lang="close">
                            Close
                        </button>
                    </div>
                </div>
            </div>

            <!-- Settings Modal -->
            <div id="settingsModal" class="fixed inset-0 bg-gray-900/90 backdrop-blur-sm flex items-center justify-center z-[115] hidden">
                <div class="bg-white p-6 rounded-xl shadow-2xl border-4 border-gray-400 w-11/12 max-w-md space-y-6">
                    <h2 class="text-2xl font-extrabold text-gray-900 border-b-2 border-gray-300 pb-3" data-lang="settingsTitle">
                        Settings
                    </h2>

                    <!-- Language Settings -->
                    <div class="space-y-2">
                        <label for="languageSelector" class="font-semibold text-gray-700 text-base" data-lang="settingsLang">Language / Bahasa:</label>
                        <select id="languageSelector" class="w-full p-3 border-2 border-gray-300 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-50 text-gray-900 text-base">
                            <option value="en">English</option>
                            <option value="ms">Bahasa Melayu</option>
                            <option value="zh">ÁÆÄ‰Ωì‰∏≠Êñá (Simplified Chinese)</option>
                            <option value="ta">‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç (Tamil)</option>
                        </select>
                    </div>
                    <!-- Visual Settings -->
                    <div class="space-y-4 pt-4 border-t border-gray-200">
                        <h3 class="text-xl font-bold text-gray-800" data-lang="settingsVisual">Visual Settings</h3>
                        <div class="flex items-center justify-between bg-gray-100 p-3 rounded-lg border border-gray-200">
                            <label for="toggleDrips" class="font-medium text-gray-700 text-base" data-lang="settingsDrips">
                                Enable Drip & Pool Effects
                            </label>
                            <input type="checkbox" id="toggleDrips" class="w-6 h-6 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                        </div>
                        <div class="flex items-center justify-between bg-gray-100 p-3 rounded-lg border border-gray-200">
                            <label for="toggleShake" class="font-medium text-gray-700 text-base" data-lang="settingsShake">
                                Enable Tension Screen Shake
                            </label>
                            <input type="checkbox" id="toggleShake" class="w-6 h-6 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                        </div>
                    </div>

                    <!-- Haptic Settings -->
                    <div class="space-y-4 pt-4 border-t border-gray-200">
                        <h3 class="text-xl font-bold text-gray-800" data-lang="settingsHaptic">Haptic Feedback</h3>
                        <label for="hapticIntensitySlider" class="font-medium text-gray-700 text-base block" data-lang="hapticIntensity">
                            Intensity: <span id="hapticIntensityValue">50%</span>
                        </label>
                        <input type="range" id="hapticIntensitySlider" min="0" max="100" value="50" step="10"
                               class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                        <p class="text-sm text-gray-500 italic" data-lang="hapticNote">Set to 0% to disable all vibrations.</p>
                    </div>
                    <!-- Challenge Prep Time Settings -->
                    <div class="space-y-3 pt-4 border-t border-gray-200">
                      <h3 class="text-xl font-bold text-gray-800" data-lang="settingsChallengePrepTitle">
                        Challenge Prep Time
                      </h3>

                      <label for="challengePrepSlider" class="font-medium text-gray-700 text-base block">
                        <span data-lang="settingsChallengePrepLabel">Get-ready countdown:</span>
                        <span id="challengePrepValue">30s</span>
                      </label>

                      <input type="range" id="challengePrepSlider"
                             min="0" max="60" value="30" step="5"
                             class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">

                      <p class="text-sm text-gray-500 italic" data-lang="settingsChallengePrepHint">
                        Set to 0s to start the challenge immediately with no prep popup.
                      </p>
                    </div>
                    <button id="closeSettingsModal"
                            class="mt-6 w-full py-3 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-xl shadow-lg transition-all duration-200 transform active:translate-y-0 active:shadow-sm border-b-4 border-gray-800"
                            data-lang="close">
                        Close
                    </button>
                </div>


            <!-- One-time "Heal Metaphor" Notification -->
            <div id="healNotification" class="fixed bottom-24 right-6 bg-green-600 text-white p-4 rounded-xl shadow-2xl border-4 border-green-400 w-11/12 max-w-sm z-[100] hidden transition-all duration-300 transform translate-x-full">
                <h3 class="font-bold text-lg" data-lang="healNotifyTitle">Cut Healed!</h3>
                <p class="text-sm" data-lang="healNotifyDesc">
                    Notice the 'Mental Load' didn't change? That's intentional. Healing is the first step. Now, use 'Breathe' or 'Challenge' to relieve the underlying tension.
                </p>
            </div>

            <!-- Notification Box for "Copied" -->
            <div id="notificationBox" class="fixed bottom-24 right-6 bg-blue-600 text-white py-3 px-5 rounded-xl shadow-2xl z-[100] hidden transition-all duration-300 transform translate-x-full">
                <p id="notificationText" class="font-semibold"></p>
            </div>

            <!-- Main Application Logic -->
            <script type="module">
                // === Firebase Imports ===
                // IMPORTANT: In this version, the Firebase libraries are exposed directly to the window in the first script tag.
                // We reference them here as global variables, which resolves the 'initializeApp is not a function' error.
                const { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, getFirestore, doc, getDoc, setDoc, onSnapshot, setLogLevel } = window;


                // === App State ===
                let appState = {
                    currentML: 0,
                    cuts: [],
                    healLines: [],
                    history: [],
                    mlHistory: [],
                    userAffirmations: [],
                    settings: {
                        language: 'en',
                        prioritizeAffirmations: false,
                        enableDrips: true,
                        enableShake: true,
                        hapticIntensity: 50, // NEW: Haptic Intensity (0-100)
                        challengePrepSeconds: 30, // NEW: Get-ready countdown (seconds)
                    },
                    hasWelcomed: false,
                    hasHealedOnce: false,
                    // NEW STREAK STATE
                    lastActivityDay: null,
                    currentStreak: 0
                };

                // === Constants ===
                const STATIC_SFX_VOLUME = 0.7; // Fixed volume for cuts/heals
                const STATIC_BREATH_VOLUME = 0.5; // Fixed volume for breath
                // Removed HAPTIC_ENABLED_INTERNAL, now controlled by appState.settings.hapticIntensity
                const QUICK_LOG_ML_RELIEF = 1000; // 1000 ML (2.0 ml in display) relief for quick log.
                const POSITIVE_ACTION_ML_RELIEF = 500; // Small relief for logging positive action

                // === Local State & DOM Refs ===
                let isDrawing = false;
                let startPoint = null;
                let endPoint = null;
                let currentStrokePoints = [];
                let activeDrips = [];
                let lastTime = 0;
                let strokeIdCounter = 0;
                let isHealMode = false;
                let strokesSinceLastPrompt = 0;
                let healStrokeCountThisSession = 0; // NEW: count heal strokes per session
                let isReliefActive = false;
                let reliefMLDrained = 0;
                let isChallengeActive = false;
                let currentChallengeKey = null;
                let isGroundingActive = false;
                let challengeTimerInterval = null;
                let focusTarget = null;
                let focusTimer = null;
                let focusTimeElapsed = 0;
                let currentTheme = 'dark';
                let breathInterval = null;
                let breathState = 0;
                let audioMuted = true;
                let saveTimeout = null;
                let isSaving = false;
                let db, auth, userId;
                let unsubscribe;
                let isFirebaseReady = false;
                let cutSynth, healSynth, breathNoise, breathFilter;
                let splashTimerId = null;
                let isMicroCheckActive = false;
                let microCheckRequired = false;
                let microCheckCompleted = false;
                let microCheckCooldownActive = false;
                let mlDripPaused = false;

                // Configuration Constants
                const MAX_CUTS_BEFORE_PROMPT = 5;
                const MAX_PERMANENT_CUTS = 5;
                const LINE_COLOR = '#8B0000';
                const DRIP_COLOR = '#8B0000';
                const POOL_CENTER_OFFSET = 4;
                const SEGMENTS = 50;
                const MAX_CUT_WIDTH = 6;
                const TRAIL_WIDTH_MAX = 4;
                const TRAIL_JAGGED_OFFSET = 1.5;
                const HEAL_COLOR = '#FFD700';
                const HEAL_WIDTH = 5;
                const HEAL_GLOW_COLOR = '#FFA500';
                const HEAL_FADE_MS = 1000;
                const MAX_ML = 50000;
                const ML_DISPLAY_FACTOR = 500;
                const PRESERVE_TENSION_ON_CUT_HEAL = true;
                const ML_ACCUMULATION_MULTIPLIER = 2.0;
                const BASE_DRIP_COOLDOWN_MS = 6000;
                const MIN_DRIP_COOLDOWN_MS = 1000;
                const BASE_DRIP_ACCELERATION = 0.00004;
                const MAX_DRIP_ACCELERATION = 0.0001;
                const DRIP_INITIAL_SPEED = 0.006;
                let globalLastDripTime = 0;
                const MIN_GLOBAL_DELAY_MAX = 500;
                const MIN_GLOBAL_DELAY_MIN = 100;
                const HEALING_RADIUS = 150;
                const MIN_HEAL_STROKES = 2;
                const MAX_HEAL_STROKES = 4;
                const RELIEF_PER_SECOND = 4000;
                const SHAKE_THRESHOLD = 0.7;
                const MAX_RED_OPACITY = 0.25;
                const CHALLENGE_TIME_SECONDS = 60;
                const ML_REDUCTION_PER_CHALLENGE = 20000;
                const FOCUS_CHALLENGE_DURATION = 15000;
                const DEBOUNCE_SAVE_MS = 2000;
                const FIREBASE_TIMEOUT_MS = 3000;


                // === DOM Elements ===
                const staticCanvas = document.getElementById('staticCanvas');
                const staticCtx = staticCanvas.getContext('2d');
                const activeCanvas = document.getElementById('activeCanvas');
                const activeCtx = activeCanvas.getContext('2d');
                const headerEl = document.getElementById('header');
                const headerDescriptionEl = document.getElementById('headerDescription');
                const clearButton = document.getElementById('clearButton');
                const undoButton = document.getElementById('undoButton');
                const breathButton = document.getElementById('breathButton');
                const modeToggleButton = document.getElementById('modeToggleButton');
                const challengeButton = document.getElementById('challengeButton');
                const affirmationsButton = document.getElementById('affirmationsButton');
                const logButton = document.getElementById('logButton');
                const settingsButton = document.getElementById('settingsButton');
                const infoButton = document.getElementById('infoButton');
                const themeToggleButton = document.getElementById('themeToggleButton');
                const themeIconEl = document.getElementById('themeIcon');
                const themeTextEl = document.getElementById('themeText');
                const mlMeterContainerEl = document.getElementById('mlMeterContainer');
                const mlPercentEl = document.getElementById('mlPercent');
                const tensionOverlay = document.getElementById('tensionOverlay');
                const breathOverlay = document.getElementById('breathOverlay');
                const breathCircle = document.getElementById('breathCircle');
                const breathText = document.getElementById('breathText');
                const welcomeModal = document.getElementById('welcomeModal');
                const closeWelcomeModal = document.getElementById('closeWelcomeModal');
                const checkinModal = document.getElementById('checkinModal');
                const closeCheckinModal = document.getElementById('closeCheckinModal');
                const randomEncouragementEl = document.getElementById('randomEncouragement');
                const sensoryChallengeModal = document.getElementById('sensoryChallengeModal');
                const challengeTaskEl = document.getElementById('challengeTask');
                const challengeTimerEl = document.getElementById('challengeTimer');
                const completeChallengeButton = document.getElementById('completeChallengeButton');
                const cancelChallengeButton = document.getElementById('cancelChallengeButton');
                const anotherChallengeButton = document.getElementById('anotherChallengeButton');
                // 30s pre-challenge popup
                const challengePrepModal = document.getElementById('challengePrepModal');
                const challengePrepCountdownEl = document.getElementById('challengePrepCountdown');
                const challengePrepTaskEl = document.getElementById('challengePrepTask');
                let challengePrepTimer = null;
                let challengePrepCountdownTimer = null;
                const CHALLENGE_PREP_SECONDS = 30;
                const challengePrepSkipButton = document.getElementById('challengePrepSkipButton');
                const challengePrepCancelButton = document.getElementById('challengePrepCancelButton');
                const challengePrepStartButton = document.getElementById('challengePrepStartButton');

                const logModal = document.getElementById('logModal');
                const closeLogModal = document.getElementById('closeLogModal');
                const logSummaryEl = document.getElementById('logSummary');
                const logDetailsEl = document.getElementById('logDetails');
                const addLogNoteButton = document.getElementById('addLogNoteButton');
                const exportPdfButton = document.getElementById('exportPdfButton');
                const exportCsvButton = document.getElementById('exportCsvButton');
                const exportEmailButton = document.getElementById('exportEmailButton');
                const exportCopyButton = document.getElementById('exportCopyButton');
                const emailSelectModal = document.getElementById('emailSelectModal');
                const closeEmailSelectModal = document.getElementById('closeEmailSelectModal');
                const emailGmailButton = document.getElementById('emailGmail');
                const emailOutlookButton = document.getElementById('emailOutlook');
                const emailMailtoButton = document.getElementById('emailMailto');
                const addNoteModal = document.getElementById('addNoteModal');
                const noteInput = document.getElementById('noteInput');
                const saveNoteButton = document.getElementById('saveNoteButton');
                const cancelNoteButton = document.getElementById('cancelNoteButton');
                const affirmationsModal = document.getElementById('affirmationsModal');
                const affirmationInput = document.getElementById('affirmationInput');
                const addAffirmationButton = document.getElementById('addAffirmationButton');
                const prioritizeAffirmations = document.getElementById('prioritizeAffirmations');
                const affirmationsList = document.getElementById('affirmationsList');
                const clearAffirmationsButton = document.getElementById('clearAffirmationsButton');
                const closeAffirmationsModal = document.getElementById('closeAffirmationsModal');
                const settingsModal = document.getElementById('settingsModal');
                const languageSelector = document.getElementById('languageSelector');
                const toggleDrips = document.getElementById('toggleDrips');
                const toggleShake = document.getElementById('toggleShake');
                const closeSettingsModal = document.getElementById('closeSettingsModal');
                const healNotification = document.getElementById('healNotification');
                const notificationBox = document.getElementById('notificationBox');
                const notificationText = document.getElementById('notificationText');
                const overloadModal = document.getElementById('overloadModal');
                const overloadBreathButton = document.getElementById('overloadBreathButton');
                const overloadChallengeButton = document.getElementById('overloadChallengeButton');
                const splashScreen = document.getElementById('splashScreen');
                const fadeSpeedEl = document.getElementById('fadeSpeed');
                const fadeSpeedValueEl = document.getElementById('fadeSpeedValue'); // inside the ‚ÄúCurrent:‚Äù line


                // NEW for micro-check
                const microCheckModal = document.getElementById('microCheckModal');
                const microCheckResponse = document.getElementById('microCheckResponse');
                const submitMicroCheckButton = document.getElementById('submitMicroCheckButton');
                // Enable / disable the "Continue" button based on typing
                if (microCheckResponse && submitMicroCheckButton) {
                    submitMicroCheckButton.disabled = true; // start disabled
                    microCheckResponse.addEventListener('input', () => {
                        const hasText = microCheckResponse.value.trim().length > 0;
                        submitMicroCheckButton.disabled = !hasText;
                    });
                }

                // Quick Log Modal Elements
                const quickLogModal = document.getElementById('quickLogModal');
                const quickLogInput = document.getElementById('quickLogInput');
                const saveQuickLogButton = document.getElementById('saveQuickLogButton');
                const cancelQuickLogButton = document.getElementById('cancelQuickLogButton');

                // Positive Action Modal Elements
                const positiveActionModal = document.getElementById('positiveActionModal');
                const logPositiveActionButton = document.getElementById('logPositiveActionButton');
                const positiveActionInput = document.getElementById('positiveActionInput');
                const savePositiveActionButton = document.getElementById('savePositiveActionButton');
                const cancelPositiveActionButton = document.getElementById('cancelPositiveActionButton');

                // Grounding / Check-Out Modal Elements
                const groundingModal = document.getElementById('groundingModal');
                const groundingCommitInput = document.getElementById('groundingCommitInput');
                const skipGroundingButton = document.getElementById('skipGroundingButton');
                const confirmGroundingButton = document.getElementById('confirmGroundingButton');

                // New Haptic Slider Elements
                const hapticIntensitySlider = document.getElementById('hapticIntensitySlider');
                const hapticIntensityValue = document.getElementById('hapticIntensityValue');

                // NEW: Challenge prep time slider
                const challengePrepSlider = document.getElementById('challengePrepSlider');
                const challengePrepValue = document.getElementById('challengePrepValue');



                // === Theme Configuration (Simplified from original) ===
                const THEMES = {
                    dark: {
                        bodyBg: '#111827', headerBg: 'bg-gray-900/95', headerText: 'text-white',
                        headerDescText: 'text-gray-400', headerBorder: 'border-gray-700',
                        meterBg: '#2D3748', meterInnerBg: '#1F2937', meterBorder: '#1F2937',
                        modalBg: 'bg-gray-900/90', cutHealText: 'text-white', breathText: 'text-white',
                        challengeText: 'text-white', affirmText: 'text-white', themeText: 'text-white',
                        logText: 'text-white', settingsText: 'text-white', undoText: 'text-white',
                        clearText: 'text-white', infoText: 'text-white',
                        themeBg: 'bg-blue-600', themeHover: 'hover:bg-blue-500', themeBorder: 'border-blue-800',
                        themeBorderHover: 'hover:border-blue-700',
                        logBg: 'bg-purple-600', logHover: 'hover:bg-purple-500', logBorder: 'border-purple-800',
                        logBorderHover: 'hover:border-purple-700', settingsBg: 'bg-gray-600', settingsHover: 'hover:bg-gray-500',
                        settingsBorder: 'border-gray-800', settingsBorderHover: 'hover:border-gray-700', undoBg: 'bg-gray-600',
                        undoHover: 'hover:bg-gray-500', undoBorder: 'border-gray-800', undoBorderHover: 'hover:border-gray-700',
                        clearBg: 'bg-gray-600', clearHover: 'hover:bg-gray-500', clearBorder: 'border-gray-800',
                        clearBorderHover: 'hover:border-gray-700',
                        infoBg: 'bg-gray-500', infoHover: 'hover:bg-gray-600', infoBorder: 'border-gray-700',
                        infoBorderHover: 'hover:border-gray-800',
                        canvasBg: '#111827',
                        iconPath: '<path d="M7.75 4A2.75 2.75 0 0 1 10.5 6.75v10.5a.75.75 0 0 0 1.5 0V6.75a4.25 4.25 0 0 0-8.5 0v10.5a.75.75 0 0 0 1.5 0V6.75A2.75 2.75 0 0 1 7.75 4Z" />',
                        modeName: 'themeDark'
                    },
                    light: {
                        bodyBg: '#F3F4F6', headerBg: 'bg-white/95', headerText: 'text-gray-900',
                        headerDescText: 'text-gray-600', headerBorder: 'border-gray-300',
                        meterBg: '#D1D5DB', meterInnerBg: '#F9FAFB', meterBorder: '#E5E7EB',
                        modalBg: 'bg-white/90', cutHealText: 'text-white', breathText: 'text-white',
                        challengeText: 'text-white', affirmText: 'text-white', themeText: 'text-white',
                        logText: 'text-white', settingsText: 'text-gray-900', undoText: 'text-gray-900',
                        clearText: 'text-gray-900', infoText: 'text-white',
                        themeBg: 'bg-blue-600', themeHover: 'hover:bg-blue-500', themeBorder: 'border-blue-800',
                        themeBorderHover: 'hover:border-blue-700',
                        logBg: 'bg-purple-600', logHover: 'hover:bg-purple-500', logBorder: 'border-purple-800',
                        logBorderHover: 'hover:border-purple-700', settingsBg: 'bg-white', settingsHover: 'hover:bg-gray-50',
                        settingsBorder: 'border-gray-300', settingsBorderHover: 'hover:border-gray-400', undoBg: 'bg-white',
                        undoHover: 'hover:bg-gray-50', undoBorder: 'border-gray-300', undoBorderHover: 'hover:border-gray-400',
                        clearBg: 'bg-white', clearHover: 'hover:bg-gray-50', clearBorder: 'border-gray-300',
                        clearBorderHover: 'hover:border-gray-400',
                        infoBg: 'bg-gray-500', infoHover: 'hover:bg-gray-600', infoBorder: 'border-gray-700',
                        infoBorderHover: 'hover:border-gray-800',
                        canvasBg: '#F3F4F6',
                        iconPath: '<path fill-rule="evenodd" d="M10 2a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0v-1.5A.75.75 0 0 1 10 2Zm6.28 12.78a.75.75 0 0 0-1.06-1.06l-1.06 1.06a.75.75 0 0 0 1.06 1.06l1.06-1.06ZM3.72 14.72a.75.75 0 0 0 1.06 1.06l-1.06 1.06a.75.75 0 0 0-1.06-1.06l1.06 1.06ZM16.03 5.97a.75.75 0 0 0-1.06-1.06l-1.06 1.06a.75.75 0 0 0 1.06 1.06l1.06-1.06ZM5.94 4.66a.75.75 0 0 0 1.06-1.06L5.94 2.54a.75.75 0 0 0-1.06 1.06l1.06 1.06ZM10 18a.75.75 0 0 1-.75-.75v-1.5a.75.75 0 0 1 1.5 0v1.5a.75.75 0 0 1-.75-.75ZM6.75 10a3.25 3.25 0 1 1 6.5 0 3.25 3.25 0 0 1-6.5 0Z" clip-rule="evenodd" />',
                        modeName: 'theme'
                    }
                };

                // === Translation Data ===
                const translations = {
                    en: {
                        title1: "Cut Me", title2: "Instead of You", description: "A touch tool for visualizing and managing emotional tension.",
                        guideTitle: "Guide: Cut & Heal Modes",
                        close: "Close",
                        guideDiffTitle: "What‚Äôs the difference?",
                        cutModeLabel: "Cut Mode",
                        cutModeDesc: "draw fast red strokes to ‚Äúexternalize‚Äù urges.",
                        healModeLabel: "Heal Mode",
                        healModeDesc: "slower, gentler input; no ‚Äúcut‚Äù pattern, intended for calm recovery doodles.",
                        quickStartTitle: "Quick Start",
                        quick1: "Toggle <strong>Cut / Heal</strong> with the mode button.",
                        quick2: "Press ‚éå <strong>Undo</strong> to remove the last stroke, or <strong>Clear All</strong> to wipe the canvas.",
                        quick3: "Use the <strong>Breath</strong> button anytime to steady yourself.",
                        quick4: "<strong>Affirmation</strong> check-in to write encouragement words to help you.",
                        quick5: "Use <strong>Challenge</strong> to distract those thoughts of anxiety or self-harm urges.",
                        cutTipsTitle: "Tips for Cut Mode",
                        cutTip1: "Short, sharp strokes = better ‚Äúrelease‚Äù feel.",
                        cutTip2: "Zoom your attention to the stroke + breath cycle (exhale while drawing).",
                        healTipsTitle: "Tips for Heal Mode",
                        healTip1: "Slow, looping shapes or gentle shading.",
                        healTip2: "Pair with affirmations or a sensory challenge if you feel overloaded.",
                        reminderLabel: "Reminder:",
                        reminderText: "This tool is a coping aid, not medical advice. If you‚Äôre in danger or thinking about self-harm, please seek immediate help.",
                        appInfoBtn: "App Info / Content Notice",
                        cutMode: "Cut Mode", healMode: "Heal Mode (Draw Light)", takeBreath: "Take a Breath", challenge: "Challenge",
                        affirmations: "Affirmations", theme: "Light Mode", themeDark: "Dark Mode", log: "Log", info: "Info",
                        emailTitle: "Select Email Client", emailDesc: "Choose your preferred email client. The session summary will be copied to your clipboard first.",
                        settings: "Settings", undo: "Undo", clearAll: "Clear All", breatheIn: "Breathe In...",
                        breatheHold: "Hold...", breatheOut: "Breathe Out...", overloadTitle: "Mental Overload!",
                        overloadDesc: "Your Mental Load is at 100%. Drawing is disabled.", overloadInstruct: "Please use a coping tool to relieve the tension.",
                        welcomeTitle: "Welcome - Please Read", welcomeIntent: "This is a tool, not a game. It's designed to be a safe alternative to help you visualize and manage overwhelming feelings.",
                        welcomeWarning: "Content Warning:", welcomeWarningText: "This application contains metaphors for self-harm. If you are in crisis, please close this and use the resources below.",
                        welcomeGoal: "Your Goal:", welcomeGoalText: "Your goal is not to fill the screen, but to use the 'Breathe' and 'Challenge' tools to manage your 'Mental Load' (the meter at the bottom left). This is a tool for practicing relief.",
                        welcomeCrisisTitle: "Immediate Crisis Support:", welcomeCrisisLink: "IASP International Help Finder", welcomeCrisisUS: "(If you are in the US, dial 988)",
                        welcomeUnderstand: "I Understand", checkinTitle: "Checking In...", checkinRemember: "Remember, whatever you're going through, you don't have to face it alone. Please look up a local crisis center or hotline immediately.",
                        checkinClose: "I'm Okay / Close", challengeTitle: "CRISIS: Sensory Challenge!", challengeDesc: "Override the urge by using an intense coping skill.",
                        challengeTaskTitle: "Your Task:", challengeTime: "Time remaining:", challengeInstruct: "Start the task NOW. Press the button below only when the time runs out.",
                        challengeIceCubes: "Go find 5 ice cubes and hold them tightly in your hands until they melt completely.",
                        challengeColdSplash: "Splash your face with ice-cold water 5 times. (Hold your breath gently during each splash.)",
                        challengeSourCandy: "Put a piece of lemon or strong sour candy in your mouth for 30 seconds. Focus only on the taste.",
                        challengeStrongScent: "Find a strong scent (peppermint oil, vinegar, or perfume) and breathe it in deeply for 5 breaths.",
                        challengeIntenseExercise: "Do 1 minute of intense exercise (jumping jacks or running in place) until you feel physically tired.",
                        challengeRubberBand: "Take a rubber band or hair tie and snap it lightly on your wrist 10 times. (Safe discomfort only!)",
                        challengeMarching: "March with high knees for 1 minute. Tap opposite hand to opposite knee and cross your body‚Äôs center each step.",
                        challengeComplete: "Complete Challenge (Wait for timer)", challengeCancel: "Cancel (I need immediate help)", challengeFocus: "Keep your finger inside the moving target for 15 seconds.",
                        anotherChallenge: "This one doesn‚Äôt fit right now‚Ä¶",
                        logTitle: "Activity Log", logAddNote: "Add Note", logTime: "Time", logAction: "Action", logChange: "ML Change",
                        logExportTitle: "Export Session", logExportPDF: "Save as PDF Report", logExportCSV: "Save as CSV Data", logExportEmail: "Email to Professional",
                        logExportCopy: "Copy Session Summary", logSummaryAccumulation: "Accumulation (Drips):", logSummaryRelief: "Relief (Breaths/Challenges/Undos):",
                        logSummaryNet: "Net Change:", logDrips: "drips", logRelief: "Relief", logChallenges: "Challenges", logUndos: "Undos",
                        logActionCut: "Cut Drip (Accumulation)", logActionBreath: "Breath (Relief)", logActionChallenge: "Challenge (Relief)",
                        logActionUndo: "Undo Cut (Relief)", logActionReset: "Full Reset (Relief)", logActionNote: "Journal Note", logActionQuick: "Quick Log (Relief)",
                        logStreak: "Current Streak: {count} Day(s)",
                        noteTitle: "Add Journal Note", noteDesc: "Add a note about what you're feeling or what triggered this moment. It will be saved in your log.",
                        notePlaceholder: "e.g., 'Felt overwhelmed after class,' 'Argument with family'", affirmTitle: "Personalized Affirmations",
                        affirmDesc: "Add personalized affirmations that will appear during your check-ins. These words of encouragement can help you through difficult moments.",
                        affirmPlaceholder: "e.g., 'I am safe in this moment.'", affirmPrioritize: "Prioritize my affirmations during high tension moments",
                        affirmClear: "Clear All", affirmRemove: "Remove", settingsTitle: "Settings", settingsLang: "Language / Bahasa:",
                        settingsVisual: "Visual Settings", settingsDrips: "Enable Drip & Pool Effects", settingsShake: "Enable Tension Screen Shake",
                        settingsAudio: "Audio Settings",
                        settingsHaptic: "Haptic Feedback", // NEW
                        hapticIntensity: "Intensity:", // NEW
                        hapticNote: "Set to 0% to disable all vibrations.", // NEW
                        close: "Close", save: "Save", cancel: "Cancel", add: "Add", notifyCopied: "Copied to clipboard!",
                        notifyEmail: "Copied! Now paste into your email.", healNotifyTitle: "Cut Healed!",
                        healNotifyDesc: "Notice the 'Mental Load' didn't change? That's intentional. Healing is the first step. Now, use 'Breathe' or 'Challenge' to relieve the underlying tension.",
                        quickLogTitle: "Quick Check-in", quickLogDesc: "What triggered this moment? Logging gives you a small pause.",
                        saveQuickLog: "Log & Pause",
                        positiveActionTitle: "Log Positive Action",
                        positiveActionDesc: "Record an action you took that was positive, helpful, or neutral. This supports healthy habit building.",
                        positiveActionPlaceholder: "e.g., 'Took a 10 min walk,' 'Drank water,' 'Called a friend'",
                        logPositiveAction: "Log Action",
                        logActionPositive: "Positive Action (Relief)",
                        groundingTitle: "Grounding Check-Out",
                        groundingIntro: "Before you head back to your day, let‚Äôs do a short grounding check-out so you leave this space feeling a bit more settled.",
                        grounding5: "5 things you can see.",
                        grounding4: "4 things you can touch.",
                        grounding3: "3 things you can hear.",
                        grounding2: "2 things you can smell.",
                        grounding1: "1 thing you can taste.",
                        groundingCommitLabel: "One small action you‚Äôll take next:",
                        groundingCommitPlaceholder: "I will drink a glass of water.",
                        groundingExamples: "This can be simple, like ‚ÄúI will stretch my shoulders‚Äù, ‚ÄúI will step away from my screen‚Äù, or ‚ÄúI will text my safety contact‚Äù.",
                        groundingSkip: "Skip for now",
                        groundingDone: "Done, back to canvas",
                        settingsChallengePrepTitle: "Challenge Prep Time",
                        settingsChallengePrepLabel: "Get-ready countdown:",
                        settingsChallengePrepHint: "Set to 0s to start the challenge immediately with no prep popup." // NO comma here (last key)
                                            },
                    ms: {
                        title1: "Lukaiku", title2: "Gantimu", description: "Alat sentuhan untuk memvisualisasikan dan menguruskan ketegangan emosi.",
                        guideTitle: "Panduan: Mod Cut & Heal",
                        close: "Tutup",
                        guideDiffTitle: "Apa bezanya?",
                        cutModeLabel: "Mod Cut",
                        cutModeDesc: "lukis garisan merah laju untuk ‚Äòluahkan‚Äô desakan.",
                        healModeLabel: "Mod Heal",
                        healModeDesc: "input lebih perlahan dan lembut; tanpa corak ‚Äòcut‚Äô, sesuai untuk lakaran pemulihan yang menenangkan.",
                        quickStartTitle: "Mula Pantas",
                        quick1: "Togol <strong>Cut / Heal</strong> dengan butang mod.",
                        quick2: "Tekan ‚éå <strong>Undo</strong> untuk buang garisan terakhir, atau <strong>Clear All</strong> untuk kosongkan kanvas.",
                        quick3: "Guna butang <strong>Breath</strong> bila-bila masa untuk tenangkan diri.",
                        quick4: "Semak <strong>Affirmation</strong> untuk menulis kata semangat membantu anda.",
                        quick5: "Guna <strong>Challenge</strong> untuk alihkan fikiran cemas atau dorongan mencederakan diri.",
                        cutTipsTitle: "Petua untuk Mod Cut",
                        cutTip1: "Garisan pendek dan tajam = rasa ‚Äòlepaskan‚Äô yang lebih baik.",
                        cutTip2: "Fokus pada kitaran garisan + pernafasan (hembus nafas sambil melukis).",
                        healTipsTitle: "Petua untuk Mod Heal",
                        healTip1: "Bentuk melingkar perlahan atau lorekan lembut.",
                        healTip2: "Gabungkan dengan affirmations atau cabaran sensori jika terasa terbeban.",
                        reminderLabel: "Peringatan:",
                        reminderText: "Alat ini hanyalah bantuan penanganan, bukan nasihat perubatan. Jika anda dalam bahaya atau terfikir untuk mencederakan diri, dapatkan bantuan segera.",
                        appInfoBtn: "Maklumat Apl / Notis Kandungan",
                        cutMode: "Mod Luka", healMode: "Mod Pulih (Cahaya)", takeBreath: "Tarik Nafas", challenge: "Cabaran",
                        affirmations: "Afirmasi", theme: "Mod Cerah", themeDark: "Mod Gelap", log: "Log", info: "Maklumat",
                        emailTitle: "Pilih Klien E-mel", emailDesc: "Pilih klien e-mel pilihan anda. Ringkasan sesi akan disalin ke papan keratan anda dahulu.",
                        settings: "Tetapan", undo: "Buat Asal", clearAll: "Padam Semua", breatheIn: "Tarik Nafas...",
                        breatheHold: "Tahan...", breatheOut: "Hembus Nafas...", overloadTitle: "Beban Mental Penuh!",
                        overloadDesc: "Beban Mental anda sudah 100%. Lukisan dilumpuhkan.", overloadInstruct: "Sila guna alat daya tindak untuk melegakan ketegangan.",
                        welcomeTitle: "Selamat Datang - Sila Baca", welcomeIntent: "Ini adalah alat, bukan permainan. Ia direka sebagai alternatif selamat untuk membantu anda memvisualisasikan dan menguruskan perasaan yang terbeban.",
                        welcomeWarning: "Amaran Kandungan:", welcomeWarningText: "Aplikasi ini mengandungi metafora untuk mencederakan diri. Jika anda dalam krisis, sila tutup dan guna sumber di bawah.",
                        welcomeGoal: "Matlamat Anda:", welcomeGoalText: "Matlamat anda bukan untuk mengisi skrin, tetapi untuk menggunakan alat 'Nafas' dan 'Cabaran' untuk menguruskan 'Beban Mental' anda (meter di kiri bawah). Ini adalah alat untuk berlatih kelegaan.",
                        welcomeCrisisTitle: "Sokongan Krisis Segera:", welcomeCrisisLink: "Pencari Bantuan Antarabangsa IASP", welcomeCrisisUS: "(Jika anda di AS, dail 988)",
                        welcomeUnderstand: "Saya Faham", checkinTitle: "Daftar Masuk...", checkinRemember: "Ingat, apa jua yang anda lalui, anda tidak perlu menghadapinya seorang diri. Sila cari pusat krisis atau talian hotline tempatan dengan segera.",
                        checkinClose: "Saya OK / Tutup", challengeTitle: "KRISIS: Cabaran Deria!", challengeDesc: "Atasi desakan dengan menggunakan kemahiran daya tindak yang intensif.",
                        challengeTaskTitle: "Tugas Anda:", challengeTime: "Masa berbaki:", challengeInstruct: "Mulakan tugas SEKARANG. Tekan butang di bawah hanya apabila masa tamat.",
                        challengeIceCubes: "Cari 5 ketul ais dan genggam kuat di tangan anda sehingga ia cair sepenuhnya.",
                        challengeColdSplash: "Percikkan air sangat sejuk ke muka anda 5 kali. (Tarik nafas, tahan sekejap semasa percikan.)",
                        challengeSourCandy: "Ambil sepotong lemon atau gula-gula masam yang kuat selama 30 saat. Fokus hanya pada rasanya.",
                        challengeStrongScent: "Cari bau yang kuat (seperti minyak peppermint, cuka atau minyak wangi) dan tarik nafas dalam sebanyak 5 kali.",
                        challengeIntenseExercise: "Lakukan 1 minit senaman intensif (lompat bintang atau berlari di tempat) sehingga anda rasa penat secara fizikal.",
                        challengeRubberBand: "Ambil getah rambut atau gelang getah dan petik perlahan pada pergelangan tangan anda 10 kali. (Hanya ketidakselesaan yang selamat!)",
                        challengeMarching: "Berjalan tempat dengan lutut diangkat tinggi selama 1 minit. Tepuk tangan bertentangan ke lutut bertentangan untuk setiap langkah.",
                        challengeComplete: "Selesai Cabaran (Tunggu pemasa)", challengeCancel: "Batal (Saya perlukan bantuan segera)", challengeFocus: "Kekalkan jari anda di dalam sasaran bergerak selama 15 saat.",
                        anotherChallenge: "Yang ini kurang sesuai buat masa ini‚Ä¶",
                        logTitle: "Log Aktiviti", logAddNote: "Tambah Nota", logTime: "Masa", logAction: "Tindakan", logChange: "Perubahan BM",
                        logExportTitle: "Eksport Sesi", logExportPDF: "Simpan sebagai Laporan PDF", logExportCSV: "Simpan sebagai Data CSV", logExportEmail: "E-mel kepada Profesional",
                        logExportCopy: "Salin Ringkasan Sesi", logSummaryAccumulation: "Pengumpulan (Titisan):", logSummaryRelief: "Kelegaan (Nafas/Cabaran/Buat Asal):",
                        logSummaryNet: "Perubahan Bersih:", logDrips: "titisan", logRelief: "Kelegaan", logChallenges: "Cabaran", logUndos: "Buat Asal",
                        logActionCut: "Titisan Luka (Pengumpulan)", logActionBreath: "Nafas (Kelegaan)", logActionChallenge: "Cabaran (Kelegaan)",
                        logActionUndo: "Buat Asal Luka (Kelegaan)", logActionReset: "Set Semula Penuh (Kelegaan)", logActionNote: "Nota Jurnal", logActionQuick: "Log Cepat (Kelegaan)",
                        logStreak: "Siri Semasa: {count} Hari", // NEW STREAK KEY
                        noteTitle: "Tambah Nota Jurnal", noteDesc: "Tambah nota tentang apa yang anda rasa atau apa yang mencetuskan detik ini. Ia akan disimpan dalam log anda.",
                        notePlaceholder: "cth., 'Rasa terbeban selepas kelas,' 'Bergaduh dengan keluarga'", affirmTitle: "Afirmasi Peribadi",
                        affirmDesc: "Tambah afirmasi peribadi yang akan muncul semasa daftar masuk anda. Kata-kata semangat ini boleh membantu anda melalui detik sukar.",
                        affirmPlaceholder: "cth., 'Saya selamat pada masa ini.'", affirmPrioritize: "Utamakan afirmasi saya semasa detik ketegangan tinggi",
                        affirmClear: "Padam Semua", affirmRemove: "Padam", settingsTitle: "Tetapan", settingsLang: "Bahasa / Language:",
                        settingsVisual: "Tetapan Visual", settingsDrips: "Aktifkan Kesan Titisan & Kolam", settingsShake: "Aktifkan Getaran Skrin Ketegangan",
                        settingsAudio: "Tetapan Audio", // NEW
                        settingsHaptic: "Maklum Balas Haptik", // NEW
                        hapticIntensity: "Keamatan:", // NEW
                        hapticNote: "Tetapkan kepada 0% untuk melumpuhkan semua getaran.", // NEW
                        close: "Tutup", save: "Simpan", cancel: "Batal", add: "Tambah", notifyCopied: "Disalin ke papan keratan!",
                        notifyEmail: "Disalin! Sekarang tampal ke dalam e-mel anda.", healNotifyTitle: "Luka Dipulih!",
                        healNotifyDesc: "Perasan 'Beban Mental' tidak berubah? Itu sengaja. Pemulihan adalah langkah pertama. Sekarang, guna 'Nafas' atau 'Cabaran' untuk melegakan ketegangan yang masih ada.",
                        quickLogTitle: "Daftar Masuk Cepat", quickLogDesc: "Apa yang mencetuskan detik ini? Log masuk memberi anda jeda kecil.",
                        saveQuickLog: "Log Masuk & Jeda",
                        positiveActionTitle: "Log Tindakan Positif",
                        positiveActionDesc: "Catatkan tindakan yang anda ambil yang positif, membantu, atau neutral. Ini menyokong pembinaan tabiat sihat.",
                        positiveActionPlaceholder: "cth., 'Berjalan 10 minit,' 'Minum air,' 'Hubungi rakan'",
                        logPositiveAction: "Log Tindakan",
                        logActionPositive: "Tindakan Positif (Kelegaan)",
                        groundingTitle: "Semakan Grounding",
                        groundingIntro: "Sebelum anda kembali meneruskan hari anda, mari kita buat semakan grounding yang ringkas supaya anda meninggalkan ruang ini dengan rasa sedikit lebih tenang.",
                        grounding5: "5 perkara yang anda boleh lihat.",
                        grounding4: "4 perkara yang anda boleh sentuh.",
                        grounding3: "3 perkara yang anda boleh dengar.",
                        grounding2: "2 perkara yang anda boleh bau.",
                        grounding1: "1 perkara yang anda boleh rasa di mulut.",
                        groundingCommitLabel: "Satu tindakan kecil yang akan anda lakukan selepas ini:",
                        groundingCommitPlaceholder: "Saya akan minum segelas air.",
                        groundingExamples: "Ini boleh jadi sangat mudah, seperti \"Saya akan regangkan bahu\", \"Saya akan menjauh sekejap dari skrin\", atau \"Saya akan mesej orang sokongan saya\".",
                        groundingSkip: "Langkau dahulu",
                        groundingDone: "Selesai, kembali ke kanvas",
                        settingsChallengePrepTitle: "Masa Persediaan Cabaran",
                        settingsChallengePrepLabel: "Kiraan detik bersedia:",
                        settingsChallengePrepHint: "Tetapkan ke 0s untuk mulakan cabaran serta-merta tanpa tetingkap persediaan."

                                    },
                    zh: {
                        title1: "Ââ≤Êàë", title2: "‰ª£‰Ω†", description: "‰∏Ä‰∏™ÂèØËßÜÂåñÂíåÁÆ°ÁêÜÊÉÖÁª™ÂéãÂäõÁöÑËß¶Êë∏Â∑•ÂÖ∑„ÄÇ",
                        guideTitle: "ÊåáÂçóÔºöCut ‰∏é Heal Ê®°Âºè",
                        close: "ÂÖ≥Èó≠",
                        guideDiffTitle: "‰∏§ËÄÖÊúâ‰ªÄ‰πàÂå∫Âà´Ôºü",
                        cutModeLabel: "Cut Ê®°Âºè",
                        cutModeDesc: "Áî®Âø´ÈÄüÁ∫¢Ëâ≤Á¨îÂàíÂ∞ÜÂÜ≤Âä®‚ÄúÂ§ñÂåñ‚Äù„ÄÇ",
                        healModeLabel: "Heal Ê®°Âºè",
                        healModeDesc: "Êõ¥ÊÖ¢„ÄÅÊõ¥ÊüîÂíåÔºõÊó†‚ÄúÂàáÂâ≤‚ÄùÁ∫πÁêÜÔºåÈÄÇÂêàÂπ≥ÈùôÁöÑ‰øÆÂ§çÊ∂ÇÈ∏¶„ÄÇ",
                        quickStartTitle: "Âø´ÈÄüÂºÄÂßã",
                        quick1: "Áî®Ê®°ÂºèÊåâÈíÆÂú® <strong>Cut / Heal</strong> Èó¥ÂàáÊç¢„ÄÇ",
                        quick2: "Êåâ ‚éå <strong>Êí§ÈîÄ</strong> Âà†Èô§‰∏ä‰∏ÄÁ¨îÔºåÊàñÁî® <strong>Ê∏ÖÁ©∫</strong> Êì¶Èô§ÁîªÂ∏É„ÄÇ",
                        quick3: "‰ªª‰ΩïÊó∂ÂÄôÈÉΩÂèØ‰ΩøÁî® <strong>ÂëºÂê∏</strong> ÊåâÈíÆÁ®≥ÂÆöÊÉÖÁª™„ÄÇ",
                        quick4: "ÈÄöËøá <strong>Ëá™ÊàëËÇØÂÆö</strong> ÂÜô‰∏ãÈºìÂä±ÁöÑËØùÂ∏ÆÂä©Ëá™Â∑±„ÄÇ",
                        quick5: "‰ΩøÁî® <strong>ÊåëÊàò</strong> ËΩ¨ÁßªÁÑ¶ËôëÊàñËá™‰º§ÂÜ≤Âä®ÁöÑÊÉ≥Ê≥ï„ÄÇ",
                        cutTipsTitle: "Cut Ê®°ÂºèÂ∞èË¥¥Â£´",
                        cutTip1: "Áü≠‰øÉ„ÄÅÂπ≤ËÑÜÁöÑÁ¨îÂàíÊõ¥Êúâ‚ÄúÈáäÊîæ‚ÄùÊÑü„ÄÇ",
                        cutTip2: "Â∞ÜÊ≥®ÊÑèÂäõËÅöÁÑ¶Âú®Á¨îÂàíÔºãÂëºÂê∏ËäÇÂ•èÔºàÁªòÂà∂Êó∂ÂëºÊ∞îÔºâ„ÄÇ",
                        healTipsTitle: "Heal Ê®°ÂºèÂ∞èË¥¥Â£´",
                        healTip1: "ÁºìÊÖ¢ÁöÑÂúÜÂºß„ÄÅÂæ™ÁéØÁ∫øÊù°ÊàñÊüîÂíåÁöÑÊéíÁ∫ø„ÄÇ",
                        healTip2: "Ëã•ÊÑüÂà∞Ë¥üËç∑ËøáÈáçÔºåÂèØÊê≠ÈÖçËá™ÊàëËÇØÂÆöÊàñÊÑüÂÆòÊåëÊàò„ÄÇ",
                        reminderLabel: "ÊèêÈÜíÔºö",
                        reminderText: "Êú¨Â∑•ÂÖ∑‰ªÖ‰∏∫Â∫îÂØπËæÖÂä©ÔºåÂπ∂ÈùûÂåªÁñóÂª∫ËÆÆ„ÄÇÂ¶ÇÊúâÂç±Èô©ÊàñËá™‰º§ÂøµÂ§¥ÔºåËØ∑Á´ãÂç≥ÂØªÊ±ÇÂ∏ÆÂä©„ÄÇ",
                        appInfoBtn: "Â∫îÁî®‰ø°ÊÅØ / ÂÜÖÂÆπÊèêÁ§∫",
                        cutMode: "ÂàáÂâ≤Ê®°Âºè", healMode: "Ê≤ªÊÑàÊ®°Âºè (ÁªòÂà∂ÂÖâ)", takeBreath: "Ê∑±ÂëºÂê∏", challenge: "ÊåëÊàò",
                        affirmations: "Ëá™ÊàëËÇØÂÆö", theme: "ÊµÖËâ≤Ê®°Âºè", themeDark: "Ê∑±Ëâ≤Ê®°Âºè", log: "Êó•Âøó", info: "‰ø°ÊÅØ",
                        emailTitle: "ÈÄâÊã©ÁîµÂ≠êÈÇÆ‰ª∂ÂÆ¢Êà∑Á´Ø", emailDesc: "ÈÄâÊã©ÊÇ®È¶ñÈÄâÁöÑÁîµÂ≠êÈÇÆ‰ª∂ÂÆ¢Êà∑Á´Ø„ÄÇ‰ºöËØùÊëòË¶ÅÂ∞ÜÈ¶ñÂÖàÂ§çÂà∂Âà∞ÊÇ®ÁöÑÂâ™Ë¥¥Êùø„ÄÇ",
                        settings: "ËÆæÁΩÆ", undo: "Êí§ÈîÄ", clearAll: "ÂÖ®ÈÉ®Ê∏ÖÈô§", breatheIn: "Âê∏Ê∞î...",
                        breatheHold: "Â±è‰Ωè...", breatheOut: "ÂëºÊ∞î...", overloadTitle: "Á≤æÁ•ûË∂ÖË¥üËç∑ÔºÅ",
                        overloadDesc: "ÊÇ®ÁöÑÁ≤æÁ•ûË¥üËç∑Â∑≤Ëææ100%„ÄÇÁªòÂõæÂäüËÉΩÂ∑≤Á¶ÅÁî®„ÄÇ", overloadInstruct: "ËØ∑‰ΩøÁî®Â∫îÂØπÂ∑•ÂÖ∑Êù•ÁºìËß£ÂéãÂäõ„ÄÇ",
                        welcomeTitle: "Ê¨¢Ëøé - ËØ∑ÈòÖËØª", welcomeIntent: "ËøôÊòØ‰∏Ä‰∏™Â∑•ÂÖ∑Ôºå‰∏çÊòØ‰∏Ä‰∏™Ê∏∏Êàè„ÄÇÂÆÉÊó®Âú®‰Ωú‰∏∫‰∏Ä‰∏™ÂÆâÂÖ®ÁöÑÊõø‰ª£ÂìÅÔºåÂ∏ÆÂä©ÊÇ®Â∞ÜÂéãÂÄíÊÄßÁöÑÊÑüËßâÂèØËßÜÂåñÂπ∂ËøõË°åÁÆ°ÁêÜ„ÄÇ",
                        welcomeWarning: "ÂÜÖÂÆπË≠¶ÂëäÔºö", welcomeWarningText: "Ê≠§Â∫îÁî®Á®ãÂ∫èÂåÖÂê´Ëá™Êàë‰º§ÂÆ≥ÁöÑÊØîÂñª„ÄÇÂ¶ÇÊûúÊÇ®Ê≠£Â§Ñ‰∫éÂç±Êú∫‰πã‰∏≠ÔºåËØ∑ÂÖ≥Èó≠Ê≠§Â∫îÁî®Âπ∂‰ΩøÁî®‰ª•‰∏ãËµÑÊ∫ê„ÄÇ",
                        welcomeGoal: "ÊÇ®ÁöÑÁõÆÊ†áÔºö", welcomeGoalText: "ÊÇ®ÁöÑÁõÆÊ†á‰∏çÊòØÂ°´Êª°Â±èÂπïÔºåËÄåÊòØ‰ΩøÁî®‚ÄúÂëºÂê∏‚ÄùÂíå‚ÄúÊåëÊàò‚ÄùÂ∑•ÂÖ∑Êù•ÁÆ°ÁêÜÊÇ®ÁöÑ‚ÄúÁ≤æÁ•ûË¥üËç∑‚ÄùÔºàÂ∑¶‰∏ãËßíÁöÑ‰ª™Ë°®Ôºâ„ÄÇËøôÊòØ‰∏Ä‰∏™ÁªÉ‰π†ÁºìËß£ÁöÑÂ∑•ÂÖ∑„ÄÇ",
                        welcomeCrisisTitle: "Âç≥Êó∂Âç±Êú∫ÊîØÊåÅÔºö", welcomeCrisisLink: "IASP ÂõΩÈôÖÂ∏ÆÂä©Êü•ÊâæÂô®", welcomeCrisisUS: "ÔºàÂ¶ÇÊûúÊÇ®Âú®ÁæéÂõΩÔºåËØ∑Êã®Êâì 988Ôºâ",
                        welcomeUnderstand: "ÊàëÊòéÁôΩ‰∫Ü", checkinTitle: "Á≠æÂà∞‰∏≠...", checkinRemember: "ËØ∑ËÆ∞‰ΩèÔºåÊó†ËÆ∫ÊÇ®Ê≠£Âú®ÁªèÂéÜ‰ªÄ‰πàÔºåÊÇ®ÈÉΩ‰∏çÂøÖÁã¨Ëá™Èù¢ÂØπ„ÄÇËØ∑Á´ãÂç≥Êü•ÊâæÂΩìÂú∞ÁöÑÂç±Êú∫‰∏≠ÂøÉÊàñÁÉ≠Á∫ø„ÄÇ",
                        checkinClose: "ÊàëÊ≤°‰∫ã / ÂÖ≥Èó≠", challengeTitle: "Âç±Êú∫ÔºöÊÑüÂÆòÊåëÊàòÔºÅ", challengeDesc: "ÈÄöËøá‰ΩøÁî®Âº∫ÁÉàÁöÑÂ∫îÂØπÊäÄÂ∑ßÊù•ÂÖãÊúçÂÜ≤Âä®„ÄÇ",
                        challengeTaskTitle: "ÊÇ®ÁöÑ‰ªªÂä°Ôºö", challengeTime: "Ââ©‰ΩôÊó∂Èó¥Ôºö", challengeInstruct: "Á´ãÂç≥ÂºÄÂßã‰ªªÂä°„ÄÇ‰ªÖÂú®Êó∂Èó¥ËÄóÂ∞ΩÊó∂ÊâçÊåâ‰∏ãÈù¢ÁöÑÊåâÈíÆ„ÄÇ",
                        challengeIceCubes: "ÂéªÊâæ 5 ÂùóÂÜ∞ÂùóÔºåÁ¥ßÁ¥ßÊè°Âú®ÊâãÈáåÔºå‰∏ÄÁõ¥Âà∞ÂÆÉ‰ª¨ÂÆåÂÖ®ËûçÂåñ„ÄÇ",
                        challengeColdSplash: "Áî®ÂÜ∞ÂÜ∑ÁöÑÊ∞¥ÊãçÊâìËÑ∏ÈÉ® 5 Ê¨°„ÄÇÔºàÊØèÊ¨°ËΩªËΩªÂ±è‰ΩèÂëºÂê∏ÂÜçÊãç„ÄÇÔºâ",
                        challengeSourCandy: "Âê´‰∏ÄÁâáÊü†Ê™¨ÊàñÈùûÂ∏∏ÈÖ∏ÁöÑÁ≥ñ 30 ÁßíÔºåÂè™‰∏ìÊ≥®Âú®Âè£‰∏≠ÁöÑÂë≥ÈÅì„ÄÇ",
                        challengeStrongScent: "Êâæ‰∏ÄÁßçÂë≥ÈÅìÊØîËæÉÂº∫ÁöÑÊ∞îÂë≥ÔºàËñÑËç∑Á≤æÊ≤π„ÄÅÈÜãÊàñÈ¶ôÊ∞¥Á≠âÔºâÔºåÊ∑±ÂëºÂê∏ÂóÖÈóª 5 Âè£„ÄÇ",
                        challengeIntenseExercise: "ÂÅö 1 ÂàÜÈíüËæÉÊøÄÁÉàÁöÑËøêÂä®ÔºàÂºÄÂêàË∑≥ÊàñÂéüÂú∞Ë∑ëÔºâÔºåÁõ¥Âà∞Ë∫´‰ΩìÊÑüÂà∞ÊúâÁÇπÁ¥Ø„ÄÇ",
                        challengeRubberBand: "Êãø‰∏ÄÊù°Ê©°ÁöÆÁ≠ãÊàñÂèëÂúàÔºåÂú®ÊâãËÖï‰∏äËΩªËΩªÂºπ 10 ‰∏ã„ÄÇÔºàÂè™Ë¶ÅÂÆâÂÖ®„ÄÅ‰∏çËøáÂ∫¶ÁöÑÂà∫ÊøÄ„ÄÇÔºâ",
                        challengeMarching: "ÂéüÂú∞È´òÊä¨ËÖøËµ∞Ë∑Ø 1 ÂàÜÈíüÔºåÊØè‰∏ÄÊ≠•Áî®Áõ∏ÂèçÁöÑÊâãËß¶Á¢∞Áõ∏ÂèçÁöÑËÜùÁõñÔºåËÆ©Ë∫´‰Ωì‰∫§ÂèâÊëÜÂä®„ÄÇ",
                        challengeComplete: "ÂÆåÊàêÊåëÊàòÔºàÁ≠âÂæÖËÆ°Êó∂Âô®Ôºâ", challengeCancel: "ÂèñÊ∂àÔºàÊàëÈúÄË¶ÅÁ´ãÂç≥Â∏ÆÂä©Ôºâ", challengeFocus: "Â∞ÜÊÇ®ÁöÑÊâãÊåá‰øùÊåÅÂú®ÁßªÂä®ÁõÆÊ†áÂÜÖ 15 Áßí„ÄÇ",
                        anotherChallenge: "Ëøô‰∏™ÊöÇÊó∂‰∏çÂ§™ÂêàÈÄÇ‚Ä¶‚Ä¶",
                        logTitle: "Ê¥ªÂä®Êó•Âøó", logAddNote: "Ê∑ªÂä†Â§áÊ≥®", logTime: "Êó∂Èó¥", logAction: "Êìç‰Ωú", logChange: "Á≤æÁ•ûË¥üËç∑ÂèòÂåñ",
                        logExportTitle: "ÂØºÂá∫‰ºöËØù", logExportPDF: "Âè¶Â≠ò‰∏∫ PDF Êä•Âëä", logExportCSV: "Âè¶Â≠ò‰∏∫ CSV Êï∞ÊçÆ", logExportEmail: "ÂèëÈÄÅÁªô‰∏ì‰∏ö‰∫∫Â£´",
                        logExportCopy: "Â§çÂà∂‰ºöËØùÊëòË¶Å", logSummaryAccumulation: "ÁßØÁ¥ØÔºàÊª¥ËêΩÔºâÔºö", logSummaryRelief: "ÁºìËß£ÔºàÂëºÂê∏/ÊåëÊàò/Êí§ÈîÄÔºâÔºö",
                        logSummaryNet: "ÂáÄÂèòÂåñÔºö", logDrips: "Ê¨°Êª¥ËêΩ", logRelief: "Ê¨°ÁºìËß£", logChallenges: "Ê¨°ÊåëÊàò", logUndos: "Ê¨°Êí§ÈîÄ",
                        logActionCut: "ÂàáÂâ≤Êª¥ËêΩÔºàÁßØÁ¥ØÔºâ", logActionBreath: "ÂëºÂê∏ÔºàÁºìËß£Ôºâ", logActionChallenge: "ÊåëÊàòÔºàÁºìËß£Ôºâ",
                        logActionUndo: "Êí§ÈîÄÂàáÂâ≤ÔºàÁºìËß£Ôºâ", logActionReset: "ÂÆåÂÖ®ÈáçÁΩÆÔºàÁºìËß£Ôºâ", logActionNote: "Êó•ËÆ∞Â§áÊ≥®", logActionQuick: "Âø´ÈÄüËÆ∞ÂΩïÔºàÁºìËß£Ôºâ",
                        logStreak: "ÂΩìÂâçËøûÁª≠Â§©Êï∞Ôºö{count} Â§©", // NEW STREAK KEY
                        noteTitle: "Ê∑ªÂä†Êó•ËÆ∞Â§áÊ≥®", noteDesc: "Ê∑ªÂä†‰∏ÄÊù°ÂÖ≥‰∫éÊÇ®ÁöÑÊÑüÂèóÊàñËß¶ÂèëÊ≠§‰∫ã‰ª∂ÁöÑÂ§áÊ≥®„ÄÇÂÆÉÂ∞Ü‰øùÂ≠òÂú®ÊÇ®ÁöÑÊó•Âøó‰∏≠„ÄÇ",
                        notePlaceholder: "‰æãÂ¶ÇÔºå'‰∏ãËØæÂêéÊÑüÂà∞‰∏çÂ†™ÈáçË¥ü'Ôºå'‰∏éÂÆ∂‰∫∫‰∫âÂêµ'", affirmTitle: "‰∏™ÊÄßÂåñËÇØÂÆö",
                        affirmDesc: "Ê∑ªÂä†Â∞ÜÂú®ÊÇ®Á≠æÂà∞Êó∂Âá∫Áé∞ÁöÑ‰∏™ÊÄßÂåñËÇØÂÆö„ÄÇËøô‰∫õÈºìÂä±ÁöÑËØùËØ≠ÂèØ‰ª•Â∏ÆÂä©ÊÇ®Â∫¶ËøáÂõ∞ÈöæÊó∂Âàª„ÄÇ",
                        affirmPlaceholder: "‰æãÂ¶ÇÔºå'Âú®Ëøô‰∏ÄÂàªÔºåÊàëÊòØÂÆâÂÖ®ÁöÑ„ÄÇ'", affirmPrioritize: "Âú®Á≤æÁ•ûÁ¥ßÂº†Êó∂‰ºòÂÖàÊòæÁ§∫ÊàëÁöÑËÇØÂÆö",
                        affirmClear: "ÂÖ®ÈÉ®Ê∏ÖÈô§", affirmRemove: "ÁßªÈô§", settingsTitle: "ËÆæÁΩÆ", settingsLang: "ËØ≠Ë®Ä / Language:",
                        settingsVisual: "ËßÜËßâËÆæÁΩÆ", settingsDrips: "ÂêØÁî®Êª¥ËêΩÂíåÊ∞¥Ê±†ÊïàÊûú", settingsShake: "ÂêØÁî®ÂéãÂäõÂ±èÂπïÊäñÂä®",
                        settingsAudio: "Èü≥È¢ëËÆæÁΩÆ", // NEW
                        settingsHaptic: "Ëß¶ËßâÂèçÈ¶à", // NEW
                        hapticIntensity: "Âº∫Â∫¶:", // NEW
                        hapticNote: "ËÆæÁΩÆ‰∏∫ 0% ‰ª•Á¶ÅÁî®ÊâÄÊúâÊåØÂä®„ÄÇ", // NEW
                        close: "ÂÖ≥Èó≠", save: "‰øùÂ≠ò", cancel: "ÂèñÊ∂à", add: "Ê∑ªÂä†", notifyCopied: "Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥ÊùøÔºÅ",
                        notifyEmail: "Â∑≤Â§çÂà∂ÔºÅÁé∞Âú®Á≤òË¥¥Âà∞ÊÇ®ÁöÑÁîµÂ≠êÈÇÆ‰ª∂‰∏≠„ÄÇ", healNotifyTitle: "‰º§Âè£Â∑≤Ê≤ªÊÑàÔºÅ",
                        healNotifyDesc: "Ê≥®ÊÑèÂà∞‚ÄúÁ≤æÁ•ûË¥üËç∑‚ÄùÊ≤°ÊúâÊîπÂèòÂêóÔºüËøôÊòØÊïÖÊÑèÁöÑ„ÄÇÊ≤ªÊÑàÊòØÁ¨¨‰∏ÄÊ≠•„ÄÇÁé∞Âú®Ôºå‰ΩøÁî®‚ÄúÂëºÂê∏‚ÄùÊàñ‚ÄúÊåëÊàò‚ÄùÊù•ÁºìËß£ÊΩúÂú®ÁöÑÂéãÂäõ„ÄÇ",
                        quickLogTitle: "Âø´ÈÄüËÆ∞ÂΩï", quickLogDesc: "‰ªÄ‰πàËß¶Âèë‰∫ÜËøô‰∏ÄÂàªÔºüËÆ∞ÂΩïÂèØ‰ª•ÁªôÊÇ®‰∏Ä‰∏™Â∞èÂ∞èÁöÑÂÅúÈ°ø„ÄÇ",
                        saveQuickLog: "ËÆ∞ÂΩïÂπ∂ÂÅúÈ°ø",
                        positiveActionTitle: "ËÆ∞ÂΩïÁßØÊûÅË°åÂä®",
                        positiveActionDesc: "ËÆ∞ÂΩïÊÇ®ÈááÂèñÁöÑÁßØÊûÅ„ÄÅÊúâÂ∏ÆÂä©Êàñ‰∏≠Á´ãÁöÑË°åÂä®„ÄÇËøôÊúâÂä©‰∫éÂª∫Á´ãÂÅ•Â∫∑ÁöÑ‰π†ÊÉØ„ÄÇ",
                        positiveActionPlaceholder: "‰æãÂ¶ÇÔºå'Êï£Ê≠• 10 ÂàÜÈíü'Ôºå'ÂñùÊ∞¥'Ôºå'ÁªôÊúãÂèãÊâìÁîµËØù'",
                        logPositiveAction: "ËÆ∞ÂΩïË°åÂä®",
                        logActionPositive: "ÁßØÊûÅË°åÂä®ÔºàÁºìËß£Ôºâ",
                        groundingTitle: "Á®≥ÂÆöÊî∂Â∞æÁªÉ‰π†",
                        groundingIntro: "Âú®‰Ω†ÂõûÂà∞Êó•Â∏∏ÁîüÊ¥ª‰πãÂâçÔºåËÆ©Êàë‰ª¨ÂÅö‰∏Ä‰∏™ÁÆÄÁü≠ÁöÑÁ®≥ÂÆöÁªÉ‰π†ÔºåËÆ©‰Ω†Â∏¶ÁùÄÁ®çÂæÆÂπ≥Á®≥‰∏ÄÁÇπÁöÑÁä∂ÊÄÅÁ¶ªÂºÄËøô‰∏™Á©∫Èó¥„ÄÇ",
                        grounding5: "ËØ¥Âá∫‰Ω†ÁúãÂà∞ÁöÑ 5 Ê†∑‰∏úË•ø„ÄÇ",
                        grounding4: "ËØ¥Âá∫‰Ω†ÂèØ‰ª•Ëß¶Á¢∞ÁöÑ 4 Ê†∑‰∏úË•ø„ÄÇ",
                        grounding3: "ËØ¥Âá∫‰Ω†Âê¨Âà∞ÁöÑ 3 ÁßçÂ£∞Èü≥„ÄÇ",
                        grounding2: "ËØ¥Âá∫‰Ω†ÈóªÂà∞ÁöÑ 2 ÁßçÊ∞îÂë≥„ÄÇ",
                        grounding1: "ËØ¥Âá∫‰Ω†ÂèØ‰ª•Â∞ùÂà∞ÁöÑ 1 ÁßçÂë≥ÈÅì„ÄÇ",
                        groundingCommitLabel: "Êé•‰∏ãÊù•‰Ω†‰ºöÂÅöÁöÑ‰∏Ä‰ª∂Â∞è‰∫ãÔºö",
                        groundingCommitPlaceholder: "ÊàëË¶ÅÂñù‰∏ÄÊùØÊ∞¥„ÄÇ",
                        groundingExamples: "ÂèØ‰ª•ÂæàÁÆÄÂçïÔºå‰æãÂ¶Ç‚ÄúÊàë‰ºö‰º∏Â±ï‰∏Ä‰∏ãËÇ©ËÜÄ‚Äù„ÄÅ‚ÄúÊàë‰ºöÂÖàÁ¶ªÂºÄÂ±èÂπï‰∏Ä‰ºöÂÑø‚ÄùÔºåÊàñ‚ÄúÊàë‰ºöÁªôÊàëÁöÑÂÆâÂÖ®ËÅîÁ≥ª‰∫∫ÂèëËÆØÊÅØ‚Äù„ÄÇ",
                        groundingSkip: "ÊöÇÊó∂Ë∑≥Ëøá",
                        groundingDone: "ÂÆåÊàêÔºåÂõûÂà∞ÁîªÂ∏É",
                        settingsChallengePrepTitle: "ÊåëÊàòÂáÜÂ§áÊó∂Èó¥",
                        settingsChallengePrepLabel: "ÂáÜÂ§áÂÄíËÆ°Êó∂Ôºö",
                        settingsChallengePrepHint: "ËÆæ‰∏∫ 0 ÁßíÂèØÁ´ãÂç≥ÂºÄÂßãÊåëÊàòÔºåÊó†ÈúÄÂáÜÂ§áÂºπÁ™ó„ÄÇ",
                    },
                    ta: {
                        title1: "‡Æµ‡ØÜ‡Æü‡Øç‡Æü‡ØÅ", title2: "‡Æâ‡Æ©‡Æï‡Øç‡Æï‡ØÅ‡Æ™‡Øç ‡Æ™‡Æ§‡Æø‡Æ≤‡Ææ‡Æï", description: "‡Æâ‡Æ£‡Æ∞‡Øç‡Æö‡Øç‡Æö‡Æø‡Æµ‡Æö‡ÆÆ‡Ææ‡Æ© ‡Æ™‡Æ§‡Æ±‡Øç‡Æ±‡Æ§‡Øç‡Æ§‡Øà‡Æï‡Øç ‡Æï‡Ææ‡Æü‡Øç‡Æö‡Æø‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç ‡Æ®‡Æø‡Æ∞‡Øç‡Æµ‡Æï‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç ‡Æí‡Æ∞‡ØÅ ‡Æ§‡Øä‡Æü‡ØÅ ‡Æï‡Æ∞‡ØÅ‡Æµ‡Æø.",
                        guideTitle: "‡Æµ‡Æ¥‡Æø‡Æï‡Ææ‡Æü‡Øç‡Æü‡Æø: Cut & Heal ‡ÆÆ‡ØÅ‡Æ±‡Øà‡Æï‡Æ≥‡Øç",
                        close: "‡ÆÆ‡ØÇ‡Æü‡ØÅ",
                        guideDiffTitle: "‡Æµ‡Øá‡Æ±‡ØÅ‡Æ™‡Ææ‡Æü‡ØÅ ‡Æé‡Æ©‡Øç‡Æ©?",
                        cutModeLabel: "Cut ‡ÆÆ‡ØÅ‡Æ±‡Øà",
                        cutModeDesc: "‡Æµ‡Øá‡Æï‡ÆÆ‡Ææ‡Æ© ‡Æö‡Æø‡Æµ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡Øã‡Æü‡Øç‡Æü‡ØÅ‡Æï‡Æ≥‡Ææ‡Æ≤‡Øç ‡Æâ‡Æ®‡Øç‡Æ§‡ØÅ‡Æ§‡Æ≤‡Øà ‚Äò‡Æµ‡ØÜ‡Æ≥‡Æø‡ÆØ‡Øá‡Æ±‡Øç‡Æ±‚Äô ‡Æâ‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç.",
                        healModeLabel: "Heal ‡ÆÆ‡ØÅ‡Æ±‡Øà",
                        healModeDesc: "‡ÆÆ‡ØÜ‡Æ§‡ØÅ‡Æµ‡Ææ‡Æ©, ‡ÆÆ‡ØÜ‡Æ©‡Øç‡ÆÆ‡Øà‡ÆØ‡Ææ‡Æ© ‡Æâ‡Æ≥‡Øç‡Æ≥‡ØÄ‡Æü‡ØÅ; ‚Äòcut‚Äô ‡Æµ‡Æü‡Æø‡Æµ‡ÆÆ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà‚Äî‡ÆÖ‡ÆÆ‡Øà‡Æ§‡Æø‡ÆØ‡Ææ‡Æ© ‡ÆÆ‡ØÄ‡Æü‡Øç‡Æ™‡ØÅ ‡Æµ‡Æ∞‡Øà‡Æ§‡Æ≤‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æè‡Æ±‡Øç‡Æ±‡Æ§‡ØÅ.",
                        quickStartTitle: "‡Æµ‡Æø‡Æ∞‡Øà‡Æµ‡ØÅ ‡Æ§‡Øä‡Æü‡Æï‡Øç‡Æï‡ÆÆ‡Øç",
                        quick1: "<strong>Cut / Heal</strong> ‡Æê ‡ÆÆ‡ØÅ‡Æ±‡Øà ‡Æ™‡Øä‡Æ§‡Øç‡Æ§‡Ææ‡Æ©‡Ææ‡Æ≤‡Øç ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡Æµ‡ØÅ‡ÆÆ‡Øç.",
                        quick2: "‚éå <strong>Undo</strong> ‡ÆÆ‡ØÇ‡Æ≤‡ÆÆ‡Øç ‡Æï‡Æü‡Øà‡Æö‡Æø ‡Æï‡Øã‡Æü‡Øç‡Æü‡Øà ‡Æ®‡ØÄ‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç, ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ <strong>Clear All</strong> ‡ÆÆ‡ØÇ‡Æ≤‡ÆÆ‡Øç ‡Æï‡Æ©‡Øç‡Æµ‡Ææ‡Æ∏‡Øà ‡Æï‡Ææ‡Æ≤‡Æø ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æµ‡ØÅ‡ÆÆ‡Øç.",
                        quick3: "‡Æé‡Æ™‡Øç‡Æ™‡Øã‡Æ§‡ØÅ‡ÆÆ‡Øç <strong>Breath</strong> ‡Æ™‡Øä‡Æ§‡Øç‡Æ§‡Ææ‡Æ©‡Øà ‡Æ™‡ÆØ‡Æ©‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æø ‡ÆÆ‡Æ©‡Æ§‡Øà ‡Æö‡ØÄ‡Æ∞‡Ææ‡Æï‡Øç‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç.",
                        quick4: "<strong>Affirmation</strong> ‡ÆÆ‡ØÇ‡Æ≤‡ÆÆ‡Øç ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øà ‡Æä‡Æï‡Øç‡Æï‡ØÅ‡Æµ‡Æø‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç ‡Æµ‡Ææ‡Æ∞‡Øç‡Æ§‡Øç‡Æ§‡Øà‡Æï‡Æ≥‡Øà ‡Æé‡Æ¥‡ØÅ‡Æ§‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        quick5: "<strong>Challenge</strong> ‡ÆÆ‡ØÇ‡Æ≤‡ÆÆ‡Øç ‡Æï‡Æµ‡Æ≤‡Øà ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æö‡ØÅ‡ÆØ ‡Æö‡Øá‡Æ§ ‡Æâ‡Æ®‡Øç‡Æ§‡ØÅ‡Æ§‡Æ≤‡Øà ‡Æµ‡Æø‡Æ≤‡Æï‡Øç‡Æï‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        cutTipsTitle: "Cut ‡ÆÆ‡ØÅ‡Æ±‡Øà‡Æï‡Øç‡Æï‡Ææ‡Æ© ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç",
                        cutTip1: "‡Æï‡ØÅ‡Æ±‡ØÅ‡Æï‡Æø‡ÆØ, ‡Æï‡ØÇ‡Æ∞‡Øç‡ÆÆ‡Øà‡ÆØ‡Ææ‡Æ© ‡Æï‡Øã‡Æü‡Øç‡Æü‡ØÅ‡Æï‡Æ≥‡Øç ‡Æö‡Æø‡Æ±‡Æ®‡Øç‡Æ§ ‚Äò‡Æµ‡Æø‡Æü‡ØÅ‡Æ§‡Æ≤‡Øà‚Äô ‡Æâ‡Æ£‡Æ∞‡Øç‡Æµ‡Øà ‡Æ§‡Æ∞‡ØÅ‡ÆÆ‡Øç.",
                        cutTip2: "‡Æï‡Øã‡Æü‡ØÅ + ‡ÆÆ‡ØÇ‡Æö‡Øç‡Æö‡ØÅ ‡Æö‡ØÅ‡Æ¥‡Æ±‡Øç‡Æö‡Æø‡ÆØ‡Æø‡Æ≤‡Øç ‡Æï‡Æµ‡Æ©‡ÆÆ‡Øç (‡Æµ‡Æ∞‡Øà‡ÆØ‡ØÅ‡ÆÆ‡Øç‡Æ™‡Øã‡Æ§‡ØÅ ‡ÆÆ‡ØÇ‡Æö‡Øç‡Æö‡Øà ‡Æµ‡ØÜ‡Æ≥‡Æø‡ÆØ‡Øá ‡Æµ‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç).",
                        healTipsTitle: "Heal ‡ÆÆ‡ØÅ‡Æ±‡Øà‡Æï‡Øç‡Æï‡Ææ‡Æ© ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç",
                        healTip1: "‡ÆÆ‡ØÜ‡Æ§‡ØÅ‡Æµ‡Ææ‡Æ© ‡Æµ‡Æü‡Øç‡Æü ‡Æµ‡Æ≥‡Øà‡Æµ‡ØÅ‡Æï‡Æ≥‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡ÆÆ‡ØÜ‡Æ©‡Øç‡ÆÆ‡Øà‡ÆØ‡Ææ‡Æ© ‡Æ∑‡Øá‡Æü‡Æø‡Æô‡Øç.",
                        healTip2: "‡ÆÖ‡Æ§‡Æø‡Æï ‡Æö‡ØÅ‡ÆÆ‡Øà ‡Æé‡Æ©‡Øç‡Æ±‡Ææ‡Æ≤‡Øç, affirmation ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ sensory challenge ‡Æâ‡Æü‡Æ©‡Øç ‡Æá‡Æ£‡Øà‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.",
                        reminderLabel: "‡Æ®‡Æø‡Æ©‡Øà‡Æµ‡ØÇ‡Æü‡Øç‡Æü‡Æ≤‡Øç:",
                        reminderText: "‡Æá‡Æ®‡Øç‡Æ§ ‡Æï‡Æ∞‡ØÅ‡Æµ‡Æø ‡Æí‡Æ∞‡ØÅ ‡Æö‡ÆÆ‡Ææ‡Æ≥‡Æø‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç ‡Æâ‡Æ§‡Æµ‡Æø; ‡ÆÆ‡Æ∞‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ‡Æµ ‡ÆÜ‡Æ≤‡Øã‡Æö‡Æ©‡Øà ‡ÆÖ‡Æ≤‡Øç‡Æ≤. ‡ÆÜ‡Æ™‡Æ§‡Øç‡Æ§‡ØÅ ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æö‡ØÅ‡ÆØ ‡Æö‡Øá‡Æ§ ‡Æé‡Æ£‡Øç‡Æ£‡ÆÆ‡Øç ‡Æá‡Æ∞‡ØÅ‡Æ®‡Øç‡Æ§‡Ææ‡Æ≤‡Øç ‡Æâ‡Æü‡Æ©‡Øá ‡Æâ‡Æ§‡Æµ‡Æø ‡Æ™‡ØÜ‡Æ±‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        appInfoBtn: "‡ÆÖ‡Æ™‡Øç‡Æ™‡Æø‡Æ≥‡Øà‡Æï‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ§‡Øç‡Æ§ ‡Æ§‡Æï‡Æµ‡Æ≤‡Øç / ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æü‡Æï‡Øç‡Æï ‡ÆÖ‡Æ±‡Æø‡Æµ‡Æø‡Æ™‡Øç‡Æ™‡ØÅ",
                        cutMode: "‡Æµ‡ØÜ‡Æü‡Øç‡Æü‡ØÅ ‡ÆÆ‡ØÅ‡Æ±‡Øà", healMode: "‡Æï‡ØÅ‡Æ£‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡Æ±‡Øà (‡Æí‡Æ≥‡Æø)", takeBreath: "‡ÆÆ‡ØÇ‡Æö‡Øç‡Æö‡ØÅ ‡Æµ‡Æø‡Æü‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç", challenge: "‡Æö‡Æµ‡Ææ‡Æ≤‡Øç",
                        affirmations: "‡Æâ‡Æ±‡ØÅ‡Æ§‡Æø‡ÆÆ‡Øä‡Æ¥‡Æø‡Æï‡Æ≥‡Øç", theme: "‡Æí‡Æ≥‡Æø ‡ÆÆ‡ØÅ‡Æ±‡Øà", themeDark: "‡Æá‡Æ∞‡ØÅ‡Æ£‡Øç‡Æü ‡ÆÆ‡ØÅ‡Æ±‡Øà", log: "‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ", info: "‡Æ§‡Æï‡Æµ‡Æ≤‡Øç",
                        emailTitle: "‡ÆÆ‡Æø‡Æ©‡Øç‡Æ©‡Æû‡Øç‡Æö‡Æ≤‡Øç ‡Æï‡Æø‡Æ≥‡Øà‡ÆØ‡Æ£‡Øç‡Æü‡Øà‡Æ§‡Øç ‡Æ§‡Øá‡Æ∞‡Øç‡Æ®‡Øç‡Æ§‡ØÜ‡Æü‡ØÅ‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç", emailDesc: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ™‡Øç ‡Æ™‡Æø‡Æü‡Æø‡Æ§‡Øç‡Æ§ ‡ÆÆ‡Æø‡Æ©‡Øç‡Æ©‡Æû‡Øç‡Æö‡Æ≤‡Øç ‡Æï‡Æø‡Æ≥‡Øà‡ÆØ‡Æ£‡Øç‡Æü‡Øà‡Æ§‡Øç ‡Æ§‡Øá‡Æ∞‡Øç‡Æ®‡Øç‡Æ§‡ØÜ‡Æü‡ØÅ‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç. ‡ÆÖ‡ÆÆ‡Æ∞‡Øç‡Æµ‡ØÅ‡Æö‡Øç ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Æø‡Æ≤‡Øç ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æï‡Æø‡Æ≥‡Æø‡Æ™‡Øç‡Æ™‡Øã‡Æ∞‡Øç‡Æü‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æ®‡Æï‡Æ≤‡ØÜ‡Æü‡ØÅ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡ÆÆ‡Øç.",
                        settings: "‡ÆÖ‡ÆÆ‡Øà‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç", undo: "‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æ§‡Æµ‡Æø‡Æ∞‡Øç", clearAll: "‡ÆÖ‡Æ©‡Øà‡Æ§‡Øç‡Æ§‡Øà‡ÆØ‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ¥‡Æø", breatheIn: "‡ÆÆ‡ØÇ‡Æö‡Øç‡Æö‡Øà ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æø‡Æ¥‡ØÅ...",
                        breatheHold: "‡Æ®‡Æø‡Æ±‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ...", breatheOut: "‡ÆÆ‡ØÇ‡Æö‡Øç‡Æö‡Øà ‡Æµ‡ØÜ‡Æ≥‡Æø‡Æµ‡Æø‡Æü‡ØÅ...", overloadTitle: "‡ÆÆ‡Æ© ‡Æö‡ØÅ‡ÆÆ‡Øà ‡ÆÖ‡Æ§‡Æø‡Æï‡ÆÆ‡Øç!",
                        overloadDesc: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡ÆÆ‡Æ© ‡Æö‡ØÅ‡ÆÆ‡Øà 100% ‡ÆÜ‡Æï ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æ§‡ØÅ. ‡Æµ‡Æ∞‡Øà‡Æ§‡Æ≤‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ.", overloadInstruct: "‡Æ™‡Æ§‡Æ±‡Øç‡Æ±‡Æ§‡Øç‡Æ§‡Øà‡Æï‡Øç ‡Æï‡ØÅ‡Æ±‡Øà‡Æï‡Øç‡Æï, ‡Æö‡ÆÆ‡Ææ‡Æ≥‡Æø‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç ‡Æï‡Æ∞‡ØÅ‡Æµ‡Æø‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æí‡Æ©‡Øç‡Æ±‡Øà‡Æ™‡Øç ‡Æ™‡ÆØ‡Æ©‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç.",
                        welcomeTitle: "‡Æö‡ØÅ‡Æµ‡Ææ‡Æï‡Æ§‡ÆÆ‡Øç - ‡Æ§‡ÆØ‡Æµ‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ ‡Æ™‡Æü‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç",
                        welcomeIntent: "‡Æá‡Æ§‡ØÅ ‡Æí‡Æ∞‡ØÅ ‡Æï‡Æ∞‡ØÅ‡Æµ‡Æø, ‡Æµ‡Æø‡Æ≥‡Øà‡ÆØ‡Ææ‡Æü‡Øç‡Æü‡Æ≤‡Øç‡Æ≤. ‡Æ§‡Ææ‡Æô‡Øç‡Æï ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡Ææ‡Æ§ ‡Æâ‡Æ£‡Æ∞‡Øç‡Æµ‡ØÅ‡Æï‡Æ≥‡Øà‡Æï‡Øç ‡Æï‡Ææ‡Æü‡Øç‡Æö‡Æø‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç ‡Æ®‡Æø‡Æ∞‡Øç‡Æµ‡Æï‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç ‡Æâ‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç ‡Æ™‡Ææ‡Æ§‡ØÅ‡Æï‡Ææ‡Æ™‡Øç‡Æ™‡Ææ‡Æ© ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡Ææ‡Æï ‡Æá‡Æ§‡ØÅ ‡Æµ‡Æü‡Æø‡Æµ‡ÆÆ‡Øà‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡ØÅ‡Æ≥‡Øç‡Æ≥‡Æ§‡ØÅ.",
                        welcomeWarning: "‡Æâ‡Æ≥‡Øç‡Æ≥‡Æü‡Æï‡Øç‡Æï ‡Æé‡Æö‡Øç‡Æö‡Æ∞‡Æø‡Æï‡Øç‡Æï‡Øà:", welcomeWarningText: "‡Æá‡Æ®‡Øç‡Æ§‡Æ™‡Øç ‡Æ™‡ÆØ‡Æ©‡Øç‡Æ™‡Ææ‡Æü‡Øç‡Æü‡Æø‡Æ≤‡Øç ‡Æö‡ØÅ‡ÆØ-‡Æ§‡ØÄ‡Æô‡Øç‡Æï‡ØÅ‡Æï‡Øç‡Æï‡Ææ‡Æ© ‡Æâ‡Æ∞‡ØÅ‡Æµ‡Æï‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æ©. ‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ®‡ØÜ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Æü‡Æø‡ÆØ‡Æø‡Æ≤‡Øç ‡Æá‡Æ∞‡ØÅ‡Æ®‡Øç‡Æ§‡Ææ‡Æ≤‡Øç, ‡Æ§‡ÆØ‡Æµ‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ ‡Æá‡Æ§‡Øà ‡ÆÆ‡ØÇ‡Æü‡Æø‡Æµ‡Æø‡Æü‡Øç‡Æü‡ØÅ ‡Æï‡ØÄ‡Æ¥‡Øá ‡Æâ‡Æ≥‡Øç‡Æ≥ ‡Æµ‡Æ≥‡Æô‡Øç‡Æï‡Æ≥‡Øà‡Æ™‡Øç ‡Æ™‡ÆØ‡Æ©‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç.",
                        welcomeGoal: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æá‡Æ≤‡Æï‡Øç‡Æï‡ØÅ:", welcomeGoalText: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æá‡Æ≤‡Æï‡Øç‡Æï‡ØÅ ‡Æ§‡Æø‡Æ∞‡Øà‡ÆØ‡Øà ‡Æ®‡Æø‡Æ∞‡Æ™‡Øç‡Æ™‡ØÅ‡Æµ‡Æ§‡Æ≤‡Øç‡Æ≤, ‡ÆÆ‡Ææ‡Æ±‡Ææ‡Æï '‡ÆÆ‡ØÇ‡Æö‡Øç‡Æö‡ØÅ' ‡ÆÆ‡Æ±‡Øç‡Æ±‡ØÅ‡ÆÆ‡Øç '‡Æö‡Æµ‡Ææ‡Æ≤‡Øç' ‡Æï‡Æ∞‡ØÅ‡Æµ‡Æø‡Æï‡Æ≥‡Øà‡Æ™‡Øç ‡Æ™‡ÆØ‡Æ©‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æø ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç '‡ÆÆ‡Æ©‡Æö‡Øç ‡Æö‡ØÅ‡ÆÆ‡Øà‡ÆØ‡Øà' (‡Æï‡ØÄ‡Æ¥‡Øá ‡Æá‡Æü‡Æ§‡ØÅ‡Æ™‡ØÅ‡Æ±‡Æ§‡Øç‡Æ§‡Æø‡Æ≤‡Øç ‡Æâ‡Æ≥‡Øç‡Æ≥ ‡ÆÖ‡Æ≥‡Æµ‡Æø) ‡Æ®‡Æø‡Æ∞‡Øç‡Æµ‡Æï‡Æø‡Æ™‡Øç‡Æ™‡Æ§‡Ææ‡Æï‡ØÅ‡ÆÆ‡Øç. ‡Æá‡Æ§‡ØÅ ‡Æ®‡Æø‡Æµ‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç ‡Æ™‡ÆØ‡Æø‡Æ±‡Øç‡Æö‡Æø ‡Æö‡ØÜ‡ÆØ‡Øç‡Æµ‡Æ§‡Æ±‡Øç‡Æï‡Ææ‡Æ© ‡Æí‡Æ∞‡ØÅ ‡Æï‡Æ∞‡ØÅ‡Æµ‡Æø.",
                        welcomeCrisisTitle: "‡Æâ‡Æü‡Æ©‡Æü‡Æø ‡Æ®‡ØÜ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Æü‡Æø ‡ÆÜ‡Æ§‡Æ∞‡Æµ‡ØÅ:", welcomeCrisisLink: "IASP ‡Æö‡Æ∞‡Øç‡Æµ‡Æ§‡Øá‡Æö ‡Æâ‡Æ§‡Æµ‡Æø ‡Æ§‡Øá‡Æü‡Æ≤‡Øç", welcomeCrisisUS: "(‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡ÆÖ‡ÆÆ‡ØÜ‡Æ∞‡Æø‡Æï‡Øç‡Æï‡Ææ‡Æµ‡Æø‡Æ≤‡Øç ‡Æá‡Æ∞‡ØÅ‡Æ®‡Øç‡Æ§‡Ææ‡Æ≤‡Øç, 988 ‡Æê ‡ÆÖ‡Æ¥‡Øà‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç)",
                        welcomeUnderstand: "‡Æ®‡Ææ‡Æ©‡Øç ‡Æ™‡ØÅ‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æï‡Øä‡Æ≥‡Øç‡Æï‡Æø‡Æ±‡Øá‡Æ©‡Øç", checkinTitle: "‡Æö‡Æ∞‡Æø‡Æ™‡Ææ‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æï‡Æø‡Æ±‡Æ§‡ØÅ...", checkinRemember: "‡Æ®‡Æø‡Æ©‡Øà‡Æµ‡Æø‡Æ≤‡Øç ‡Æï‡Øä‡Æ≥‡Øç‡Æ≥‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç, ‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æé‡Æ§‡Øà‡Æö‡Øç ‡Æö‡Æ®‡Øç‡Æ§‡Æø‡Æ§‡Øç‡Æ§‡Ææ‡Æ≤‡ØÅ‡ÆÆ‡Øç, ‡ÆÖ‡Æ§‡Øà‡Æ§‡Øç ‡Æ§‡Æ©‡Æø‡ÆØ‡Ææ‡Æï ‡Æé‡Æ§‡Æø‡Æ∞‡Øç‡Æï‡Øä‡Æ≥‡Øç‡Æ≥ ‡Æµ‡Øá‡Æ£‡Øç‡Æü‡Æø‡ÆØ‡Æ§‡Æø‡Æ≤‡Øç‡Æ≤‡Øà. ‡Æ§‡ÆØ‡Æµ‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ ‡Æâ‡Æ≥‡Øç‡Æ≥‡ØÇ‡Æ∞‡Øç ‡Æ®‡ØÜ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Æü‡Æø ‡ÆÆ‡Øà‡ÆØ‡Æ§‡Øç‡Æ§‡Øà‡ÆØ‡Øã ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æπ‡Ææ‡Æü‡Øç‡Æ≤‡Øà‡Æ©‡Øà‡ÆØ‡Øã ‡Æâ‡Æü‡Æ©‡Æü‡Æø‡ÆØ‡Ææ‡Æï‡Æ§‡Øç ‡Æ§‡Øá‡Æü‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        checkinClose: "‡Æ®‡Ææ‡Æ©‡Øç ‡Æ®‡Æ≤‡ÆÆ‡Ææ‡Æï ‡Æâ‡Æ≥‡Øç‡Æ≥‡Øá‡Æ©‡Øç / ‡ÆÆ‡ØÇ‡Æü‡ØÅ", challengeTitle: "‡Æ®‡ØÜ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Æü‡Æø: ‡Æâ‡Æ£‡Æ∞‡Øç‡Æö‡Øç‡Æö‡Æø ‡Æö‡Æµ‡Ææ‡Æ≤‡Øç!", challengeDesc: "‡Æ§‡ØÄ‡Æµ‡Æø‡Æ∞‡ÆÆ‡Ææ‡Æ© ‡Æö‡ÆÆ‡Ææ‡Æ≥‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æ§‡Øç ‡Æ§‡Æø‡Æ±‡Æ©‡Øà‡Æ™‡Øç ‡Æ™‡ÆØ‡Æ©‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æø ‡Æâ‡Æ®‡Øç‡Æ§‡ØÅ‡Æ§‡Æ≤‡Øà ‡ÆÆ‡ØÄ‡Æ±‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        challengeTaskTitle: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡Æ£‡Æø:", challengeTime: "‡ÆÆ‡ØÄ‡Æ§‡ÆÆ‡ØÅ‡Æ≥‡Øç‡Æ≥ ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç:", challengeInstruct: "‡Æá‡Æ™‡Øç‡Æ™‡Øã‡Æ§‡Øá ‡Æ™‡Æ£‡Æø‡ÆØ‡Øà‡Æ§‡Øç ‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç. ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡Æü‡Øç‡Æü‡ØÅ‡ÆÆ‡Øá ‡Æï‡ØÄ‡Æ¥‡Øá ‡Æâ‡Æ≥‡Øç‡Æ≥ ‡Æ™‡Øä‡Æ§‡Øç‡Æ§‡Ææ‡Æ©‡Øà ‡ÆÖ‡Æ¥‡ØÅ‡Æ§‡Øç‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç.",
                        challengeIceCubes: "5 ‡Æê‡Æ∏‡Øç ‡Æï‡Æü‡Øç‡Æü‡Æø‡Æï‡Æ≥‡Øà‡Æ§‡Øç ‡Æ§‡Øá‡Æü‡Æø ‡Æï‡Øà‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æá‡Æ±‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Ææ‡Æï ‡Æ™‡Æø‡Æü‡Æø‡ÆØ‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç. ‡ÆÖ‡Æµ‡Øà ‡ÆÆ‡ØÅ‡Æ¥‡ØÅ‡Æµ‡Æ§‡ØÅ‡ÆÆ‡Øç ‡Æâ‡Æ∞‡ØÅ‡Æï‡ØÅ‡ÆÆ‡Øç ‡Æµ‡Æ∞‡Øà ‡Æµ‡Øà‡Æ§‡Øç‡Æ§‡Æø‡Æ∞‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        challengeColdSplash: "‡ÆÆ‡Æø‡Æï‡Æï‡Øç ‡Æï‡ØÅ‡Æ≥‡Æø‡Æ∞‡Øç‡Æ®‡Øç‡Æ§ ‡Æ®‡ØÄ‡Æ∞‡Øà ‡ÆÆ‡ØÅ‡Æï‡Æ§‡Øç‡Æ§‡Æø‡Æ≤‡Øç 5 ‡ÆÆ‡ØÅ‡Æ±‡Øà ‡Æ§‡ØÜ‡Æ≥‡Æø‡ÆØ‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç. (‡Æí‡Æµ‡Øç‡Æµ‡Øä‡Æ∞‡ØÅ ‡Æ§‡ØÜ‡Æ≥‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡Æ©‡Øç ‡Æö‡ØÅ‡Æµ‡Ææ‡Æö‡Æ§‡Øç‡Æ§‡Øà ‡ÆÆ‡ØÜ‡Æ§‡ØÅ‡Æµ‡Ææ‡Æï‡Æ§‡Øç ‡Æ§‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ ‡Æï‡Øä‡Æ≥‡Øç‡Æ≥‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.)",
                        challengeSourCandy: "‡Æí‡Æ∞‡ØÅ ‡Æé‡Æ≤‡ØÅ‡ÆÆ‡Æø‡Æö‡Øç‡Æö‡Øà ‡Æ§‡ØÅ‡Æ£‡Øç‡Æü‡Øà ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡ÆÆ‡Æø‡Æï ‡Æ™‡ØÅ‡Æ≥‡Æø‡Æ™‡Øç‡Æ™‡Ææ‡Æ© ‡ÆÆ‡Æø‡Æü‡Øç‡Æü‡Ææ‡ÆØ‡Øç ‡Æí‡Æ©‡Øç‡Æ±‡Øà 30 ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç ‡Æµ‡Ææ‡ÆØ‡Æø‡Æ≤‡Øç ‡Æµ‡Øà‡Æ§‡Øç‡Æ§‡ØÅ‡Æï‡Øç ‡Æï‡Øä‡Æ≥‡Øç‡Æ≥‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç. ‡ÆÖ‡Æ§‡Æ©‡Øç ‡Æö‡ØÅ‡Æµ‡Øà‡ÆØ‡Æø‡Æ≤ ‡ÆÆ‡Æü‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡Æï‡Æµ‡Æ©‡ÆÆ‡Øç ‡Æö‡ØÜ‡Æ≤‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        challengeStrongScent: "‡Æí‡Æ∞‡ØÅ ‡Æµ‡Æ≤‡ØÅ‡Æµ‡Ææ‡Æ© ‡Æµ‡Ææ‡Æö‡Æ©‡Øà‡ÆØ‡Øà (‡Æ™‡ØÜ‡Æ™‡Øç‡Æ™‡Æ∞‡Øç‡ÆÆ‡Æø‡Æ£‡Øç‡Æü‡Øç ‡Æé‡Æ£‡Øç‡Æ£‡ØÜ‡ÆØ‡Øç, ‡Æµ‡ØÜ‡Æø‡Æ©‡Øç‡Æï‡Æ∞‡Øç, ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æ™‡Æ∞‡Øç‡ÆÉ‡Æ™‡Øç‡ÆØ‡ØÇ‡ÆÆ‡Øç ‡Æ™‡Øã‡Æ©‡Øç‡Æ±‡Æµ‡Øà) ‡Æ§‡Øá‡Æü‡Æø, ‡ÆÜ‡Æ¥‡ÆÆ‡Ææ‡Æï 5 ‡ÆÆ‡ØÅ‡Æ±‡Øà ‡ÆÆ‡ØÇ‡Æö‡Øç‡Æö‡Øà ‡Æá‡Æ¥‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ ‡Æµ‡Ææ‡Æö‡Æø‡ÆØ‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        challengeIntenseExercise: "1 ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡ÆÆ‡Øç ‡Æ§‡Æø‡Æü‡ØÄ‡Æ∞‡ØÜ‡Æ©/‡Æ§‡ØÄ‡Æµ‡Æø‡Æ∞‡ÆÆ‡Ææ‡Æï ‡Æâ‡Æü‡Æ±‡Øç‡Æ™‡ÆØ‡Æø‡Æ±‡Øç‡Æö‡Æø ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç (‡Æú‡ÆÆ‡Øç‡Æ™‡Æø‡Æô‡Øç ‡Æú‡Ææ‡Æï‡Øç‡Æ∏‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æá‡Æü‡Æ§‡Øç‡Æ§‡Æø‡Æ≤‡Øç ‡Æì‡Æü‡ØÅ‡Æ§‡Æ≤‡Øç ‡Æ™‡Øã‡Æ©‡Øç‡Æ±‡Æµ‡Øà) ‡Æâ‡Æü‡Æ≤‡Øç ‡Æö‡Øã‡Æ∞‡Øç‡Æµ‡ØÅ ‡Æâ‡Æ£‡Æ∞‡ØÅ‡ÆÆ‡Øç ‡Æµ‡Æ∞‡Øà.",
                        challengeRubberBand: "‡Æí‡Æ∞‡ØÅ ‡Æ∞‡Æ™‡Øç‡Æ™‡Æ∞‡Øç ‡Æ™‡Øá‡Æ£‡Øç‡Æü‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æπ‡Øá‡Æ∞‡Øç ‡Æü‡Øà ‡Æé‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ, ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡ÆÆ‡Æ£‡Æø‡Æï‡Øç‡Æï‡Æü‡Øç‡Æü‡Æø‡Æ≤‡Øç ‡ÆÆ‡ØÜ‡Æ§‡ØÅ‡Æµ‡Ææ‡Æï 10 ‡ÆÆ‡ØÅ‡Æ±‡Øà ‡Æ§‡Æü‡Øç‡Æü‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç. (‡Æ™‡Ææ‡Æ§‡ØÅ‡Æï‡Ææ‡Æ™‡Øç‡Æ™‡Ææ‡Æ©, ‡ÆÆ‡Æø‡Æï‡Ææ‡Æ§ ‡Æµ‡Æ≤‡Æø‡ÆØ‡ØÅ‡Æü‡Æ©‡Øç ‡ÆÆ‡Æü‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç.)",
                        challengeMarching: "1 ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡ÆÆ‡Øç ‡Æá‡Æü‡Æ§‡Øç‡Æ§‡Æø‡Æ≤‡Øç ‡Æâ‡ÆØ‡Æ∞‡ÆÆ‡Ææ‡Æï ‡ÆÆ‡ØÅ‡Æ¥‡Æô‡Øç‡Æï‡Ææ‡Æ≤‡Øà ‡Æ§‡ØÇ‡Æï‡Øç‡Æï‡Æø ‡Æ®‡Æü‡Øà‡Æ™‡Øã‡Æü‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç. ‡Æí‡Æµ‡Øç‡Æµ‡Øä‡Æ∞‡ØÅ ‡ÆÖ‡Æü‡Æø‡ÆØ‡Æø‡Æ≤‡ØÅ‡ÆÆ‡Øç ‡Æé‡Æ§‡Æø‡Æ∞‡Øç ‡Æï‡Øà‡ÆØ‡Øà ‡Æé‡Æ§‡Æø‡Æ∞‡Øç ‡ÆÆ‡ØÅ‡Æ¥‡Æô‡Øç‡Æï‡Ææ‡Æ≤‡ØÅ‡Æü‡Æ©‡Øç ‡ÆÆ‡ØÜ‡Æ§‡ØÅ‡Æµ‡Ææ‡Æï‡Æ§‡Øç ‡Æ§‡Øä‡Æü‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        challengeComplete: "‡Æö‡Æµ‡Ææ‡Æ≤‡Øà ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç (‡Æü‡Øà‡ÆÆ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Ææ‡Æï‡Æï‡Øç ‡Æï‡Ææ‡Æ§‡Øç‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç)", challengeCancel: "‡Æ∞‡Æ§‡Øç‡Æ§‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç (‡Æé‡Æ©‡Æï‡Øç‡Æï‡ØÅ ‡Æâ‡Æü‡Æ©‡Æü‡Æø ‡Æâ‡Æ§‡Æµ‡Æø ‡Æ§‡Øá‡Æµ‡Øà)", challengeFocus: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æµ‡Æø‡Æ∞‡Æ≤‡Øà ‡Æ®‡Æï‡Æ∞‡ØÅ‡ÆÆ‡Øç ‡Æá‡Æ≤‡Æï‡Øç‡Æï‡Æø‡Æ©‡Øç ‡Æâ‡Æ≥‡Øç‡Æ≥‡Øá 15 ‡Æµ‡Æø‡Æ©‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç ‡Æµ‡Øà‡Æ§‡Øç‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.",
                        anotherChallenge: "‡Æá‡Æ§‡ØÅ ‡Æá‡Æ™‡Øç‡Æ™‡Øã‡Æ§‡ØÅ ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æ®‡Øç‡Æ§‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà‚Ä¶",
                        logTitle: "‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æ™‡Ææ‡Æü‡Øç‡Æü‡ØÅ ‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ", logAddNote: "‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ ‡Æö‡Øá‡Æ∞‡Øç", logTime: "‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç", logAction: "‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç", logChange: "‡ÆÆ‡Æ© ‡Æö‡ØÅ‡ÆÆ‡Øà ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡ÆÆ‡Øç",
                        logExportTitle: "‡ÆÖ‡ÆÆ‡Æ∞‡Øç‡Æµ‡Øà ‡Æè‡Æ±‡Øç‡Æ±‡ØÅ‡ÆÆ‡Æ§‡Æø ‡Æö‡ØÜ‡ÆØ‡Øç",
                        logExportPDF: "PDF ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà‡ÆØ‡Ææ‡Æï‡Æö‡Øç ‡Æö‡Øá‡ÆÆ‡Æø",
                        logExportCSV: "CSV ‡Æ§‡Æ∞‡Æµ‡Ææ‡Æï‡Æö‡Øç ‡Æö‡Øá‡ÆÆ‡Æø",
                        logExportEmail: "‡Æ®‡Æø‡Æ™‡ØÅ‡Æ£‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡ÆÆ‡Æø‡Æ©‡Øç‡Æ©‡Æû‡Øç‡Æö‡Æ≤‡Øç ‡ÆÖ‡Æ©‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ",
                        logExportCopy: "‡ÆÖ‡ÆÆ‡Æ∞‡Øç‡Æµ‡ØÅ‡Æö‡Øç ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Æ§‡Øç‡Æ§‡Øà ‡Æ®‡Æï‡Æ≤‡ØÜ‡Æü‡ØÅ",
                        logSummaryAccumulation: "‡Æ§‡Æø‡Æ∞‡Æ≥‡Øç (‡Æö‡Øä‡Æü‡Øç‡Æü‡ØÅ‡Æï‡Æ≥‡Øç):",
                        logSummaryRelief: "‡Æ®‡Æø‡Æµ‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç (‡ÆÆ‡ØÇ‡Æö‡Øç‡Æö‡ØÅ‡Æï‡Æ≥‡Øç/‡Æö‡Æµ‡Ææ‡Æ≤‡Øç‡Æï‡Æ≥‡Øç/‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æ§‡Æµ‡Æø‡Æ∞‡Øç):",
                        logSummaryNet: "‡Æ®‡Æø‡Æï‡Æ∞ ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡ÆÆ‡Øç:",
                        logDrips: "‡Æö‡Øä‡Æü‡Øç‡Æü‡ØÅ‡Æï‡Æ≥‡Øç", logRelief: "‡Æ®‡Æø‡Æµ‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç", logChallenges: "‡Æö‡Æµ‡Ææ‡Æ≤‡Øç‡Æï‡Æ≥‡Øç", logUndos: "‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æ§‡Æµ‡Æø‡Æ∞‡Øç",
                        logActionCut: "‡Æµ‡ØÜ‡Æü‡Øç‡Æü‡ØÅ‡Æö‡Øç ‡Æö‡Øä‡Æü‡Øç‡Æü‡ØÅ (‡Æ§‡Æø‡Æ∞‡Æ≥‡Øç)", logActionBreath: "‡ÆÆ‡ØÇ‡Æö‡Øç‡Æö‡ØÅ (‡Æ®‡Æø‡Æµ‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç)", logActionChallenge: "‡Æö‡Æµ‡Ææ‡Æ≤‡Øç (‡Æ®‡Æø‡Æµ‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç)",
                        logActionUndo: "‡Æµ‡ØÜ‡Æü‡Øç‡Æü‡Øà ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æ§‡Æµ‡Æø‡Æ∞‡Øç (‡Æ®‡Æø‡Æµ‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç)", logActionReset: "‡ÆÆ‡ØÅ‡Æ¥‡ØÅ ‡ÆÆ‡ØÄ‡Æü‡Øç‡Æü‡ÆÆ‡Øà‡Æ™‡Øç‡Æ™‡ØÅ (‡Æ®‡Æø‡Æµ‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç)", logActionNote: "‡Æ™‡Æ§‡Øç‡Æ§‡Æø‡Æ∞‡Æø‡Æï‡Øà ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ", logActionQuick: "‡Æµ‡Æø‡Æ∞‡Øà‡Æµ‡ØÅ‡Æ™‡Øç ‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ (‡Æ®‡Æø‡Æµ‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç)",
                        logStreak: "‡Æ§‡Æ±‡Øç‡Æ™‡Øã‡Æ§‡Øà‡ÆØ ‡Æ§‡Øä‡Æü‡Æ∞‡Øç‡Æö‡Øç‡Æö‡Æø‡ÆØ‡Ææ‡Æ© ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç: {count} ‡Æ®‡Ææ‡Æ≥‡Øç(‡Æï‡Æ≥‡Øç)", // NEW STREAK KEY
                        noteTitle: "‡Æ™‡Æ§‡Øç‡Æ§‡Æø‡Æ∞‡Æø‡Æï‡Øà‡Æï‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡Øà‡Æö‡Øç ‡Æö‡Øá‡Æ∞‡Øç", noteDesc: "‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æé‡Æ©‡Øç‡Æ© ‡Æâ‡Æ£‡Æ∞‡Øç‡Æï‡Æø‡Æ±‡ØÄ‡Æ∞‡Øç‡Æï‡Æ≥‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æá‡Æ®‡Øç‡Æ§‡Æ§‡Øç ‡Æ§‡Æ∞‡ØÅ‡Æ£‡Æ§‡Øç‡Æ§‡Øà‡Æ§‡Øç ‡Æ§‡ØÇ‡Æ£‡Øç‡Æü‡Æø‡ÆØ‡Æ§‡ØÅ ‡Æé‡Æ©‡Øç‡Æ© ‡Æé‡Æ©‡Øç‡Æ™‡Æ§‡ØÅ ‡Æ™‡Æ±‡Øç‡Æ±‡Æø‡ÆØ ‡Æí‡Æ∞‡ØÅ ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡Øà‡Æö‡Øç ‡Æö‡Øá‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç. ‡Æá‡Æ§‡ØÅ ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡Æ§‡Æø‡Æµ‡Æø‡Æ≤‡Øç ‡Æö‡Øá‡ÆÆ‡Æø‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡ÆÆ‡Øç.",
                        notePlaceholder: "‡Æé.‡Æï‡Ææ., '‡Æµ‡Æï‡ØÅ‡Æ™‡Øç‡Æ™‡Æø‡Æ±‡Øç‡Æï‡ØÅ‡Æ™‡Øç ‡Æ™‡Æø‡Æ±‡Æï‡ØÅ ‡Æö‡Øã‡Æ∞‡Øç‡Æµ‡Ææ‡Æï ‡Æâ‡Æ£‡Æ∞‡Øç‡Æ®‡Øç‡Æ§‡Øá‡Æ©‡Øç,' '‡Æï‡ØÅ‡Æü‡ØÅ‡ÆÆ‡Øç‡Æ™‡Æ§‡Øç‡Æ§‡ØÅ‡Æü‡Æ©‡Øç ‡Æö‡Æ£‡Øç‡Æü‡Øà'", affirmTitle: "‡Æ§‡Æ©‡Æø‡Æ™‡Øç‡Æ™‡ÆØ‡Æ©‡Ææ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü ‡Æâ‡Æ±‡ØÅ‡Æ§‡Æø‡ÆÆ‡Øä‡Æ¥‡Æø‡Æï‡Æ≥‡Øç",
                        affirmDesc: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æö‡Æ∞‡Æø‡Æ™‡Ææ‡Æ∞‡Øç‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Æø‡Æ©‡Øç ‡Æ™‡Øã‡Æ§‡ØÅ ‡Æ§‡Øã‡Æ©‡Øç‡Æ±‡ØÅ‡ÆÆ‡Øç ‡Æ§‡Æ©‡Æø‡Æ™‡Øç‡Æ™‡ÆØ‡Æ©‡Ææ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü ‡Æâ‡Æ±‡ØÅ‡Æ§‡Æø‡ÆÆ‡Øä‡Æ¥‡Æø‡Æï‡Æ≥‡Øà‡Æö‡Øç ‡Æö‡Øá‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç. ‡Æá‡Æ®‡Øç‡Æ§ ‡Æä‡Æï‡Øç‡Æï‡ÆÆ‡Æ≥‡Æø‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç ‡Æµ‡Ææ‡Æ∞‡Øç‡Æ§‡Øç‡Æ§‡Øà‡Æï‡Æ≥‡Øç ‡Æï‡Æü‡Æø‡Æ©‡ÆÆ‡Ææ‡Æ© ‡Æ§‡Æ∞‡ØÅ‡Æ£‡Æô‡Øç‡Æï‡Æ≥‡Øà‡Æï‡Øç ‡Æï‡Æü‡Æï‡Øç‡Æï ‡Æâ‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç.",
                        affirmPlaceholder: "‡Æé.‡Æï‡Ææ., '‡Æ®‡Ææ‡Æ©‡Øç ‡Æá‡Æ®‡Øç‡Æ§‡Æ§‡Øç ‡Æ§‡Æ∞‡ØÅ‡Æ£‡Æ§‡Øç‡Æ§‡Æø‡Æ≤‡Øç ‡Æ™‡Ææ‡Æ§‡ØÅ‡Æï‡Ææ‡Æ™‡Øç‡Æ™‡Ææ‡Æï ‡Æá‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Æø‡Æ±‡Øá‡Æ©‡Øç.'",
                        affirmPrioritize: "‡ÆÖ‡Æ§‡Æø‡Æï ‡Æ™‡Æ§‡Æ±‡Øç‡Æ±‡ÆÆ‡Øç ‡Æâ‡Æ≥‡Øç‡Æ≥ ‡Æ§‡Æ∞‡ØÅ‡Æ£‡Æô‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æé‡Æ©‡Æ§‡ØÅ ‡Æâ‡Æ±‡ØÅ‡Æ§‡Æø‡ÆÆ‡Øä‡Æ¥‡Æø‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡ÆÆ‡ØÅ‡Æ©‡Øç‡Æ©‡ØÅ‡Æ∞‡Æø‡ÆÆ‡Øà ‡Æï‡Øä‡Æü‡ØÅ",
                        affirmClear: "‡ÆÖ‡Æ©‡Øà‡Æ§‡Øç‡Æ§‡Øà‡ÆØ‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ¥‡Æø", affirmRemove: "‡Æ®‡ØÄ‡Æï‡Øç‡Æï‡ØÅ", settingsTitle: "‡ÆÖ‡ÆÆ‡Øà‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç", settingsLang: "‡ÆÆ‡Øä‡Æ¥‡Æø / Language:",
                        settingsVisual: "‡Æï‡Ææ‡Æü‡Øç‡Æö‡Æø ‡ÆÖ‡ÆÆ‡Øà‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç", settingsDrips: "‡Æö‡Øä‡Æü‡Øç‡Æü‡ØÅ & ‡Æï‡ØÅ‡Æ≥‡ÆÆ‡Øç ‡Æµ‡Æø‡Æ≥‡Øà‡Æµ‡ØÅ‡Æï‡Æ≥‡Øà ‡Æá‡ÆØ‡Æï‡Øç‡Æï‡ØÅ", settingsShake: "‡Æ™‡Æ§‡Æ±‡Øç‡Æ±‡ÆÆ‡Øç ‡Æ§‡Æø‡Æ∞‡Øà ‡Æ®‡Æü‡ØÅ‡Æï‡Øç‡Æï‡Æ§‡Øç‡Æ§‡Øà ‡Æá‡ÆØ‡Æï‡Øç‡Æï‡ØÅ",
                        settingsAudio: "‡ÆÜ‡Æü‡Æø‡ÆØ‡Øã ‡ÆÖ‡ÆÆ‡Øà‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç", // NEW
                        settingsHaptic: "‡Æ§‡Øä‡Æü‡Øç‡Æü‡ØÅ‡Æ£‡Æ∞‡Øç‡Æö‡Øç‡Æö‡Æø ‡Æï‡Æ∞‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ", // NEW
                        hapticIntensity: "‡Æ§‡ØÄ‡Æµ‡Æø‡Æ∞‡ÆÆ‡Øç:", // NEW
                        hapticNote: "‡ÆÖ‡Æ©‡Øà‡Æ§‡Øç‡Æ§‡ØÅ ‡ÆÖ‡Æ§‡Æø‡Æ∞‡Øç‡Æµ‡ØÅ‡Æï‡Æ≥‡Øà‡ÆØ‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æï‡Øç‡Æï 0% ‡Æé‡Æ© ‡ÆÖ‡ÆÆ‡Øà‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.", // NEW
                        close: "‡ÆÆ‡ØÇ‡Æü‡ØÅ", save: "‡Æö‡Øá‡ÆÆ‡Æø", cancel: "‡Æ∞‡Æ§‡Øç‡Æ§‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç", add: "‡Æö‡Øá‡Æ∞‡Øç", notifyCopied: "‡Æï‡Æø‡Æ≥‡Æø‡Æ™‡Øç‡Æ™‡Øã‡Æ∞‡Øç‡Æü‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æ®‡Æï‡Æ≤‡ØÜ‡Æü‡ØÅ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ!",
                        notifyEmail: "‡Æ®‡Æï‡Æ≤‡ØÜ‡Æü‡ØÅ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ! ‡Æá‡Æ™‡Øç‡Æ™‡Øã‡Æ§‡ØÅ ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡ÆÆ‡Æø‡Æ©‡Øç‡Æ©‡Æû‡Øç‡Æö‡Æ≤‡Æø‡Æ≤‡Øç ‡Æí‡Æü‡Øç‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç.", healNotifyTitle: "‡Æï‡Ææ‡ÆØ‡ÆÆ‡Øç ‡Æï‡ØÅ‡Æ£‡ÆÆ‡Ææ‡Æï‡Æø‡ÆØ‡Æ§‡ØÅ!",
                        healNotifyDesc: "‡Æ§‡Æø‡Æ∞‡Øà‡ÆØ‡Øà ‡Æ®‡Æø‡Æ∞‡Æ™‡Øç‡Æ™‡ØÅ‡Æµ‡Æ§‡ØÅ ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æá‡Æ≤‡Æï‡Øç‡Æï‡ØÅ ‡ÆÖ‡Æ≤‡Øç‡Æ≤, ‡ÆÜ‡Æ©‡Ææ‡Æ≤‡Øç '‡ÆÆ‡ØÇ‡Æö‡Øç‡Æö‡ØÅ' ‡ÆÆ‡Æ±‡Øç‡Æ±‡ØÅ‡ÆÆ‡Øç '‡Æö‡Æµ‡Ææ‡Æ≤‡Øç' ‡Æï‡Æ∞‡ØÅ‡Æµ‡Æø‡Æï‡Æ≥‡Øà‡Æ™‡Øç ‡Æ™‡ÆØ‡Æ©‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æø ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç '‡ÆÆ‡Æ©‡Æö‡Øç ‡Æö‡ØÅ‡ÆÆ‡Øà‡ÆØ‡Øà' (‡Æï‡ØÄ‡Æ¥‡Øá ‡Æá‡Æü‡Æ§‡ØÅ‡Æ™‡ØÅ‡Æ±‡Æ§‡Øç‡Æ§‡Æø‡Æ≤‡Øç ‡Æâ‡Æ≥‡Øç‡Æ≥ ‡ÆÖ‡Æ≥‡Æµ‡Æø) ‡Æ®‡Æø‡Æ∞‡Øç‡Æµ‡Æï‡Æø‡Æ™‡Øç‡Æ™‡Æ§‡Ææ‡Æï‡ØÅ‡ÆÆ‡Øç. ‡Æá‡Æ§‡ØÅ ‡Æ®‡Æø‡Æµ‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç ‡Æ™‡ÆØ‡Æø‡Æ±‡Øç‡Æö‡Æø ‡Æö‡ØÜ‡ÆØ‡Øç‡Æµ‡Æ§‡Æ±‡Øç‡Æï‡Ææ‡Æ© ‡Æí‡Æ∞‡ØÅ ‡Æï‡Æ∞‡ØÅ‡Æµ‡Æø.",
                        groundingTitle: "‡Æ®‡Æø‡Æ≤‡Øà‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ‡ÆÆ‡Øç ‡Æ®‡Æø‡Æ±‡Øà‡Æµ‡ØÅ (Grounding Check-out)",
                        groundingIntro: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ®‡Ææ‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ§‡Øç ‡Æ§‡Æø‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡ØÅ‡Æµ‡Æ§‡Æ±‡Øç‡Æï‡ØÅ ‡ÆÆ‡ØÅ‡Æ©‡Øç, ‡Æí‡Æ∞‡ØÅ ‡Æö‡Æø‡Æ±‡Æø‡ÆØ ‡Æ®‡Æø‡Æ≤‡Øà‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ‡ÆÆ‡Øç ‡Æ™‡ÆØ‡Æø‡Æ±‡Øç‡Æö‡Æø‡ÆØ‡Øà ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ, ‡Æï‡Øä‡Æû‡Øç‡Æö‡ÆÆ‡Øç ‡ÆÖ‡ÆÆ‡Øà‡Æ§‡Æø‡ÆØ‡Ææ‡Æ© ‡Æ®‡Æø‡Æ≤‡Øà‡ÆØ‡ØÅ‡Æü‡Æ©‡Øç ‡Æá‡Æ®‡Øç‡Æ§ ‡Æá‡Æü‡Æ§‡Øç‡Æ§‡Øà ‡Æµ‡Æø‡Æü‡Øç‡Æü‡ØÅ ‡Æö‡ØÜ‡Æ≤‡Øç‡Æ≤‡Æ≤‡Ææ‡ÆÆ‡Øç.",
                        grounding5: "‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡Ææ‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æï‡Øç‡Æï‡ØÇ‡Æü‡Æø‡ÆØ 5 ‡Æµ‡Æø‡Æ∑‡ÆØ‡Æô‡Øç‡Æï‡Æ≥‡Øà ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡Æø‡Æü‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        grounding4: "‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ§‡Øä‡Æü‡Æï‡Øç‡Æï‡ØÇ‡Æü‡Æø‡ÆØ 4 ‡Æµ‡Æø‡Æ∑‡ÆØ‡Æô‡Øç‡Æï‡Æ≥‡Øà ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡Æø‡Æü‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        grounding3: "‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æï‡Øá‡Æü‡Øç‡Æï‡Æï‡Øç‡Æï‡ØÇ‡Æü‡Æø‡ÆØ 3 ‡Æí‡Æ≤‡Æø‡Æï‡Æ≥‡Øà ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡Æø‡Æü‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        grounding2: "‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡ÆÆ‡Æ£‡Æï‡Øç‡Æï‡Æï‡Øç‡Æï‡ØÇ‡Æü‡Æø‡ÆØ 2 ‡ÆÆ‡Æ£‡Æô‡Øç‡Æï‡Æ≥‡Øà ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡Æø‡Æü‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        grounding1: "‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æö‡ØÅ‡Æµ‡Øà‡Æï‡Øç‡Æï‡Æï‡Øç‡Æï‡ØÇ‡Æü‡Æø‡ÆØ 1 ‡Æö‡ØÅ‡Æµ‡Øà‡ÆØ‡Øà ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡Æø‡Æü‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
                        groundingCommitLabel: "‡ÆÖ‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æ§‡Ææ‡Æï ‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡ØÅ‡ÆÆ‡Øç ‡Æí‡Æ∞‡ØÅ ‡Æö‡Æø‡Æ±‡Æø‡ÆØ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç:",
                        groundingCommitPlaceholder: "‡Æ®‡Ææ‡Æ©‡Øç ‡Æí‡Æ∞‡ØÅ ‡Æü‡ÆÆ‡Øç‡Æ≥‡Æ∞‡Øç ‡Æ§‡Æ£‡Øç‡Æ£‡ØÄ‡Æ∞‡Øç ‡Æï‡ØÅ‡Æü‡Æø‡Æ™‡Øç‡Æ™‡Øá‡Æ©‡Øç.",
                        groundingExamples: "‡Æá‡Æ§‡ØÅ ‡ÆÆ‡Æø‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç ‡Æé‡Æ≥‡Æø‡ÆÆ‡Øà‡ÆØ‡Ææ‡Æ©‡Æ§‡Ææ‡Æï ‡Æá‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç; ‡Æâ‡Æ§‡Ææ‡Æ∞‡Æ£‡Æ§‡Øç‡Æ§‡Æø‡Æ±‡Øç‡Æï‡ØÅ \"‡Æ®‡Ææ‡Æ©‡Øç ‡Æ§‡Øã‡Æ≥‡Øç‡Æï‡Æ≥‡Øà ‡Æö‡Æø‡Æ±‡Æø‡Æ§‡ØÅ ‡Æ®‡ØÄ‡Æü‡Øç‡Æü‡Æø ‡Æ™‡Ææ‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æø‡Æ±‡Øá‡Æ©‡Øç\", \"‡Æ®‡Ææ‡Æ©‡Øç ‡Æö‡Æø‡Æ≤ ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ§‡Æø‡Æ∞‡Øà‡ÆØ‡Æø‡Æ≤‡Æø‡Æ∞‡ØÅ‡Æ®‡Øç‡Æ§‡ØÅ ‡Æµ‡Æø‡Æ≤‡Æï‡ØÅ‡Æï‡Æø‡Æ±‡Øá‡Æ©‡Øç\", ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ \"‡Æé‡Æ©‡Øç ‡Æ™‡Ææ‡Æ§‡ØÅ‡Æï‡Ææ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æ®‡Æ™‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æí‡Æ∞‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡Æø ‡ÆÖ‡Æ©‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æø‡Æ±‡Øá‡Æ©‡Øç\" ‡Æ™‡Øã‡Æ©‡Øç‡Æ±‡Æµ‡Øà.",
                        groundingSkip: "‡Æá‡Æ™‡Øç‡Æ™‡Øã‡Æ§‡Øà‡Æï‡Øç‡Æï‡ØÅ ‡Æ§‡Æµ‡Æø‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç",
                        groundingDone: "‡ÆÆ‡ØÅ‡Æü‡Æø‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ, ‡Æï‡Æ©‡Øç‡Æµ‡Ææ‡Æö‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æ§‡Æø‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™",
                        settingsChallengePrepTitle: "‡Æö‡Æµ‡Ææ‡Æ≤‡Øç ‡Æ§‡ÆØ‡Ææ‡Æ∞‡Ææ‡Æï‡ØÅ‡ÆÆ‡Øç ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç",
                        settingsChallengePrepLabel: "‡Æ§‡ÆØ‡Ææ‡Æ∞‡Øç ‡ÆÜ‡Æï‡ØÅ‡ÆÆ‡Øç ‡Æï‡Æµ‡ØÅ‡Æ©‡Øç‡Æü‡Øç‡Æü‡Æµ‡ØÅ‡Æ©‡Øç:",
                        settingsChallengePrepHint: "0 ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø ‡Æé‡Æ© ‡ÆÖ‡ÆÆ‡Øà‡Æ§‡Øç‡Æ§‡Ææ‡Æ≤‡Øç ‡ÆÆ‡ØÅ‡Æ©‡Øç‡Æ©‡Øã‡Æü‡Øç‡Æü ‡Æö‡Ææ‡Æ≥‡Æ∞‡ÆÆ‡Øç ‡Æá‡Æ≤‡Øç‡Æ≤‡Ææ‡ÆÆ‡Æ≤‡Øç ‡Æâ‡Æü‡Æ©‡Øá ‡Æö‡Æµ‡Ææ‡Æ≤‡Øç ‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç.",
                    }
                };

                // === Encouraging Messages & Challenges (kept from original) ===
                const encouragingMessages = [
                    "This moment is just one part of your journey, and it's okay if today feels heavy. Just try to focus on taking the next small, gentle step forward. Your strength isn't about getting through everything perfectly, but about continuing to show up for yourself, even when it's hard. You've got this.",
                    "Please remember that you are worthy of kindness and support, especially from yourself. The feelings you have are valid, but they don't define your entire future. There are people who care deeply about you and want to help carry this weight. Reach out‚Äîconnection is always available.",
                    "The most difficult feelings are temporary, even if they feel overwhelming right now. You are resilient, and is light waiting for you just beyond this moment. Give yourself permission to pause, breathe, and simply wait for the intensity to pass. Hold on just a little longer.",
                    "A setback isn't a failure, it's just a reminder that you're human. Be gentle with yourself today. Focus on tiny victories: a glass of water, a deep breath, or a moment of quiet. You are doing the best you can with what you have, and that is more than enough."
                ];
                const SENSORY_CHALLENGES = [
                  "challengeIceCubes",
                  "challengeColdSplash",
                  "challengeSourCandy",
                  "challengeStrongScent",
                  "challengeIntenseExercise",
                  "challengeRubberBand",
                  "challengeMarching",
                  "focus_challenge" // keep as special key
                ];
                // --- helpers for prep modal challenge switching ---
                const NON_FOCUS_CHALLENGES = SENSORY_CHALLENGES.filter(c => c !== 'focus_challenge');
                let lastPrepChallenge = null;

                function pickRandomNonFocusChallenge() {
                    if (NON_FOCUS_CHALLENGES.length === 0) return null;
                    let choice = NON_FOCUS_CHALLENGES[Math.floor(Math.random() * NON_FOCUS_CHALLENGES.length)];
                    // avoid immediate repeats if we have >1 option
                    if (NON_FOCUS_CHALLENGES.length > 1) {
                        while (choice === lastPrepChallenge) {
                            choice = NON_FOCUS_CHALLENGES[Math.floor(Math.random() * NON_FOCUS_CHALLENGES.length)];
                        }
                    }
                    lastPrepChallenge = choice;
                    return choice;
                }

                // =================================================================
                // CORE UTILITY FUNCTIONS (Defined first to solve ReferenceErrors)
                // =================================================================

                // Function to format a date to YYYY-MM-DD (Used for streak tracking)
                function formatDate(date) {
                    const d = new Date(date);
                    const year = d.getFullYear();
                    const month = String(d.getMonth() + 1).padStart(2, '0');
                    const day = String(d.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                }

                // NEW STREAK LOGIC
                function checkAndUpdateStreak() {
                    const now = new Date();
                    const todayStr = formatDate(now);

                    // Check if activity was already logged today (only updates streak if it's a new day's first action)
                    if (appState.lastActivityDay === todayStr) {
                        return;
                    }

                    const lastActivity = appState.lastActivityDay;

                    // Calculate yesterday's date string
                    const yesterday = new Date(now);
                    yesterday.setDate(now.getDate() - 1);
                    const yesterdayStr = formatDate(yesterday);

                    if (lastActivity === yesterdayStr) {
                        // Streak continues
                        appState.currentStreak = (appState.currentStreak || 0) + 1;
                    } else if (lastActivity) {
                        // Streak broken (last activity was before yesterday)
                        appState.currentStreak = 1;
                    } else {
                         // First time logging ever
                         appState.currentStreak = 1;
                    }

                    appState.lastActivityDay = todayStr;
                    triggerSave();
                }
// 1) Keys that may contain inline HTML like <strong>‚Ä¶</strong>
const LANG_HTML_KEYS = new Set([
  // Guide ‚ÄúQuick Start‚Äù list items (contain <strong>)
  "quick1", "quick2", "quick3", "quick4", "quick5",
  // Challenge instruction line (has <strong>Start the task NOW.</strong>)
  "challengeInstruct",
]);

// 2) Helper to render HTML only for approved keys
function setHTMLOrText(el, val, key) {
  if (LANG_HTML_KEYS.has(key)) {
    el.innerHTML = val;
  } else {
    el.textContent = val;
  }
}

// 3) getTranslation stays simple & safe
function getTranslation(key) {
  const lang = appState?.settings?.language || 'en';
  const dict = translations[lang] || translations['en'] || {};
  return (dict[key] != null ? dict[key] : (translations['en'] ? translations['en'][key] : ""));
}

// 4) Main updater
function updateLanguage(lang) {
  if (!translations[lang]) lang = 'en';
  appState.settings.language = lang;

  // data-lang: may include HTML for approved keys
  document.querySelectorAll('[data-lang]').forEach(el => {
    const key = el.getAttribute('data-lang');
    const val = (translations[lang] && translations[lang][key]) ?? (translations['en'] && translations['en'][key]);
    if (val != null) setHTMLOrText(el, val, key);
  });

  // data-lang-target: plain text only (e.g., theme/mode names)
  document.querySelectorAll('[data-lang-target]').forEach(el => {
    const themeKey = THEMES[currentTheme].modeName;
    const val = (translations[lang] && translations[lang][themeKey]) ?? (translations['en'] && translations['en'][themeKey]);
    if (val != null) el.textContent = val;
  });

  // placeholder-key: inputs placeholders ‚Äî plain text only
  document.querySelectorAll('[placeholder-key]').forEach(el => {
    const key = el.getAttribute('placeholder-key');
    const val = (translations[lang] && translations[lang][key]) ?? (translations['en'] && translations['en'][key]);
    if (val != null) el.placeholder = val;
  });

  // persist settings if available
  if (typeof saveSettings === 'function') saveSettings();

  // ‚úÖ These were previously outside‚Äîkeep them INSIDE the function
  if (typeof updateMeterDisplay === 'function') updateMeterDisplay();
  if (typeof updateLogModal === 'function' && typeof logModal !== 'undefined' && !logModal.classList.contains('hidden')) {
    updateLogModal();
  }
  if (typeof updateAffirmationsList === 'function') updateAffirmationsList();
}


                function drawTaperedCutSegments(ctxToUse, cut) {
                    const points = cut.smoothPoints;
                    if (points.length < 2) return;
                    const progress = cut.currentHealStrokes / cut.requiredHealStrokes;
                    ctxToUse.globalAlpha = Math.max(0.1, 1.0 - progress);
                    ctxToUse.strokeStyle = LINE_COLOR;
                    ctxToUse.lineCap = 'round';
                    ctxToUse.lineJoin = 'round';
                    ctxToUse.shadowBlur = 0;
                    const totalSegments = points.length - 1;
                    for (let i = 0; i < totalSegments; i++) {
                        const t = i / totalSegments;
                        const width = MAX_CUT_WIDTH * 4 * t * (1 - t);
                        ctxToUse.beginPath();
                        ctxToUse.moveTo(points[i].x, points[i].y);
                        ctxToUse.lineTo(points[i + 1].x, points[i + 1].y);
                        ctxToUse.lineWidth = width;
                        ctxToUse.stroke();
                    }
                }

                function drawHealLineSegments(ctxToUse, healLine, alphaOverride = 1.0) {
                const points = healLine.points;
                if (!points || points.length < 2) return;

                const alpha = Math.max(0, Math.min(1, alphaOverride));
                ctxToUse.save();
                ctxToUse.globalAlpha = alpha;

                ctxToUse.strokeStyle = HEAL_COLOR;
                ctxToUse.lineWidth = HEAL_WIDTH;
                ctxToUse.lineCap = 'round';
                ctxToUse.lineJoin = 'round';
                ctxToUse.shadowColor = HEAL_GLOW_COLOR;
                ctxToUse.shadowBlur = 10;

                ctxToUse.beginPath();
                ctxToUse.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctxToUse.lineTo(points[i].x, points[i].y);
                }
                ctxToUse.stroke();

                ctxToUse.restore();
            }


                function drawDripPool(x, y) {
                    if (!appState.settings.enableDrips) return;
                    staticCtx.fillStyle = `rgba(128, 0, 0, 0.7)`;
                    staticCtx.beginPath();
                    staticCtx.ellipse(x, y, 4, 3, 0, 0, 2 * Math.PI);
                    staticCtx.fill();
                }

                function drawTrailSegments(ctxToUse, trail) {
                    if (trail.length < 2) return;
                    ctxToUse.strokeStyle = DRIP_COLOR;
                    ctxToUse.lineCap = 'round';
                    ctxToUse.lineJoin = 'round';
                    ctxToUse.shadowBlur = 0;
                    for (let i = 0; i < trail.length - 1; i++) {
                        const p1 = trail[i];
                        const p2 = trail[i + 1];
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        let nx = 0, ny = 0;
                        if (length > 0) {
                            nx = -dy / length;
                            ny = dx / length;
                        }
                        const randomWidth = 1 + Math.random() * (TRAIL_WIDTH_MAX - 1);
                        ctxToUse.lineWidth = randomWidth;
                        const randomOffset = (Math.random() * 2 - 1) * TRAIL_JAGGED_OFFSET;
                        const offsetX = nx * randomOffset;
                        const offsetY = ny * randomOffset;
                        ctxToUse.beginPath();
                        ctxToUse.moveTo(p1.x + offsetX, p1.y + offsetY);
                        ctxToUse.lineTo(p2.x + offsetX, p2.y + offsetY);
                        ctxToUse.stroke();
                    }
                }

                function redrawStaticContent() {
                    staticCtx.fillStyle = THEMES[currentTheme].canvasBg;
                    staticCtx.fillRect(0, 0, staticCanvas.width, staticCanvas.height);

                    appState.cuts.forEach(cut => {
                        const progress = cut.currentHealStrokes / cut.requiredHealStrokes;
                        const alpha = Math.max(0.1, 1.0 - progress);
                        staticCtx.globalAlpha = alpha;

                        drawTaperedCutSegments(staticCtx, cut);

                        if (appState.settings.enableDrips) {
                            if (cut.pools) {
                                cut.pools.forEach(pool => drawDripPool(pool.x, pool.y));
                            }
                            if (cut.completedTrails) {
                                cut.completedTrails.forEach(trail => {
                                    drawTrailSegments(staticCtx, trail);
                                });
                            }
                        }
                    });

                    updateMeterDisplay();
                }

                function updateMeterDisplay() {
            // Clamp ML within bounds
            appState.currentML = Math.max(0, Math.min(appState.currentML, MAX_ML));
            const percentage   = Math.floor((appState.currentML / MAX_ML) * 100);
            const tensionRatio = appState.currentML / MAX_ML;

            // === 60% Rule: Proactive micro check ===
            // Triggers ONCE per session when ML is between 60% and 99%,
            // and only if no micro-check / cooldown / challenge / relief is running.
            if (
                !microCheckCompleted &&
                !microCheckRequired &&
                !isMicroCheckActive &&
                !microCheckCooldownActive &&
                appState.currentML >= MAX_ML * 0.6 &&
                appState.currentML < MAX_ML
            ) {
                microCheckRequired = true;
                showMicroCheckModal();
            }

            // === Meter Color + Overload Logic ===
            const HUE        = 350;
            const SATURATION = Math.min(100, 30 + (tensionRatio * 70));
            const LIGHTNESS  = Math.max(40, 70 - (tensionRatio * 30));
            const fillColor  = `hsl(${HUE}, ${SATURATION}%, ${LIGHTNESS}%)`;

            let valueText;

            if (percentage >= 100) {
                // Hard cap display at max
                valueText = `${(MAX_ML / ML_DISPLAY_FACTOR).toFixed(1)}`;
                mlMeterContainerEl.style.background = fillColor;

                // Show overload modal ONLY if no micro-check / cooldown / challenge / relief is running
                if (!isChallengeActive && !isReliefActive && !isMicroCheckActive && !microCheckCooldownActive) {
                    overloadModal.classList.remove('hidden');
                }
            } else {
                valueText = `${(appState.currentML / ML_DISPLAY_FACTOR).toFixed(1)}`;
                mlMeterContainerEl.style.background =
                    `conic-gradient(${fillColor} ${percentage}%, ${THEMES[currentTheme].meterBg} ${percentage}%)`;
                overloadModal.classList.add('hidden');
            }

            const maxMlDisplay = (MAX_ML / ML_DISPLAY_FACTOR).toFixed(1);
            mlPercentEl.innerHTML = `
                <span style="font-size: 1.1rem; font-weight: bold; line-height: 1;">${valueText}</span>
                <span style="font-size: 0.6rem; opacity: 0.8; margin-top: 2px;">/ ${maxMlDisplay} ml</span>
            `;
        }


                function applyTheme(theme) {
                    const oppositeTheme = theme === 'dark' ? 'light' : 'dark';
                    const config = THEMES[theme];
                    const oppositeConfig = THEMES[oppositeTheme];

                    // 1. Body Background
                    document.body.style.backgroundColor = config.bodyBg;
                    // 2. Header
                    headerEl.classList.remove(oppositeConfig.headerBg, oppositeConfig.headerText, oppositeConfig.headerBorder);
                    headerEl.classList.add(config.headerBg, config.headerText, config.headerBorder);
                    // 3. Header Description
                    headerDescriptionEl.classList.remove(oppositeConfig.headerDescText);
                    headerDescriptionEl.classList.add(config.headerDescText);
                    // 4. ML Meter
                    mlMeterContainerEl.style.backgroundColor = config.meterBg;
                    mlMeterContainerEl.style.borderColor = config.meterBorder;
                    mlPercentEl.style.backgroundColor = config.meterInnerBg;
                    mlPercentEl.style.color = config.headerText;
                    // 5. Theme Toggle Button
                    themeIconEl.innerHTML = config.iconPath;
                    // Use getTranslation to make sure theme button text is updated on language change
                    themeTextEl.textContent = getTranslation(oppositeConfig.modeName);


                    // Helper to apply styles to a button
                    const styleButton = (btn, text, bg, hover, border, borderHover) => {
                        // Remove all possible theme classes first
                        btn.classList.remove(
                            oppositeConfig[text], oppositeConfig[bg], oppositeConfig[hover],
                            oppositeConfig[border], oppositeConfig[borderHover],
                            config[text], config[bg], config[hover],
                            config[border], config[borderHover]
                        );
                        // Add the correct classes for the current theme
                        btn.classList.add(
                            config[text], config[bg], config[hover],
                            config[border], config[borderHover]
                        );
                    };

                    // 6. Style Primary Buttons (Always colored, only text color changes)
                    const primaryButtons = [modeToggleButton, breathButton, challengeButton, affirmationsButton];
                    primaryButtons.forEach(btn => {
                        btn.classList.remove(oppositeConfig.cutHealText, config.cutHealText); // Use cutHealText as a generic key
                        btn.classList.add(config.cutHealText);
                    });

                    // 7. Style Utility Buttons (Colors change with theme)
                    styleButton(themeToggleButton, 'themeText', 'themeBg', 'themeHover', 'themeBorder', 'themeBorderHover');
                    styleButton(logButton, 'logText', 'logBg', 'logHover', 'logBorder', 'logBorderHover');
                    styleButton(settingsButton, 'settingsText', 'settingsBg', 'settingsHover', 'settingsBorder', 'settingsBorderHover');
                    styleButton(undoButton, 'undoText', 'undoBg', 'undoHover', 'undoBorder', 'undoBorderHover');
                    styleButton(clearButton, 'clearText', 'clearBg', 'clearHover', 'clearBorder', 'clearBorderHover');
                    // NEW: Info Button
                    styleButton(infoButton, 'infoText', 'infoBg', 'infoHover', 'infoBorder', 'infoBorderHover');

                    // 8. Update Primary Button Colors (which are theme-independent)
                    modeToggleButton.classList.add('bg-red-700', 'hover:bg-red-600', 'border-red-900', 'hover:border-red-800');
                    breathButton.classList.add('bg-emerald-600', 'hover:bg-emerald-500', 'border-emerald-800', 'hover:border-emerald-700');
                    challengeButton.classList.add('bg-indigo-700', 'hover:bg-indigo-600', 'border-indigo-900', 'hover:border-indigo-800');
                    affirmationsButton.classList.add('bg-teal-600', 'hover:bg-teal-500', 'border-teal-800', 'hover:border-teal-700');

                    // 9. Update Mode Button (if in heal mode)
                    updateModeButton();

                    // 10. Modal Wrappers
                    const modalWrappers = [welcomeModal, checkinModal, sensoryChallengeModal, logModal, addNoteModal, affirmationsModal, settingsModal, overloadModal];
                    modalWrappers.forEach(modal => {
                        if (modal) {
                            modal.classList.remove(oppositeConfig.modalBg);
                            modal.classList.add(config.modalBg);
                        }
                    });

                    // 11. Save preference and update state
                    currentTheme = theme;
                    localStorage.setItem('theme', theme);

                    // 12. Redraw canvas to update background
                    redrawStaticContent();
                }

                function toggleTheme() {
                    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                    applyTheme(newTheme);
                }

                function loadTheme() {
                    const savedTheme = localStorage.getItem('theme');
                    const initialTheme = savedTheme && THEMES[savedTheme] ? savedTheme : 'dark';
                    applyTheme(initialTheme);
                }

                function drawTemporaryLine(points) {
                    activeCtx.shadowBlur = 0;
                    if (isHealMode) {
                        activeCtx.strokeStyle = HEAL_COLOR;
                        activeCtx.lineWidth = HEAL_WIDTH;
                        activeCtx.lineCap = 'round';
                        activeCtx.lineJoin = 'round';
                        activeCtx.shadowColor = HEAL_GLOW_COLOR;
                        activeCtx.shadowBlur = 15;
                    } else {
                        activeCtx.strokeStyle = LINE_COLOR;
                        activeCtx.lineWidth = MAX_CUT_WIDTH;
                        activeCtx.lineCap = 'round';
                        activeCtx.lineJoin = 'round';
                        activeCtx.shadowBlur = 0;
                    }
                    activeCtx.globalAlpha = 1.0;
                    activeCtx.beginPath();
                    if (points.length > 0) {
                        activeCtx.moveTo(points[0].x, points[0].y);
                        for (let i = 1; i < points.length; i++) {
                            activeCtx.lineTo(points[i].x, points[i].y);
                        }
                    }
                    activeCtx.stroke();
                    activeCtx.shadowBlur = 0;
                }

                function calculatePathLength(points) {
                    let length = 0;
                    for (let i = 1; i < points.length; i++) {
                        const p1 = points[i - 1];
                        const p2 = points[i];
                        length += Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                    }
                    return length;
                }

                function generateTaperedPoints(start, end, segmentCount) {
                    const points = [];
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    for (let i = 0; i <= segmentCount; i++) {
                        const t = i / segmentCount;
                        points.push({
                            x: start.x + t * dx,
                            y: start.y + t * dy
                        });
                    }
                    return points;
                }

                function draw(timestamp = 0) {
                    const deltaTime = timestamp - lastTime;
                    lastTime = timestamp;
                    const deltaTimeSeconds = deltaTime / 1000;

                    // 1. Handle Relief Draining
                    if (isReliefActive) {
                        const drainAmount = RELIEF_PER_SECOND * deltaTimeSeconds;
                        appState.currentML -= drainAmount;
                        reliefMLDrained += drainAmount;
                        updateMeterDisplay();
                    }

                    // 2. Clear the ACTIVE canvas
                    activeCtx.clearRect(0, 0, activeCanvas.width, activeCanvas.height);

                    const tensionRatio = appState.currentML / MAX_ML;

                    // 3. Apply Visual Tension Effects
                    if (appState.settings.enableShake) {
                        if (tensionRatio >= SHAKE_THRESHOLD) {
                            document.body.classList.add('shaking');
                        } else {
                            document.body.classList.remove('shaking');
                        }
                    } else {
                        document.body.classList.remove('shaking');
                    }

                    let overlayOpacity = 0.0;
                    if (tensionRatio > 0.05) {
                        overlayOpacity = tensionRatio * MAX_RED_OPACITY;
                    }
                    tensionOverlay.style.backgroundColor = `rgba(139, 0, 0, ${overlayOpacity.toFixed(3)})`;

                    // 4. Drip generation (if enabled)
                    if (appState.settings.enableDrips && !mlDripPaused) {
                        const dynamicAcceleration = BASE_DRIP_ACCELERATION + (tensionRatio * (MAX_DRIP_ACCELERATION - BASE_DRIP_ACCELERATION));
                        const dynamicGlobalDelay = MIN_GLOBAL_DELAY_MAX - (tensionRatio * (MIN_GLOBAL_DELAY_MAX - MIN_GLOBAL_DELAY_MIN));

                        let dripGeneratedThisCycle = false;
                        if ((timestamp - globalLastDripTime) > dynamicGlobalDelay) {
                            appState.cuts.forEach(cut => {
                                if (dripGeneratedThisCycle) return;
                                const dynamicCooldown = BASE_DRIP_COOLDOWN_MS - (tensionRatio * (BASE_DRIP_COOLDOWN_MS - MIN_DRIP_COOLDOWN_MS));
                                if ((timestamp - cut.lastDripTime) > dynamicCooldown) {
                                    const t = Math.random();
                                    const dripX = cut.start.x + t * (cut.end.x - cut.start.x);
                                    let dripY = cut.start.y + t * (cut.end.y - cut.start.y);
                                    dripY += 5;
                                    activeDrips.push({
                                        cutId: cut.id,
                                        x: dripX,
                                        y: dripY,
                                        vY: DRIP_INITIAL_SPEED,
                                        trail: [{ x: dripX, y: dripY }],
                                        cutRef: cut
                                    });
                                    cut.lastDripTime = timestamp;
                                    globalLastDripTime = timestamp;
                                    dripGeneratedThisCycle = true;
                                }
                            });
                        }

                        // 5. Update and Draw ACTIVE Drips
                        const dropsToKeep = [];
                        activeDrips.forEach(drip => {
                            drip.vY += dynamicAcceleration;
                            drip.y += drip.vY;
                            drip.trail.push({ x: drip.x, y: drip.y });

                            if (drip.y > activeCanvas.height) {
                                drip.cutRef.completedTrails.push(drip.trail);
                                const poolY = activeCanvas.height - POOL_CENTER_OFFSET;
                                drip.cutRef.pools.push({ x: drip.x, y: poolY });

                                const trailLength = drip.trail.reduce((sum, p, index, arr) => {
                                    if (index === 0) return 0;
                                    const prev = arr[index - 1];
                                    return sum + Math.sqrt(Math.pow(p.x - prev.x, 2) + Math.pow(p.y - prev.y, 2));
                                }, 0);
                                const mlAdded = trailLength * ML_ACCUMULATION_MULTIPLIER;
                                appState.currentML += mlAdded;

                                logMLChange('cut', mlAdded, `Cut ID ${drip.cutId} drip finished`);

                                drip.cutRef.totalML = (drip.cutRef.totalML || 0) + mlAdded;
                                updateMeterDisplay();
                                redrawStaticContent();
                            } else {
                                dropsToKeep.push(drip);
                                drawTrailSegments(activeCtx, drip.trail);
                            }
                        });
                        activeDrips = dropsToKeep;
                    } else {
                        // If drips are disabled, clear any existing ones
                        activeDrips = [];
                    }

                    // 6. Draw temporary line
                    if (isDrawing && startPoint && endPoint) {
                        drawTemporaryLine(currentStrokePoints);
                    }
                    // === Render fading heal strokes on ACTIVE canvas ===
                    if (appState.healLines && appState.healLines.length) {
                      const now = performance.now();
                      const keep = [];

                      for (const hl of appState.healLines) {
                        // stamp createdAt once so fade actually advances
                        if (!hl.createdAt) hl.createdAt = now;
                        const fadeMs = hl.fadeMs ?? HEAL_FADE_MS;
                        const age    = now - hl.createdAt;

                        // linear fade from 1 ‚Üí 0 over fadeMs
                        const t = Math.min(1, age / fadeMs);
                        const alpha = 1 - t;

                        if (alpha > 0) {
                          drawHealLineSegments(activeCtx, hl, alpha);
                          keep.push(hl);
                        }
                        // else: fully faded ‚Üí drop it
                      }

                      // remove fully faded lines so they don't linger
                      if (keep.length !== appState.healLines.length) {
                        appState.healLines = keep;
                        // no need to redraw static; heal lines live on ACTIVE canvas only
                      }
                    }
                    function clearActiveStroke() {
                      currentStrokePoints = [];
                      startPoint = null;
                      endPoint = null;
                      isDrawing = false;
                      activeCtx.clearRect(0, 0, activeCanvas.width, activeCanvas.height);
                    }

                    requestAnimationFrame(draw);
                }

                    // Canvas-wide decay loop
                    const DECAY_FPS = 60;          // target frame rate
                    let DECAY_PER_TICK = 0.25;     // will be set from Settings (slider)

                    let _lastDecay = 0;
                    function startActiveFadeLoop() {
                      function step(ts) {
                        if (!_lastDecay || ts - _lastDecay >= 1000 / DECAY_FPS) {
                          _lastDecay = ts;

                          // fade everything on the active layer a bit each tick
                          activeCtx.save();
                          activeCtx.globalCompositeOperation = 'destination-out';
                          activeCtx.globalAlpha = DECAY_PER_TICK;
                          activeCtx.fillRect(0, 0, activeCanvas.width, activeCanvas.height);
                          activeCtx.restore();
                        }
                        requestAnimationFrame(step);
                      }
                      requestAnimationFrame(step);
                    }

                    // call this once after canvases are created
                    startActiveFadeLoop();

                    function startStrokeRAF() {
                      function tick() {
                        drawActiveStroke();
                        requestAnimationFrame(tick);
                      }
                      requestAnimationFrame(tick);
                    }
                    startStrokeRAF();

    function endDrawing() {
      // commit to static layer...
      clearActiveStroke();          // instantly remove temp
      // Optional: one extra decay blast to ensure no ghosting
      activeCtx.save();
      activeCtx.globalCompositeOperation = 'destination-out';
      activeCtx.globalAlpha = 1;    // full erase
      activeCtx.fillRect(0, 0, activeCanvas.width, activeCanvas.height);
      activeCtx.restore();

      redrawStaticContent();
    }


                function resizeCanvas() {
                    staticCanvas.width = window.innerWidth;
                    staticCanvas.height = window.innerHeight;
                    activeCanvas.width = window.innerWidth;
                    activeCanvas.height = window.innerHeight;
                    redrawStaticContent();
                    if (!isDrawing) {
                        // FIX: Ensure draw is called here to keep animation loop running
                        draw();
                    }
                }

                // =================================================================
                // FIREBASE / DATA PERSISTENCE
                // =================================================================

                function firebaseInit() {
                    // Check if Firebase was loaded
                    if (typeof window.initializeApp === 'undefined') { // Checking for global variable directly
                        console.warn("Firebase libraries not loaded. App will start in local-only mode.");
                        startLocalApp();
                        return;
                    }

                    try {
                        // DO NOT PROMPT FOR THESE
                        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                        const authToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

                        if (!firebaseConfig.apiKey) {
                            console.warn("Firebase config not found. App will start in local-only mode.");
                            startLocalApp(); // Start local mode if config is missing
                            return;
                        }

                        // Use globally accessible functions directly
                        const app = initializeApp(firebaseConfig);
                        db = getFirestore(app);
                        auth = getAuth(app);
                        // setLogLevel('Debug'); // Enable debug logging for Firestore

                        // Set a timeout to ensure app starts even if auth is slow
                        const authTimeout = setTimeout(() => {
                            if (!isFirebaseReady) {
                                console.warn("Firebase auth timed out. Starting in local-only mode.");
                                startLocalApp();
                            }
                        }, FIREBASE_TIMEOUT_MS);

                        onAuthStateChanged(auth, async (user) => {
                            clearTimeout(authTimeout); // Auth responded
                            if (isFirebaseReady) return; // Already handled

                            if (user) {
                                console.log("User is signed in:", user.uid);
                                userId = user.uid;
                                isFirebaseReady = true;
                                // User is signed in, load their data
                                loadDataFromFirestore();
                            } else if (authToken) {
                                // No user, but we have a token
                                console.log("Signing in with custom token...");
                                await signInWithCustomToken(auth, authToken);
                            } else {
                                // No user, no token
                                console.log("Signing in anonymously...");
                                await signInAnonymously(auth);
                            }
                        });

                    } catch (error) {
                        console.error("Error initializing Firebase:", error);
                        startLocalApp(); // Start local mode on any error
                    }
                }

                function startLocalApp() {
                    if (isFirebaseReady) return; // Prevent double-start
                    isFirebaseReady = true; // Mark as "ready" (in local mode)
                    console.log("Starting app in local-only mode.");
                    // Apply all default states
                    applyFullAppState();
                }

                function getDocRef() {
                    // DO NOT PROMPT FOR THIS
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    // Use private user-specific collection
                    return doc(db, 'artifacts', appId, 'users', userId, 'cmioy-session', 'userData');
                }

                async function loadDataFromFirestore() {
                    if (!userId) {
                        startLocalApp();
                        return;
                    }

                    // Stop any previous listener
                    if (unsubscribe) unsubscribe();

                    const docRef = getDocRef();

                    // Use onSnapshot to listen for real-time changes
                    unsubscribe = onSnapshot(docRef, (docSnap) => {
                        if (docSnap.exists()) {
                            console.log("Firebase data loaded.");
                            const loadedData = docSnap.data();

                            // Merge loaded data with default state
                            appState = {
                                ...appState,
                                ...loadedData,
                                settings: {
                                    ...appState.settings,
                                    // Ensure hapticIntensity defaults if missing, otherwise use loaded
                                    hapticIntensity: loadedData.settings?.hapticIntensity ?? 50,
                                    ...(loadedData.settings || {}),
                                },
                            };

                        } else {
                            console.log("No existing document found. Saving initial state.");
                            saveDatatoFirestore(); // Save the default state
                        }

                        // Re-apply state to the whole application
                        applyFullAppState();

                    }, (error) => {
                        console.error("Error loading data from Firestore:", error);
                        startLocalApp(); // Fallback to local mode on listener error
                    });
                }

                function triggerSave() {
                    if (!userId) return; // Don't save if not authenticated (local mode)

                    if (saveTimeout) {
                        clearTimeout(saveTimeout);
                    }

                    saveTimeout = setTimeout(() => {
                        saveDatatoFirestore();
                        saveTimeout = null;
                    }, DEBOUNCE_SAVE_MS);
                }

                async function saveDatatoFirestore() {
                    if (!userId || isSaving) return;
                    isSaving = true;
                    console.log("Saving data to Firebase...");

                    try {
                        const stateToSave = {
                currentML: appState.currentML,
                cuts: appState.cuts,
                healLines: appState.healLines,
                history: appState.history.map(h => ({ id: h.id, type: h.type })),
                mlHistory: appState.mlHistory,
                userAffirmations: appState.userAffirmations,
                settings: appState.settings,
                hasWelcomed: appState.hasWelcomed,
                // üëá do NOT persist hasHealedOnce anymore
                // hasHealedOnce: appState.hasHealedOnce,
                // NEW STREAK DATA
                lastActivityDay: appState.lastActivityDay,
                currentStreak: appState.currentStreak
            };
                        await setDoc(docRef, stateToSave, { merge: true });
                        console.log("Data saved successfully.");
                    } catch (error) {
                        console.error("Error saving data to Firestore:", error);
                    }
                    isSaving = false;
                }

                function applyFullAppState() {
                    // ALWAYS reset ML to 0 on app start for a fresh session
                    if (appState.currentML > 0) {
                        appState.currentML = 0;
                        if (userId) { // Only trigger save if we're connected
                            triggerSave();
                        }
                    }

                    // Apply all settings from appState
                    isHealMode = false; // Always reset mode on load
                    strokesSinceLastPrompt = 0;
                    healStrokeCountThisSession = 0; // NEW: reset per session
                    appState.hasHealedOnce = false; // NEW: allow the heal message once every session

                    // Restore settings
                    languageSelector.value = appState.settings.language;
                    updateLanguage(appState.settings.language);

                    prioritizeAffirmations.checked = appState.settings.prioritizeAffirmations;

                    toggleDrips.checked = appState.settings.enableDrips;
                    toggleShake.checked = appState.settings.enableShake;

                    // On app/state load:
                    if (!appState.settings) appState.settings = {};
                    if (typeof appState.settings.fadeDecayPerTick !== 'number') {
                      appState.settings.fadeDecayPerTick = DECAY_PER_TICK; // default 0.25
                    }

                    // Apply to runtime and UI
                    DECAY_PER_TICK = appState.settings.fadeDecayPerTick;
                    if (fadeSpeedEl) {
                      fadeSpeedEl.value = appState.settings.fadeDecayPerTick.toFixed(2);
                      if (fadeSpeedValueEl) fadeSpeedValueEl.textContent = fadeSpeedEl.value;
                    }
                    if (fadeSpeedEl) {
                      fadeSpeedEl.addEventListener('input', (e) => {
                        const v = Math.max(0.05, Math.min(0.50, parseFloat(e.target.value) || 0.25));
                        DECAY_PER_TICK = v;                             // immediately affects fade loop
                        appState.settings.fadeDecayPerTick = v;         // persist to state
                        if (fadeSpeedValueEl) fadeSpeedValueEl.textContent = v.toFixed(2);
                        saveAppState && saveAppState();                 // call your existing saver
                      });
                    }

                    // Restore Haptic setting
                    const intensity = appState.settings.hapticIntensity = appState.settings.hapticIntensity ?? 50;
                    hapticIntensitySlider.value = intensity;
                    hapticIntensityValue.textContent = `${intensity}%`;

                    // Restore Challenge Prep Time (seconds)
                    const prepSeconds =
                        appState.settings.challengePrepSeconds =
                            appState.settings.challengePrepSeconds ?? CHALLENGE_PREP_SECONDS;

                    if (challengePrepSlider && challengePrepValue) {
                        challengePrepSlider.value = prepSeconds;
                        challengePrepValue.textContent = `${prepSeconds}s`;
                    }

                    // Ensure streak state defaults if not loaded
                    if (typeof appState.currentStreak === 'undefined' || appState.currentStreak === null) {
                        appState.currentStreak = 0;
                    }
                    if (typeof appState.lastActivityDay === 'undefined') {
                         appState.lastActivityDay = null;
                    }
                  // snap the temp line away immediately
                  clearActiveStroke();

                    // Update UI elements
                    updateAffirmationsList();
                    updateModeButton();
                    redrawStaticContent(); // Redraws all cuts/heals
                    updateMeterDisplay(); // Updates ML meter
                }

                // =================================================================
                // AUDIO AND HAPTIC FUNCTIONS
                // =================================================================

                function initializeAudio() {
                    // Check if audio is already initialized
                    if (cutSynth) return;
                    if (typeof Tone === 'undefined') return; // Tone.js not loaded

                    Tone.start();

                    // 1. Cut Synth
                    cutSynth = new Tone.MembraneSynth({
                        pitchDecay: 0.01,
                        octaves: 2,
                        envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
                    }).toDestination();
                    cutSynth.volume.value = Tone.gainToDb(STATIC_SFX_VOLUME) + 6;

                    // 2. Heal Synth
                    healSynth = new Tone.PluckSynth({
                        attackNoise: 0.5,
                        dampening: 4000,
                        resonance: 0.8
                    }).toDestination();
                    healSynth.volume.value = Tone.gainToDb(STATIC_SFX_VOLUME) + 6;

                    // 3. Breath Noise and Filter (Breathing SFX)
                    breathNoise = new Tone.Noise("pink").start(); // Using pink noise for a fuller sound
                    breathNoise.volume.value = -Infinity; // Start muted

                    breathFilter = new Tone.Filter({
                        type: "lowpass",
                        frequency: 100, // Starting low
                        Q: 0.5
                    }).toDestination();

                    breathNoise.connect(breathFilter);

                    audioMuted = false;
                    console.log("Audio initialized.");
                }

                function playSound(type) {
                    if (audioMuted) return;
                    try {
                        if (type === 'cut' && cutSynth) {
                            cutSynth.triggerAttackRelease("C1", "8n", Tone.now());
                        } else if (type === 'heal' && healSynth) {
                            healSynth.triggerAttackRelease("C4", "8n", Tone.now());
                        }
                    } catch (e) {
                        console.warn("Audio playback error:", e);
                    }
                }

                function startBreathSound() {
                    if (audioMuted || !breathNoise) return;

                    // Fade in volume immediately
                    breathNoise.volume.rampTo(Tone.gainToDb(STATIC_BREATH_VOLUME) + 6, 0.5);

                    // Set up initial filter automation for the first inhale (State 0)
                    const inhaleDuration = 4; // Matches breathInterval time
                    const now = Tone.now();

                    // Inhale: Filter sweeps up (mimics air rushing in)
                    breathFilter.frequency.setValueAtTime(100, now);
                    breathFilter.frequency.linearRampToValueAtTime(1000, now + inhaleDuration);
                }

                function updateBreathSound(state) {
                    if (audioMuted || !breathNoise) return;
                    const now = Tone.now();
                    const duration = 4; // Matches breath interval

                    if (state === 0) { // Inhale (Increase frequency)
                        breathFilter.frequency.linearRampToValueAtTime(1000, now + duration);
                    } else if (state === 1) { // Hold 1 (Slight drop or maintain high frequency)
                        breathFilter.frequency.linearRampToValueAtTime(1200, now + duration); // Slight peak
                    } else if (state === 2) { // Exhale (Decrease frequency)
                        breathFilter.frequency.linearRampToValueAtTime(100, now + duration);
                    } else if (state === 3) { // Hold 2 (Maintain low frequency)
                        breathFilter.frequency.linearRampToValueAtTime(150, now + duration);
                    }
                }

                function stopBreathSound() {
                    if (!breathNoise) return;
                    // Fade out volume and stop the noise
                    breathNoise.volume.rampTo(-Infinity, 0.5);
                    // Stop the filter movement
                    breathFilter.frequency.cancelScheduledValues(Tone.now());
                    // Move filter to base position after fade out
                    setTimeout(() => {
                        breathFilter.frequency.value = 100;
                    }, 500);
                }

                function playHaptic(type) {
                    const intensity = appState.settings.hapticIntensity / 100; // Normalized 0.0 to 1.0

                    if (!window.navigator.vibrate || intensity === 0) return;

                    const minDuration = 30;
                    const maxDuration = 150;

                    // Calculate dynamic duration based on intensity
                    const baseDuration = minDuration + (intensity * (maxDuration - minDuration));

                    try {
                        if (type === 'cut') {
                            // Quick, sharp tap
                            window.navigator.vibrate(baseDuration);
                        } else if (type === 'breath') {
                            // Gentle, pulsing pattern
                            const hapticPattern = [
                                baseDuration * 1.5, // Inhale pulse
                                baseDuration * 0.5, // Pause
                                baseDuration * 1.5  // Exhale pulse
                            ];
                            window.navigator.vibrate(hapticPattern);
                        }
                    } catch (e) {
                        console.warn("Haptic feedback error:", e);
                    }
                }

                // =================================================================
                // LOGGING AND MODALS
                // =================================================================

                (function setupGuideAutoOpen(){
                  const infoButton = document.getElementById('infoButton');
                  const infoPanel  = document.getElementById('infoPanel');   // or your info modal/container id
                  const guideModal = document.getElementById('guideModal');
                  const closeGuide = document.getElementById('closeGuideModal');

                  if (!guideModal || !infoPanel) return;

                  const openGuide = () => guideModal.classList.remove('hidden');
                  const closeGuideFn = () => guideModal.classList.add('hidden');

                  closeGuide?.addEventListener('click', closeGuideFn);

                  // 1) If Info is opened via the sidebar button:
                  infoButton?.addEventListener('click', () => {
                    // let your existing code open the info panel first, then show Guide
                    setTimeout(openGuide, 50);
                  });

                  // 2) If Info is opened by other triggers (menu, keyboard, etc.),
                  //    watch for the "hidden" class being removed:
                  const obs = new MutationObserver(() => {
                    const isOpen = !infoPanel.classList.contains('hidden');
                    if (isOpen) openGuide();
                  });
                  obs.observe(infoPanel, { attributes: true, attributeFilter: ['class'] });
                })();


                        function logMLChange(type, amount, detail, emotion = null, trigger = null) {
                    appState.mlHistory.push({
                        timestamp: Date.now(),
                        type: type,
                        amount: amount,
                        detail: detail,
                        emotion: emotion,
                        trigger: trigger
                    });
                    if (appState.mlHistory.length > 100) {
                        appState.mlHistory.shift();
                    }
                    // NEW: Update streak status on any successful log entry
                    checkAndUpdateStreak();
                    triggerSave();
                }

                function formatLogTime(timestamp) {
                    const date = new Date(timestamp);
                    return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                }

                function updateLogModal() {
                    let totalMLIn = 0, totalMLOut = 0, cutCount = 0, reliefCount = 0, challengeCount = 0, undoCount = 0, noteCount = 0, quickLogCount = 0, positiveActionCount = 0;

                    appState.mlHistory.forEach(entry => {
                        if (entry.amount > 0) totalMLIn += entry.amount;
                        else if (entry.amount < 0) totalMLOut += entry.amount;

                        if (entry.type === 'cut') cutCount++;
                        else if (entry.type === 'breath') reliefCount++;
                        else if (entry.type === 'challenge') challengeCount++;
                        else if (entry.type === 'undo') undoCount++;
                        else if (entry.type === 'note') noteCount++;
                        else if (entry.type === 'quick_log') quickLogCount++;
                        else if (entry.type === 'positive_action') positiveActionCount++;
                    });
                    const netML = totalMLIn + totalMLOut;
                    const totalReliefEvents = reliefCount + challengeCount + undoCount + quickLogCount;

                    // Format streak display
                    const streakText = getTranslation('logStreak').replace('{count}', appState.currentStreak);


                    logSummaryEl.innerHTML = `
                        <p class="text-lg font-extrabold text-gray-800 border-b border-gray-300 pb-2 mb-2">${streakText}</p>
                        <p><span class="font-bold text-gray-700">${getTranslation('logSummaryAccumulation')}</span> <span class="text-red-700 font-extrabold">${(totalMLIn / ML_DISPLAY_FACTOR).toFixed(1)} ml</span> (${cutCount} ${getTranslation('logDrips')})</p>
                        <p><span class="font-bold text-gray-700">${getTranslation('logSummaryRelief')}</span> <span class="text-green-700 font-extrabold">${(totalMLOut / ML_DISPLAY_FACTOR).toFixed(1)} ml</span> (${totalReliefEvents} relief actions)</p>
                        <p class="text-sm text-gray-500 mt-1">Breaths: ${reliefCount}, Challenges: ${challengeCount}, Quick Logs: ${quickLogCount}, Positive Actions: ${positiveActionCount}, Undos: ${undoCount}</p>
                        <p class="mt-4 text-xl font-extrabold text-center">${getTranslation('logSummaryNet')} <span class="${netML >= 0 ? 'text-red-700' : 'text-green-700'}">${(netML / ML_DISPLAY_FACTOR).toFixed(1)} ml</span></p>
                    `;

                    logDetailsEl.innerHTML = '';

                    const combinedHistory = [...appState.mlHistory];
                    combinedHistory.sort((a, b) => b.timestamp - a.timestamp);

                    combinedHistory.forEach(entry => {
                        const mlValue = (entry.amount / ML_DISPLAY_FACTOR).toFixed(2);
                        const mlClass = entry.amount > 0 ? 'text-red-600 font-bold' : (entry.amount < 0 ? 'text-green-600 font-bold' : 'text-gray-500');

                        let actionText, rowClass = "hover:bg-gray-50";

                        if (entry.type === 'cut') actionText = getTranslation('logActionCut');
                        else if (entry.type === 'breath') actionText = getTranslation('logActionBreath');
                        else if (entry.type === 'challenge') actionText = getTranslation('logActionChallenge');
                        else if (entry.type === 'undo') actionText = getTranslation('logActionUndo');
                        else if (entry.type === 'reset') actionText = getTranslation('logActionReset');
                        else if (entry.type === 'quick_log') { actionText = `<strong>${getTranslation('logActionQuick')}:</strong> <span class="italic text-gray-600">"${entry.detail}"</span>`; rowClass = "bg-blue-50 hover:bg-blue-100"; }
                        else if (entry.type === 'positive_action') { actionText = `<strong>${getTranslation('logActionPositive')}:</strong> <span class="italic text-gray-600">"${entry.detail}"</span>`; rowClass = "bg-green-50 hover:bg-green-100"; }
                        else if (entry.type === 'note') { actionText = `<strong>${getTranslation('logActionNote')}:</strong> <span class="italic text-gray-600">"${entry.detail}"</span>`; rowClass = "bg-yellow-50 hover:bg-yellow-100"; }
                        else actionText = entry.type;

                        const mlDisplay = (entry.type === 'note' || entry.type === 'quick_log' || entry.type === 'positive_action') ? '---' : `${mlValue} ml`;

                        logDetailsEl.innerHTML += `
                            <tr class="${rowClass}">
                                <td class="py-2 px-3 text-gray-500">${formatLogTime(entry.timestamp)}</td>
                                <td class="py-2 px-3 text-gray-700">${actionText}</td>
                                <td class="py-2 px-3 text-right ${mlClass}">${mlDisplay}</td>
                            </tr>
                        `;
                    });
                }

                function showLogModal() {
                    updateLogModal();
                    logModal.classList.remove('hidden');
                }
                function hideLogModal() { logModal.classList.add('hidden'); }

                // --- micro-check modal open / close ---
        function showMicroCheckModal() {
            if (!microCheckModal) return;

            // Once it's actually showing, it's no longer just "required"
            microCheckRequired = false;
            isMicroCheckActive = true;

            // üîí Pause ML drips while user is writing
            mlDripPaused = true;

            // Reset input state
            if (microCheckResponse) {
                microCheckResponse.value = '';
            }
            if (submitMicroCheckButton) {
                submitMicroCheckButton.disabled = true;
            }

            microCheckModal.classList.remove('hidden');
        }

        function hideMicroCheckModal() {
            if (!microCheckModal) return;

            microCheckModal.classList.add('hidden');
            isMicroCheckActive = false;

            // If we're NOT in the 30s cooldown, we can resume drips now
            if (!microCheckCooldownActive) {
                mlDripPaused = false;   // üîì allow drips again
            }
        }

        //  --- micro-check submit logic ---

        function handleMicroCheckSubmit() {
            const text = microCheckResponse.value.trim();
            if (!text) return;

            // Log this as a neutral ML event (no direct ML change)
            logMLChange('micro_check', 0, text);
            hideMicroCheckModal();

            // Mark as completed so the micro-check only happens once per session
            microCheckCompleted = true;

            // 30-second cooldown where drawing is disabled
            microCheckCooldownActive = true;
            mlDripPaused = true;

            showTemporaryPopup("Drawing is paused for 30 seconds. Try using Affirmations, Challenge, or the breathing exercise to help you cope.");

            setTimeout(() => {
                microCheckCooldownActive = false;
                mlDripPaused = false;
                showTemporaryPopup("You can draw again now.");
            }, 30000);
        }

        // Enable the Continue button only when there is some text
        microCheckResponse.addEventListener('input', () => {
            submitMicroCheckButton.disabled = microCheckResponse.value.trim().length === 0;
        });

        // Submit handler
        submitMicroCheckButton.addEventListener('click', handleMicroCheckSubmit);
                // --- Quick Log Modal Logic ---
                function showQuickLogModal() {
                     // Do not show if other core modals are visible
                    if (!welcomeModal.classList.contains('hidden') || !overloadModal.classList.contains('hidden')) return;

                    quickLogInput.value = '';
                    quickLogModal.classList.remove('hidden');
                    quickLogInput.focus();
                }

                function hideQuickLogModal() {
                    quickLogModal.classList.add('hidden');
                }

                        function saveQuickLog() {
                    const noteText = quickLogInput.value.trim() || 'No detail recorded';

                    const selectedEmotionBtn = document.querySelector('.quick-emotion-btn.selected');
                    const selectedTriggerBtn = document.querySelector('.quick-trigger-btn.selected');
                    const emotion = selectedEmotionBtn ? selectedEmotionBtn.getAttribute('data-emotion') : null;
                    const trigger = selectedTriggerBtn ? selectedTriggerBtn.getAttribute('data-trigger') : null;

                    if (!emotion || !trigger) {
                        showNotification('microPause', 2500);
                    }

                    // Apply relief instantly
                    appState.currentML = Math.max(0, appState.currentML - QUICK_LOG_ML_RELIEF);

                    // Log the action with optional tags
                    logMLChange('quick_log', -QUICK_LOG_ML_RELIEF, noteText, emotion, trigger);

                    updateMeterDisplay();
                    hideQuickLogModal();
                    showNotification('copy', 1500); // Give a brief positive notification
                }

                // --- Positive Action Modal Logic ---
                function showPositiveActionModal() {
                    logModal.classList.add('hidden');
                    positiveActionInput.value = '';
                    positiveActionModal.classList.remove('hidden');
                    positiveActionInput.focus();
                }

                function hidePositiveActionModal() {
                    positiveActionModal.classList.add('hidden');
                    logModal.classList.remove('hidden'); // Return to the log screen
                    updateLogModal(); // Refresh the log
                }

                function savePositiveAction() {
                    const actionText = positiveActionInput.value.trim();
                    if (actionText) {
                        // Log the action with 0 ML change, and apply minor relief
                        appState.currentML = Math.max(0, appState.currentML - POSITIVE_ACTION_ML_RELIEF);
                        logMLChange('positive_action', -POSITIVE_ACTION_ML_RELIEF, actionText);
                        updateMeterDisplay();
                        hidePositiveActionModal();
                        showNotification('heal', 1500);
                    }
                }
        // --- Grounding / Check-Out Modal Logic ---
        function showGroundingModal() {
            if (!groundingModal) return;

            isGroundingActive = true;

            if (groundingCommitInput) {
                groundingCommitInput.value = '';
            }

            groundingModal.classList.remove('hidden');
        }

        function closeGroundingModal(saveCommitment) {
            if (!groundingModal) return;

            groundingModal.classList.add('hidden');
            isGroundingActive = false;

            if (saveCommitment && groundingCommitInput) {
                const commitText = groundingCommitInput.value.trim();
                if (commitText) {
                    // Log as a zero-ML grounding event
                    logMLChange('grounding_checkout', 0, commitText);
                    if (typeof triggerSave === 'function') {
                        triggerSave();
                    }
                }
            }
        }
                // --- Add Note Modal Logic ---
                function showAddNoteModal() {
                    logModal.classList.add('hidden');
                    noteInput.value = '';
                    addNoteModal.classList.remove('hidden');
                    noteInput.focus();
                }
                function hideAddNoteModal() {
                    addNoteModal.classList.add('hidden');
                    logModal.classList.remove('hidden'); // Return to the log screen
                    updateLogModal(); // Refresh the log
                }
                        function saveNote() {
                    const noteText = noteInput.value.trim();
                    if (noteText) {
                        const selectedEmotionBtn = document.querySelector('.note-emotion-btn.selected');
                        const selectedTriggerBtn = document.querySelector('.note-trigger-btn.selected');
                        const emotion = selectedEmotionBtn ? selectedEmotionBtn.getAttribute('data-emotion') : null;
                        const trigger = selectedTriggerBtn ? selectedTriggerBtn.getAttribute('data-trigger') : null;

                        if (!emotion || !trigger) {
                            showNotification('microPause', 2500);
                        }

                        logMLChange('note', 0, noteText, emotion, trigger);
                        hideAddNoteModal();
                    }
                }

                        // --- Emotion & Trigger Tag Selection (Quick Log + Note) ---
                document.addEventListener('click', (e) => {
                    const quickEmotionBtn = e.target.closest('.quick-emotion-btn');
        if (quickEmotionBtn) {
            const group = quickEmotionBtn.closest('div').querySelectorAll('.quick-emotion-btn');

            let emotionValue = quickEmotionBtn.getAttribute('data-emotion');
            const isOther = quickEmotionBtn.classList.contains('emotion-other-btn');

            if (isOther) {
                // Use previous custom value as default if available
                const previous =
                    emotionValue && emotionValue !== 'Other'
                        ? emotionValue
                        : '';

                const custom = prompt(
                    "Type the main emotion you‚Äôre feeling right now (e.g. guilt, grief, frustration):",
                    previous
                );

                // If cancelled or empty, do nothing (keep previous selection)
                if (!custom || !custom.trim()) {
                    return;
                }

                emotionValue = custom.trim();
                quickEmotionBtn.setAttribute('data-emotion', emotionValue);
                quickEmotionBtn.textContent = emotionValue;
            }

            // Now update selection styling
            group.forEach(btn => btn.classList.remove('selected', 'bg-blue-600', 'border-blue-400'));
            quickEmotionBtn.classList.add('selected', 'bg-blue-600', 'border-blue-400');
        }

        const noteEmotionBtn = e.target.closest('.note-emotion-btn');
        if (noteEmotionBtn) {
            const group = noteEmotionBtn.closest('div').querySelectorAll('.note-emotion-btn');

            let emotionValue = noteEmotionBtn.getAttribute('data-emotion');
            const isOther = noteEmotionBtn.classList.contains('emotion-other-btn');

            if (isOther) {
                const previous =
                    emotionValue && emotionValue !== 'Other'
                        ? emotionValue
                        : '';

                const custom = prompt(
                    "Type the main emotion for this note (e.g. guilt, grief, frustration):",
                    previous
                );

                if (!custom || !custom.trim()) {
                    return;
                }

                emotionValue = custom.trim();
                noteEmotionBtn.setAttribute('data-emotion', emotionValue);
                noteEmotionBtn.textContent = emotionValue;
            }

            group.forEach(btn => btn.classList.remove('selected', 'bg-blue-100', 'border-blue-500'));
            noteEmotionBtn.classList.add('selected', 'bg-blue-100', 'border-blue-500');
        }

                });

        // --- Affirmations Modal Logic ---
                function showAffirmationsModal() {
                    updateAffirmationsList();
                    affirmationsModal.classList.remove('hidden');
                }
                function hideAffirmationsModal() { affirmationsModal.classList.add('hidden'); }
                function addAffirmation() {
                    const text = affirmationInput.value.trim();
                    if (text && !appState.userAffirmations.includes(text)) {
                        appState.userAffirmations.push(text);
                        updateAffirmationsList();
                        triggerSave();
                        affirmationInput.value = '';
                    }
                }
                function removeAffirmation(index) {
                    appState.userAffirmations.splice(index, 1);
                    updateAffirmationsList();
                    triggerSave();
                }
                function clearAffirmations() {
                    appState.userAffirmations = [];
                    updateAffirmationsList();
                    triggerSave();
                }
                function updateAffirmationsList() {
                    affirmationsList.innerHTML = '';
                    if (appState.userAffirmations.length === 0) {
                        // FIX: Use getTranslation directly to prevent recursive call to updateLanguage
                        const placeholderText = getTranslation('affirmPlaceholder');
                        affirmationsList.innerHTML = `<li class="p-3 text-gray-500 italic">${placeholderText}</li>`;
                        return;
                    }
                    appState.userAffirmations.forEach((text, index) => {
                        const li = document.createElement('li');
                        li.className = 'p-3 flex justify-between items-center text-gray-800 text-sm md:text-base';
                        li.textContent = text;
                        const removeBtn = document.createElement('button');
                        removeBtn.className = 'ml-4 py-1 px-2 bg-red-100 hover:bg-red-200 text-red-700 text-xs font-semibold rounded-md transition-all';
                        removeBtn.textContent = getTranslation('affirmRemove');
                        removeBtn.onclick = () => removeAffirmation(index);
                        li.appendChild(removeBtn);
                        affirmationsList.appendChild(li);
                    });
                }

                // --- Settings Modal Logic ---
                function showSettingsModal() {
                    settingsModal.classList.remove('hidden');
                }
                function hideSettingsModal() { settingsModal.classList.add('hidden'); }

                // --- Haptic Logic ---
                hapticIntensitySlider.addEventListener('input', (e) => {
                    const intensity = parseInt(e.target.value, 10);
                    appState.settings.hapticIntensity = intensity;
                    hapticIntensityValue.textContent = `${intensity}%`;

                    // Provide a test vibration when the slider is moved (if intensity > 0)
                    if (intensity > 0) {
                        playHaptic('cut');
                    }

                    triggerSave();
                });


                // --- Welcome Modal Logic ---
                function showWelcomeModal() { welcomeModal.classList.remove('hidden'); }
                function hideWelcomeModal() {
                    appState.hasWelcomed = true;
                    welcomeModal.classList.add('hidden');
                }

                // --- Check-in Modal Logic ---
                function showMentalHealthPrompt() {
                    let message = '';
                    const usePersonal = appState.settings.prioritizeAffirmations && appState.userAffirmations.length > 0;

                    if (usePersonal) {
                        const randomIndex = Math.floor(Math.random() * appState.userAffirmations.length);
                        message = appState.userAffirmations[randomIndex];
                    } else {
                        const randomIndex = Math.floor(Math.random() * encouragingMessages.length);
                        message = encouragingMessages[randomIndex];
                    }

                    randomEncouragementEl.textContent = message;
                    checkinModal.classList.remove('hidden');
                }
                function hideMentalHealthPrompt() { checkinModal.classList.add('hidden'); }

                // --- Challenge Logic ---
                function formatTime(seconds) {
                    const min = Math.floor(seconds / 60);
                    const sec = seconds % 60;
                    return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
                }

                // --- prep modal lifecycle ---
    function openChallengePrepWith(challengeTextOrKey) {
        // If a sentinel key came in, resolve it to actual text; otherwise assume it's already text
        const resolved = (challengeTextOrKey === 'focus_challenge')
            ? getTranslation('challengeFocus')     // keep your finger on moving target...
            : challengeTextOrKey;

        currentChallengeKey = challengeTextOrKey; // store what we intend to run
        challengePrepTaskEl.textContent = resolved;

        // show modal with fade
        challengePrepModal.classList.remove('hidden');
        requestAnimationFrame(() => challengePrepModal.classList.remove('opacity-0'));

        startPrepCountdown();
    }

    function closeChallengePrep() {
        challengePrepModal.classList.add('hidden');
        challengePrepModal.classList.add('opacity-0');
        stopPrepCountdown();
    }

    function startPrepCountdown() {
        stopPrepCountdown();
        const seconds = Number(appState?.settings?.challengePrepSeconds ?? CHALLENGE_PREP_SECONDS);
        let remaining = Math.max(0, seconds);
        challengePrepCountdownEl.textContent = remaining;

        // if user sets 0s in settings, allow immediate start
        if (remaining === 0) return;

        challengePrepCountdownTimer = setInterval(() => {
            remaining -= 1;
            challengePrepCountdownEl.textContent = remaining;
            if (remaining <= 0) {
                stopPrepCountdown();
                // auto-start the challenge when countdown finishes
                beginChallengeFromPrep();
            }
        }, 1000);
    }

    function stopPrepCountdown() {
        if (challengePrepCountdownTimer) {
            clearInterval(challengePrepCountdownTimer);
            challengePrepCountdownTimer = null;
        }
    }

    function beginChallengeFromPrep() {
        closeChallengePrep();
        // Hand off to your existing challenge runner:
        // If your app expects the "key" 'focus_challenge', pass it; otherwise pass the text.
        startChallengeFlow(currentChallengeKey);
    }

    // small adapter ‚Äì replace with your actual function name if different
    function startChallengeFlow(keyOrText) {
        // Existing code that shows the main Sensory Challenge modal & timer.
        // If you already have a function (e.g., startSensoryChallenge(...)), call it here instead:
        if (typeof startSensoryChallenge === 'function') {
            startSensoryChallenge(keyOrText);
        } else {
            // Fallback: minimal behavior to avoid crashes
            challengeTaskEl.textContent = (keyOrText === 'focus_challenge')
              ? getTranslation('challengeFocus')
              : getTranslation(keyOrText);
            sensoryChallengeModal.classList.remove('hidden');
        }
    }

                function showSensoryChallenge() {
            // Check if any modal is active
            if (isDrawing || isReliefActive || !checkinModal.classList.contains('hidden') || !welcomeModal.classList.contains('hidden') || !quickLogModal.classList.contains('hidden') || !positiveActionModal.classList.contains('hidden')) return;

            isChallengeActive = true;
        function getAnotherChallengeKey() {
            if (!SENSORY_CHALLENGES.length) return null;

            // If there‚Äôs only one, we can‚Äôt change it
            if (SENSORY_CHALLENGES.length === 1) return SENSORY_CHALLENGES[0];

            let newKey = currentChallengeKey;
            let guard = 0;

            // Try a few times to avoid giving the same challenge again in a row
            while (newKey === currentChallengeKey && guard < 10) {
                newKey = SENSORY_CHALLENGES[Math.floor(Math.random() * SENSORY_CHALLENGES.length)];
                guard++;
            }

            return newKey;
        }
            // Always start with the focus challenge first
            currentChallengeKey = 'focus_challenge';
            const isFocus = true;

// Focus challenge uses its special translation key
challengeTaskEl.textContent = getTranslation('challengeFocus');

    completeChallengeButton.disabled = true;
    completeChallengeButton.classList.add('opacity-50', 'cursor-not-allowed');
    completeChallengeButton.classList.remove('bg-green-600', 'hover:bg-green-700');

    sensoryChallengeModal.classList.remove('hidden');

    // üîÅ NEW: 30s prep popup, then start the actual challenge
    startChallengeWithPrep(isFocus);
        }

                function startChallengeTimer(duration) {
                    let timeLeft = duration;
                    challengeTimerEl.textContent = formatTime(timeLeft);
                    clearInterval(challengeTimerInterval);

                    challengeTimerInterval = setInterval(() => {
                        timeLeft--;
                        challengeTimerEl.textContent = formatTime(timeLeft);
                        if (timeLeft <= 0) {
                            clearInterval(challengeTimerInterval);
                            if (focusTarget) {
                                stopFocusChallenge(true);
                            } else {
                                completeChallengeButton.disabled = false;
                                completeChallengeButton.classList.remove('opacity-50', 'cursor-not-allowed');
                                completeChallengeButton.classList.add('bg-green-600', 'hover:bg-green-700');
                                challengeTimerEl.classList.remove('text-red-500');
                                challengeTimerEl.classList.add('text-green-500');
                                // Show post-relief grounding check-out after a successful challenge
            showGroundingModal();
                            }
                        }
                    }, 1000);
                }
    function cancelChallengePrep() {
        clearTimeout(challengePrepTimer);
        clearInterval(challengePrepCountdownTimer);

        if (challengePrepModal) {
            // Hide + reset fade
            challengePrepModal.classList.add('opacity-0');
            challengePrepModal.classList.remove('opacity-100');
            challengePrepModal.classList.add('hidden');
        }
    }

    function startChallengeWithPrep(isFocus) {
    // Stop any previous prep
    cancelChallengePrep();

    // Get user-configured prep seconds (fallback to constant)
    const prepSeconds = (
        appState &&
        appState.settings &&
        typeof appState.settings.challengePrepSeconds === 'number'
    )
        ? appState.settings.challengePrepSeconds
        : CHALLENGE_PREP_SECONDS;

    // üîπ NEW: Focus challenge ALWAYS starts immediately, ignoring prep setting
    if (isFocus) {
        // Moving target challenge
        startFocusChallenge();
        startChallengeTimer(FOCUS_CHALLENGE_DURATION / 1000);
        return;
    }

    // If user set 0s, skip the prep popup entirely for non-focus challenges
    if (prepSeconds <= 0) {
        // Normal text-based challenge
        startChallengeTimer(CHALLENGE_TIME_SECONDS);
        return;
    }

    // üîπ Copy the challenge text into the prep popup
    if (challengePrepTaskEl && challengeTaskEl) {
        challengePrepTaskEl.textContent = challengeTaskEl.textContent;
    }

    // Set up countdown in popup
    let timeLeft = prepSeconds;
    if (challengePrepCountdownEl) {
        challengePrepCountdownEl.textContent = timeLeft;
    }

    if (challengePrepModal) {
        // Show modal
        challengePrepModal.classList.remove('hidden');

        // Force a reflow so the opacity transition works
        void challengePrepModal.offsetWidth;

        // Fade in
        challengePrepModal.classList.remove('opacity-0');
        challengePrepModal.classList.add('opacity-100');
    }

    // Update the countdown each second
    challengePrepCountdownTimer = setInterval(() => {
        timeLeft--;
        if (challengePrepCountdownEl && timeLeft >= 0) {
            challengePrepCountdownEl.textContent = timeLeft;
        }
        if (timeLeft <= 0) {
            clearInterval(challengePrepCountdownTimer);
        }
    }, 1000);

    // After prepSeconds, hide popup and start the REAL challenge timer
    challengePrepTimer = setTimeout(() => {
        cancelChallengePrep();

        // Here it's always a non-focus challenge (focus already returned above)
        startChallengeTimer(CHALLENGE_TIME_SECONDS);
    }, prepSeconds * 1000);
}



                function completeChallenge() {
        if (completeChallengeButton.disabled) return;
        clearInterval(challengeTimerInterval);
        appState.currentML -= ML_REDUCTION_PER_CHALLENGE;
        logMLChange('challenge', -ML_REDUCTION_PER_CHALLENGE, 'Sensory Challenge Complete');
        updateMeterDisplay();
        sensoryChallengeModal.classList.add('hidden');
        isChallengeActive = false;
        challengeTimerEl.classList.add('text-red-500');
        challengeTimerEl.classList.remove('text-green-500');

        // ‚úÖ Transition into the grounding check-out
        showGroundingModal();
    }

    //small helper to clean up the focus circle
    function cleanupFocusTargetForReroll() {
        // Only used when skipping/changing challenges
        if (!focusTarget) return;

        // Stop the target movement
        clearInterval(focusTimer);

        // Remove its event listeners
        if (focusTarget.cleanup) {
            focusTarget.cleanup();
        }

        // Remove the circle from the page
        document.body.removeChild(focusTarget);
        focusTarget = null;
    }

        function requestAnotherChallenge() {
        // Only do anything if the challenge modal is actually open
        if (sensoryChallengeModal.classList.contains('hidden')) return;

        // Stop current countdown and any prep that might be running
        clearInterval(challengeTimerInterval);
        cancelChallengePrep();

        // ‚úÖ Use the helper instead of duplicating logic
        cleanupFocusTargetForReroll();

        // Pick a new challenge
        if (!SENSORY_CHALLENGES.length) return;

        let newKey = SENSORY_CHALLENGES[Math.floor(Math.random() * SENSORY_CHALLENGES.length)];

        // Avoid repeating the exact same one if possible
        if (typeof currentChallengeKey !== 'undefined' && SENSORY_CHALLENGES.length > 1) {
            let guard = 0;
            while (newKey === currentChallengeKey && guard < 10) {
                newKey = SENSORY_CHALLENGES[Math.floor(Math.random() * SENSORY_CHALLENGES.length)];
                guard++;
            }
        }

        currentChallengeKey = newKey;

        // Reset timer display state & button
        challengeTimerEl.classList.remove('text-green-500');
        challengeTimerEl.classList.add('text-red-500');

        completeChallengeButton.disabled = true;
        completeChallengeButton.classList.add('opacity-50', 'cursor-not-allowed');
        completeChallengeButton.classList.remove('bg-green-600', 'hover:bg-green-700');

        const isFocus = currentChallengeKey === 'focus_challenge';

        if (isFocus) {
            challengeTaskEl.textContent = getTranslation('challengeFocus');
        } else {
            challengeTaskEl.textContent = getTranslation(currentChallengeKey);
        }

        // 30s prep before starting the new challenge
        startChallengeWithPrep(isFocus);
    }



                function cancelChallenge() {
                clearInterval(challengeTimerInterval);
                cancelChallengePrep(); // stop the 30s prep if it‚Äôs running
                stopFocusChallenge(false); // Stop focus game if running
                sensoryChallengeModal.classList.add('hidden');
                isChallengeActive = false;
                challengeTimerEl.classList.add('text-red-500');
                challengeTimerEl.classList.remove('text-green-500');
                showMentalHealthPrompt();
            }

                function startFocusChallenge() {
                    if (focusTarget) return; // Already running
                    focusTarget = document.createElement('div');
                    focusTarget.id = 'focusTarget';
                    document.body.appendChild(focusTarget);

                    focusTimeElapsed = 0;
                    let targetX = Math.random() * (window.innerWidth - 60);
                    let targetY = Math.random() * (window.innerHeight - 60);
                    focusTarget.style.transform = `translate(${targetX}px, ${targetY}px)`;

                    // Move target periodically
                    focusTimer = setInterval(() => {
                        targetX = Math.random() * (window.innerWidth - 60);
                        targetY = Math.random() * (window.innerHeight - 60);
                        focusTarget.style.transform = `translate(${targetX}px, ${targetY}px)`;
                    }, 1000);

                    // Track mouse/touch
                    const onFocusMove = (e) => {
                        if (!focusTarget) return;
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                        const rect = focusTarget.getBoundingClientRect();

                        if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
                            focusTarget.classList.add('success');
                            focusTimeElapsed += 100; // Increment time
                            if (focusTimeElapsed >= FOCUS_CHALLENGE_DURATION) {
                                // Success handled by timer logic
                            }
                        } else {
                            focusTarget.classList.remove('success');
                            focusTimeElapsed = 0; // Reset time
                        }
                    };

                    window.addEventListener('mousemove', onFocusMove);
                    window.addEventListener('touchmove', onFocusMove, { passive: false });

                    // Store cleanup function
                    focusTarget.cleanup = () => {
                        window.removeEventListener('mousemove', onFocusMove);
                        window.removeEventListener('touchmove', onFocusMove);
                    };
                }

                function stopFocusChallenge(success) {
                    if (!focusTarget) return;

                    clearInterval(challengeTimerInterval);
                    clearInterval(focusTimer);
                    focusTarget.cleanup(); // Remove event listeners
                    document.body.removeChild(focusTarget);
                    focusTarget = null; // CRITICAL: Reset the variable

                    if (success) {
                        appState.currentML -= ML_REDUCTION_PER_CHALLENGE;
                        logMLChange('challenge', -ML_REDUCTION_PER_CHALLENGE, 'Focus Challenge Complete');
                        updateMeterDisplay();
                    // ‚úÖ Grounding after a successful focus challenge
            showGroundingModal();
        }

                    sensoryChallengeModal.classList.add('hidden');
                    isChallengeActive = false;
                    challengeTimerEl.classList.add('text-red-500');
                    challengeTimerEl.classList.remove('text-green-500');

                    if (!success) {
                        showMentalHealthPrompt();
                    }
                }


                // --- Main Action Handlers ---
                function clearCuts() {
                    if (isChallengeActive) return;
                    if (appState.currentML > 0) {
                        logMLChange('reset', -appState.currentML, 'Full canvas cleared');
                    }
                    appState.cuts = [];
                    appState.healLines = [];
                    appState.history = [];
                    appState.mlHistory = [];
                    activeDrips = [];
                    appState.currentML = 0;
                    strokesSinceLastPrompt = 0;
                    hideMentalHealthPrompt();
                    redrawStaticContent();
                    if (!isDrawing) draw();
                    triggerSave();
                }

                function undoLastCut() {
                    if (isChallengeActive) return;
                    if (appState.history.length === 0) return;

                    const lastStroke = appState.history.pop();
                    const strokeType = lastStroke.type;
                    const strokeIdToRemove = lastStroke.id;

                    if (strokeType === 'cut') {
                        const cutIndex = appState.cuts.findIndex(c => c.id === strokeIdToRemove);
                        if (cutIndex > -1) {
                            const cut = appState.cuts.splice(cutIndex, 1)[0];
                            const mlRemoved = cut.totalML || 0;
                            appState.currentML -= mlRemoved;
                            logMLChange('undo', -mlRemoved, `Undone Cut ID ${cut.id}`);
                            activeDrips = activeDrips.filter(drip => drip.cutId !== strokeIdToRemove);
                        }
                    } else if (strokeType === 'heal') {
                        const healIndex = appState.healLines.findIndex(h => h.id === strokeIdToRemove);
                        if (healIndex > -1) {
                            appState.healLines.splice(healIndex, 1);
                        }
                    }

                    redrawStaticContent();
                    draw();
                    triggerSave();
                }

                function updateModeButton() {
                    const lang = appState.settings.language;
                    if (isHealMode) {
                        modeToggleButton.querySelector('span').textContent = getTranslation('healMode');
                        modeToggleButton.classList.remove('bg-red-700', 'hover:bg-red-600', 'border-red-900', 'hover:border-red-800');
                        modeToggleButton.classList.add('bg-amber-400', 'hover:bg-amber-300', 'text-gray-900', 'border-amber-600', 'hover:border-amber-500');
                    } else {
                        modeToggleButton.querySelector('span').textContent = getTranslation('cutMode');
                        modeToggleButton.classList.remove('bg-amber-400', 'hover:bg-amber-300', 'text-gray-900', 'border-amber-600', 'hover:border-amber-500');
                        modeToggleButton.classList.add('bg-red-700', 'hover:bg-red-600', 'border-red-900', 'hover:border-red-800', 'text-white');
                    }
                }

                // --- Relief Logic ---
                function startRelief() {
                    // CRITICAL FIX: Prevent re-entry if relief is already active
                    if (isChallengeActive || isReliefActive) return;

                    // If any modal related to logging/coping is open, hide it
                    if (!overloadModal.classList.contains('hidden')) {
                        overloadModal.classList.add('hidden');
                    }
                     if (!quickLogModal.classList.contains('hidden')) {
                        quickLogModal.classList.add('hidden');
                    }
                     if (!positiveActionModal.classList.contains('hidden')) {
                        positiveActionModal.classList.add('hidden');
                    }


                    isReliefActive = true;
                    reliefMLDrained = 0;
                    breathButton.classList.add('bg-emerald-700', 'animate-pulse');

                    // Start Guided Breathing
                    breathOverlay.classList.add('visible');
                    startBreathSound();
                    playHaptic('breath');
                    breathState = 0;
                    breathText.textContent = getTranslation('breatheIn');
                    breathText.classList.add('visible');
                    breathCircle.classList.remove('breathe-out'); // Ensure it's ready to expand
                    breathCircle.classList.add('breathe-in');
                    updateBreathSound(0); // Initial sound setting

                    clearInterval(breathInterval);
                    breathInterval = setInterval(() => {
                        breathState = (breathState + 1) % 4;
                        breathText.classList.remove('visible');
                        updateBreathSound(breathState); // Update sound filter based on new state

                        // We add a slight delay for the text to fade in *after* the state change
                        setTimeout(() => {
                            if (breathState === 0) { // In
                                breathText.textContent = getTranslation('breatheIn');
                                breathCircle.classList.add('breathe-in');
                                breathCircle.classList.remove('breathe-out');
                            } else if (breathState === 1) { // Hold
                                breathText.textContent = getTranslation('breatheHold');
                            } else if (breathState === 2) { // Out
                                breathText.textContent = getTranslation('breatheOut');
                                breathCircle.classList.add('breathe-out');
                                breathCircle.classList.remove('breathe-in');
                            } else { // Hold
                                breathText.textContent = getTranslation('breatheHold');
                            }
                            breathText.classList.add('visible');
                        }, 500); // This delay matches the text fade-out time

                    }, 4000); // 4-second intervals
                }

                function endRelief() {
            if (!isReliefActive) return;
            clearInterval(breathInterval);
            isReliefActive = false;
            breathButton.classList.remove('bg-emerald-700', 'animate-pulse');

            breathOverlay.classList.remove('visible');
            breathCircle.classList.remove('breathe-in');
            breathCircle.classList.add('breathe-out');
            breathText.classList.remove('visible');
            stopBreathSound();

            if (reliefMLDrained > 0) {
                logMLChange('breath', -reliefMLDrained, 'Take a Breath Session');
                triggerSave();
            }
            reliefMLDrained = 0;

            // ‚úÖ After a successful breathing session, guide into grounding
            showGroundingModal();
        }

                // --- Input Handlers (Event listeners defined below) ---
                function onMouseDown(e) {
                    if (e.button !== 0) return; // Only left click
                     //  Block drawing during micro-check cooldown (mouse)
            if (microCheckCooldownActive) {
                showTemporaryPopup(
                    "Drawing is resting for 30 seconds after your check-in. Try Affirmations, Challenge, or the breathing exercise meanwhile."
                );
                return;
            }
                    // Check if any modal is active
                    if (isChallengeActive || !overloadModal.classList.contains('hidden') || !welcomeModal.classList.contains('hidden') || !emailSelectModal.classList.contains('hidden') || !quickLogModal.classList.contains('hidden') || !positiveActionModal.classList.contains('hidden')) {
                        return;
                    }

                    // First interaction: unlock audio
                    if (audioMuted) initializeAudio();

                    // Check if 100% ML
                    if (appState.currentML >= MAX_ML) {
                        overloadModal.classList.remove('hidden');
                        return;
                    }

                    // Also prevent drawing during breath session
                    if (isReliefActive) return;

                    isDrawing = true;
                    startPoint = { x: e.clientX, y: e.clientY };
                    endPoint = startPoint;
                    currentStrokePoints = [startPoint];
                }

                function onTouchStart(e) {
                // üîí Block drawing during micro-check cooldown (touch)
            if (microCheckCooldownActive) {
                e.preventDefault();
                showTemporaryPopup(
                    "Drawing is resting for 30 seconds after your check-in. Try Affirmations, Challenge, or the breathing exercise meanwhile."
                );
                return;
            }

                    if (isChallengeActive || !overloadModal.classList.contains('hidden') || !welcomeModal.classList.contains('hidden') || !emailSelectModal.classList.contains('hidden') || !quickLogModal.classList.contains('hidden') || !positiveActionModal.classList.contains('hidden')) {
                        return;
                    }

                    // First interaction: unlock audio
                    if (audioMuted) initializeAudio();

                    // Check if 100% ML
                    if (appState.currentML >= MAX_ML) {
                        overloadModal.classList.remove('hidden');
                        return;
                    }

                    // Also prevent drawing during breath session
                    if (isReliefActive) return;

                    e.preventDefault();
                    isDrawing = true;
                    const touch = e.touches[0];
                    startPoint = { x: touch.clientX, y: touch.clientY };
                    endPoint = startPoint;
                    currentStrokePoints = [startPoint];
                }

                function onMouseMove(e) {
                // üîí Block drawing during micro-check cooldown
            if (microCheckCooldownActive) {
                showTemporaryPopup(
                    "Drawing is resting for 30 seconds after your check-in. Try Affirmations, Challenge, or the breathing exercise meanwhile."
                );
                return;
            }
                    if (!isDrawing) return;
                    endPoint = { x: e.clientX, y: e.clientY };
                    if (isHealMode) {
                        currentStrokePoints.push(endPoint);
                    } else {
                        currentStrokePoints = [startPoint, endPoint];
                    }
                    draw();
                }

                function onTouchMove(e) {
                    if (!isDrawing) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    endPoint = { x: touch.clientX, y: touch.clientY };
                    if (isHealMode) {
                        currentStrokePoints.push(endPoint);
                    } else {
                        currentStrokePoints = [startPoint, endPoint];
                    }
                    draw();
                }

                function finalizeStroke() {
                    if (!isDrawing || isChallengeActive || isReliefActive) return;
                    isDrawing = false;

                    const strokeLength = calculatePathLength(currentStrokePoints);
                    if (strokeLength < 10) { // Ignore tiny accidental clicks
                        currentStrokePoints = [];
                        draw(); // Clear active canvas
                        return;
                    }

                    strokeIdCounter++;
                    if (isHealMode) {
                        // --- HEAL MODE LOGIC ---
                        playSound('heal');
                        // NEW: count heal strokes and show message after 2 strokes (anywhere)
                        healStrokeCountThisSession += 1;
                        if (!appState.hasHealedOnce && healStrokeCountThisSession >= 4) {
                            showNotification('heal', 7000);
                            appState.hasHealedOnce = true;
                        }
                        const newHeal = {
                            id: strokeIdCounter,
                            type: 'heal',
                            points: currentStrokePoints,
                        };
                        appState.healLines.push(newHeal);
                        appState.history.push({ id: strokeIdCounter, type: 'heal' });

                        const cutsInfluencedThisStroke = new Set();
                        for (let i = appState.cuts.length - 1; i >= 0; i--) {
                            const cut = appState.cuts[i];
                            const cutMidX = (cut.start.x + cut.end.x) / 2;
                            const cutMidY = (cut.start.y + cut.end.y) / 2;
                            let isNearCut = false;
                            for (const healPoint of currentStrokePoints) {
                                const distance = Math.sqrt(
                                    Math.pow(cutMidX - healPoint.x, 2) +
                                    Math.pow(cutMidY - healPoint.y, 2)
                                );
                                if (distance < HEALING_RADIUS) {
                                    isNearCut = true;
                                    break;
                                }
                            }
                            if (isNearCut) {
                                if (!cutsInfluencedThisStroke.has(cut.id)) {
                                    cut.currentHealStrokes++;
                                    cutsInfluencedThisStroke.add(cut.id);
                                }
                                if (cut.currentHealStrokes >= cut.requiredHealStrokes) {
                                    if (!PRESERVE_TENSION_ON_CUT_HEAL) {
                                        appState.currentML -= cut.totalML || 0;
                                    }
                                    appState.cuts.splice(i, 1);
                                    activeDrips = activeDrips.filter(drip => drip.cutId !== cut.id);

                                    // Show "Heal Metaphor" notification
                                    if (!appState.hasHealedOnce) {
                                        showNotification('heal', 7000);
                                        appState.hasHealedOnce = true;
                                    }
                                }
                            }
                        }
                        redrawStaticContent();
                        drawHealLineSegments(staticCtx, newHeal);
                    } else {
                        // --- CUT MODE LOGIC ---
                        playSound('cut');
                        playHaptic('cut');
                        if (appState.cuts.length >= MAX_PERMANENT_CUTS) {
                            const oldestCut = appState.cuts.shift();
                            activeDrips = activeDrips.filter(drip => drip.cutId !== oldestCut.id);
                            redrawStaticContent();
                        }
                        const newCut = {
                            id: strokeIdCounter,
                            type: 'cut',
                            start: startPoint,
                            end: endPoint,
                            smoothPoints: generateTaperedPoints(startPoint, endPoint, SEGMENTS),
                            lastDripTime: -BASE_DRIP_COOLDOWN_MS,
                            completedTrails: [],
                            pools: [],
                            totalML: 0,
                            requiredHealStrokes: Math.floor(Math.random() * (MAX_HEAL_STROKES - MIN_HEAL_STROKES + 1)) + MIN_HEAL_STROKES,
                            currentHealStrokes: 0,
                        };
                        appState.cuts.push(newCut);
                        appState.history.push({ id: strokeIdCounter, type: 'cut' });
                        redrawStaticContent();
                        strokesSinceLastPrompt++;
                        if (strokesSinceLastPrompt >= MAX_CUTS_BEFORE_PROMPT) {
                            showMentalHealthPrompt();
                            strokesSinceLastPrompt = 0;
                        }
                    }

                    startPoint = null;
                    endPoint = null;
                    currentStrokePoints = [];
                    updateMeterDisplay();
                    draw();
                    logMLChange('cut', 0, 'New Cut Drawn'); // Log the cut to trigger streak check
                    // Note: ML is added inside draw loop for cuts, but we log here to catch the activity.
                    triggerSave(); // Queue a save
                }


                // --- Export Functions ---
                function getSessionSummary() {
                    let totalMLIn = 0, totalMLOut = 0, cutCount = 0, reliefCount = 0, challengeCount = 0, undoCount = 0;
                    appState.mlHistory.forEach(entry => {
                        if (entry.amount > 0) totalMLIn += entry.amount;
                        else if (entry.amount < 0) totalMLOut += entry.amount;
                        if (entry.type === 'cut') cutCount++;
                        if (entry.type === 'breath') reliefCount++;
                        if (entry.type === 'challenge') challengeCount++;
                        if (entry.type === 'undo') undoCount++;
                    });
                    const netML = totalMLIn + totalMLOut;

                    const summary = `
        Session Summary for "Cut Me Instead of You"
        Generated: ${new Date().toLocaleString()}
        Streak: ${appState.currentStreak} Day(s)
        ------------------------------------------------
        Current Mental Load: ${(appState.currentML / ML_DISPLAY_FACTOR).toFixed(1)} ml / ${(MAX_ML / ML_DISPLAY_FACTOR).toFixed(1)} ml

        SESSION TOTALS:
        - Total Accumulated: ${(totalMLIn / ML_DISPLAY_FACTOR).toFixed(1)} ml (${cutCount} drips)
        - Total Relieved: ${(totalMLOut / ML_DISPLAY_FACTOR).toFixed(1)} ml (${reliefCount} breaths, ${challengeCount} challenges, ${undoCount} undos)
        - Net Change: ${(netML / ML_DISPLAY_FACTOR).toFixed(1)} ml

        SESSION LOG:
        ${appState.mlHistory.map(entry => {
            if (entry.type === 'note' || entry.type === 'quick_log' || entry.type === 'positive_action') {
                let typeLabel = getTranslation(entry.type === 'note' ? 'logActionNote' : entry.type === 'quick_log' ? 'logActionQuick' : 'logActionPositive').split('(')[0].trim().toUpperCase();
                return `[${formatLogTime(entry.timestamp)}] ${typeLabel}: ${entry.detail}`;
            }
            const mlValue = (entry.amount / ML_DISPLAY_FACTOR).toFixed(2);
            return `[${formatLogTime(entry.timestamp)}] ${entry.type.padEnd(10, ' ')} | ${mlValue} ml`;
        }).join('\n')}
                    `;
                    return summary.trim();
                }

                function exportToPdf() {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();
                    const summary = getSessionSummary();

                    doc.setFont("helvetica", "normal");
                    doc.setFontSize(10);
                    doc.text(summary, 10, 10);
                    doc.save("CMIOY_Session_Report.pdf");
                }

                function exportToCsv() {
                    const data = appState.mlHistory.map(entry => ({
                        timestamp: new Date(entry.timestamp).toISOString(),
                        time: formatLogTime(entry.timestamp),
                        action_type: entry.type,
                        ml_change: (entry.amount / ML_DISPLAY_FACTOR).toFixed(3),
                        detail: entry.detail || ''
                    }));
                    const csv = Papa.unparse(data);
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement("a");
                    const url = URL.createObjectURL(blob);
                    link.setAttribute("href", url);
                    link.setAttribute("download", "CMIOY_Session_Log.csv");
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }

                // --- New Email Selection Logic ---
                function showEmailSelectModal() {
                    logModal.classList.add('hidden'); // Hide the log modal first
                    emailSelectModal.classList.remove('hidden');
                }

                function handleEmailExport(clientType) {
                    const summary = getSessionSummary();
                    const subject = encodeURIComponent('Session Report - Cut Me Instead of You');
                    const body = encodeURIComponent('Please paste the session summary below (Ctrl+V / Cmd+V).');
                    let uri;

                    // 1. Copy summary to clipboard first (Crucial for mobile)
                    try {
                        navigator.clipboard.writeText(summary).then(() => {
                            showNotification('email');

                            // 2. Adjust URI based on client selection
                            if (clientType === 'gmail') {
                                uri = `https://mail.google.com/mail/u/0/?view=cm&fs=1&su=${subject}&body=${body}`;
                            } else if (clientType === 'outlook') {
                                // NOTE: mailto is often more reliable than ms-outlook on generic browsers
                                uri = `mailto:?subject=${subject}&body=${body}`;
                            } else {
                                // Default mailto:
                                uri = `mailto:?subject=${subject}&body=${body}`;
                            }

                            // 3. Open link
                            window.open(uri, '_blank');

                            hideEmailSelectModal();

                        }).catch(err => {
                            console.error('Failed to copy text:', err);
                            // Use simple mailto if copy failed
                            window.open(`mailto:?subject=${subject}&body=${body}`, '_blank');
                            hideEmailSelectModal();
                        });
                    } catch (err) {
                        console.error('Clipboard access denied:', err);
                        // Fallback if clipboard access fails entirely
                        window.open(`mailto:?subject=${subject}&body=${body}`, '_blank');
                        hideEmailSelectModal();
                    }
                }

                function hideEmailSelectModal() {
                    emailSelectModal.classList.add('hidden');
                    logModal.classList.remove('hidden'); // Re-show log modal for context
                }

                function exportToCopy() {
                    const summary = getSessionSummary();
                    try {
                        navigator.clipboard.writeText(summary).then(() => {
                            showNotification('copy');
                        });
                    } catch (err) {
                        console.error('Failed to copy:', err);
                    }
                }

                // --- Notification Helpers ---
                function showNotification(type, duration = 3000) {
                    let element, text;
                    if (type === 'heal') {
                        element = healNotification;
                    } else {
                        element = notificationBox;
                        if (type === 'copy') text = getTranslation('notifyCopied');
                        if (type === 'email') text = getTranslation('notifyEmail');
                        notificationText.textContent = text;
                    }

                    element.classList.remove('hidden', 'translate-x-full');
                    element.classList.add('translate-x-0');

                    setTimeout(() => {
                        element.classList.remove('translate-x-0');
                        element.classList.add('translate-x-full');
                        setTimeout(() => element.classList.add('hidden'), 300);
                    }, duration);
                }

                // === Splash Screen Dismissal ===

                function dismissSplashScreen(e) {
                    // Prevent accidental triggering from button clicks (only allow direct body/div/html taps)
                    if (e && e.target.tagName !== 'DIV' && e.target.tagName !== 'BODY' && e.target.tagName !== 'HTML') return;

                    if (splashScreen.classList.contains('fade-out')) return;

                    if (splashTimerId) {
                        clearTimeout(splashTimerId);
                    }
                    splashScreen.classList.add('fade-out');

                    // Immediately change pointer events to auto to allow interaction behind the splash
                    splashScreen.style.pointerEvents = 'none';

                    // Remove listeners immediately to prevent accidental re-triggering
                    document.body.removeEventListener('mousedown', dismissSplashScreen);
                    document.body.removeEventListener('touchstart', dismissSplashScreen);

                    setTimeout(() => {
                        splashScreen.classList.add('hidden');
                        // Show welcome modal once splash is gone
                        welcomeModal.classList.remove('hidden');
                    }, 1000);
                }

                // === App Initialization Sequence ===
                function initSequence() {
                    try {
                        // 1. Initial UI Setup (Theme and Canvas)
                        loadTheme();
                        resizeCanvas();
                        // draw() is called inside resizeCanvas, so we skip it here.
                        updateLanguage(appState.settings.language);

                        // 2. Start Splash Screen Timer
                        splashTimerId = setTimeout(() => {
                            dismissSplashScreen();
                        }, 2500);

                        // 3. Tap-to-Dismiss Listeners (Trigger function only once)
                        // Use capture phase (true) to ensure we catch clicks anywhere on the body
                        document.body.addEventListener('mousedown', dismissSplashScreen, { once: true, capture: true });
                        document.body.addEventListener('touchstart', dismissSplashScreen, { once: true, capture: true });

                        // 4. Initialize Firebase/Persistence
                        // NOTE: This checks for the globally exposed functions from the first script tag.
                        if (typeof window.initializeApp !== 'undefined') {
                            firebaseInit();
                        } else {
                            // Fallback in case the firebase-ready event is needed
                            window.addEventListener('firebase-ready', firebaseInit);
                        }
                    } catch (e) {
                        console.error("Critical error during app init (Startup blocked):", e);
                        // Ensure the app starts even if init fails
                        startLocalApp();
                        dismissSplashScreen(); // Force dismiss splash on hard error
                    }
                }

                // === Event Listeners (Defined after all required functions) ===
                window.addEventListener('resize', resizeCanvas);
        // --- Grounding ---
        if (skipGroundingButton) {
            skipGroundingButton.addEventListener('click', () => closeGroundingModal(false));
        }
        if (confirmGroundingButton) {
            confirmGroundingButton.addEventListener('click', () => closeGroundingModal(true));
        }

                // --- Input Listeners ---
                activeCanvas.addEventListener('mousedown', onMouseDown);
                activeCanvas.addEventListener('mousemove', onMouseMove);
                activeCanvas.addEventListener('mouseup', finalizeStroke);
                activeCanvas.addEventListener('mouseleave', () => { if (isDrawing) finalizeStroke(); });

                activeCanvas.addEventListener('touchstart', onTouchStart, { passive: false });
                activeCanvas.addEventListener('touchmove', onTouchMove, { passive: false });
                activeCanvas.addEventListener('touchend', finalizeStroke);
                activeCanvas.addEventListener('touchcancel', finalizeStroke);

                activeCanvas.addEventListener('contextmenu', (e) => e.preventDefault());


                // --- ML Meter Quick Log Trigger
                mlMeterContainerEl.addEventListener('click', showQuickLogModal);

                // --- Quick Log Listeners
                saveQuickLogButton.addEventListener('click', saveQuickLog);
                cancelQuickLogButton.addEventListener('click', hideQuickLogModal);

                // --- Positive Action Listeners
                logPositiveActionButton.addEventListener('click', showPositiveActionModal);
                savePositiveActionButton.addEventListener('click', savePositiveAction);
                cancelPositiveActionButton.addEventListener('click', hidePositiveActionModal);

                // --- Button Listeners ---
                clearButton.addEventListener('click', clearCuts);
                undoButton.addEventListener('click', undoLastCut);
                themeToggleButton.addEventListener('click', toggleTheme);
                modeToggleButton.addEventListener('click', () => {
                    if (isChallengeActive) return;
                    isHealMode = !isHealMode;
                    updateModeButton();
                });
                // --- Relief Listeners ---
                breathButton.addEventListener('mousedown', startRelief);
                breathButton.addEventListener('mouseup', endRelief);
                breathButton.addEventListener('mouseleave', endRelief);
                breathButton.addEventListener('touchstart', (e) => { e.preventDefault(); startRelief(); }, { passive: false });
                breathButton.addEventListener('touchend', (e) => { e.preventDefault(); endRelief(); });
                breathButton.addEventListener('touchcancel', (e) => { e.preventDefault(); endRelief(); });

                // --- Overload Listeners ---
                overloadBreathButton.addEventListener('click', startRelief);
                overloadChallengeButton.addEventListener('click', () => {
                    overloadModal.classList.add('hidden');
                    showSensoryChallenge();
                });

                // --- Challenge Listeners ---
                challengeButton.addEventListener('click', showSensoryChallenge);
                completeChallengeButton.addEventListener('click', completeChallenge);
                cancelChallengeButton.addEventListener('click', cancelChallenge);
                anotherChallengeButton.addEventListener('click', requestAnotherChallenge);
                if (challengePrepSkipButton) {
                challengePrepSkipButton.addEventListener('click', () => {
                    // Stop the current prep popup
                    cancelChallengePrep();
                    // Reroll to another challenge
                    requestAnotherChallenge();
                });
            }
                if (challengePrepStartButton) {
                    challengePrepStartButton.addEventListener('click', () => {
                        // Stop the 30s countdown if it's running
                        if (challengePrepCountdownTimer) {
                            clearInterval(challengePrepCountdownTimer);
                            challengePrepCountdownTimer = null;
                        }
                        if (challengePrepTimer) {
                            clearTimeout(challengePrepTimer);
                            challengePrepTimer = null;
                        }

                        // Decide which type of challenge to start
                        const isFocus = challengePrepModal && challengePrepModal.dataset.isFocus === 'true';

                        // Hide the Get Ready popup
                        if (challengePrepModal) {
                            challengePrepModal.classList.add('hidden');
                        }

                        // Start the actual challenge immediately
                        if (isFocus) {
                            // Moving target / focus-type challenge
                            startFocusChallenge();
                            startChallengeTimer(FOCUS_CHALLENGE_DURATION / 1000);
                        } else {
                            // Normal grounding challenge
                            startChallengeTimer(CHALLENGE_TIME_SECONDS);
                        }
                    });
                }

            if (challengePrepCancelButton) {
    challengePrepCancelButton.addEventListener('click', () => {
        // Just stop the prep popup and go back to the main challenge screen
        cancelChallengePrep();

        // Make sure the main challenge modal stays visible
        sensoryChallengeModal.classList.remove('hidden');
    });
}
            // Start now -> skip waiting and begin immediately
    challengePrepStartButton?.addEventListener('click', () => {
        beginChallengeFromPrep();
    });

    // Cancel -> close the prep popup without starting
    challengePrepCancelButton?.addEventListener('click', () => {
        closeChallengePrep();
    });

    // Change challenge -> pick a different (non-focus) challenge, reset the 30s timer
    const challengePrepChangeButton = document.getElementById('challengePrepChangeButton');
    challengePrepChangeButton?.addEventListener('click', () => {
        const next = pickRandomNonFocusChallenge();
        if (!next) return;
        // update the task text shown in the prep popup
        currentChallengeKey = next;
        challengePrepTaskEl.textContent = next;

        // restart countdown cleanly
        startPrepCountdown();
    });

                // --- Modal Listeners ---
                closeWelcomeModal.addEventListener('click', hideWelcomeModal);
                closeCheckinModal.addEventListener('click', hideMentalHealthPrompt);
                logButton.addEventListener('click', showLogModal);
                closeLogModal.addEventListener('click', hideLogModal);
                infoButton.addEventListener('click', showWelcomeModal);

                // --- Log Note Listeners ---
                addLogNoteButton.addEventListener('click', showAddNoteModal);
                saveNoteButton.addEventListener('click', saveNote);
                cancelNoteButton.addEventListener('click', hideAddNoteModal);

                // --- Affirmation Listeners ---
                affirmationsButton.addEventListener('click', showAffirmationsModal);
                closeAffirmationsModal.addEventListener('click', hideAffirmationsModal);
                addAffirmationButton.addEventListener('click', addAffirmation);
                clearAffirmationsButton.addEventListener('click', clearAffirmations);
                prioritizeAffirmations.addEventListener('change', (e) => {
                    appState.settings.prioritizeAffirmations = e.target.checked;
                    triggerSave();
                });

                // --- Settings Listeners ---
                settingsButton.addEventListener('click', showSettingsModal);
                closeSettingsModal.addEventListener('click', hideSettingsModal);
                toggleDrips.addEventListener('change', (e) => {
                    appState.settings.enableDrips = e.target.checked;
                    if (!appState.settings.enableDrips) {
                        activeDrips = [];
                    }
                    redrawStaticContent();
                    triggerSave();
                });
                toggleShake.addEventListener('change', (e) => {
                    appState.settings.enableShake = e.target.checked;
                    if (!appState.settings.enableShake) {
                        document.body.classList.remove('shaking');
                    }
                    triggerSave();
                });

                // --- Haptic Listeners ---
                hapticIntensitySlider.addEventListener('input', (e) => {
                    const intensity = parseInt(e.target.value, 10);
                    appState.settings.hapticIntensity = intensity;
                    hapticIntensityValue.textContent = `${intensity}%`;

                    // Provide a test vibration when the slider is moved (if intensity > 0)
                    if (intensity > 0) {
                        playHaptic('cut');
                    }

                    triggerSave();
                });

    // --- Challenge Prep Time Listener ---
    if (challengePrepSlider && challengePrepValue) {
        challengePrepSlider.addEventListener('input', (e) => {
            const seconds = parseInt(e.target.value, 10) || 0;
            appState.settings.challengePrepSeconds = seconds;
            challengePrepValue.textContent = `${seconds}s`;
            triggerSave();
        });
    }

        // --- Language Selector Listener ---
        languageSelector.addEventListener('change', (e) => {
            const newLang = e.target.value;
            appState.settings.language = newLang;
            updateLanguage(newLang);
            triggerSave();
        });

                // --- Export Listeners ---
                exportPdfButton.addEventListener('click', exportToPdf);
                exportCsvButton.addEventListener('click', exportToCsv);
                exportEmailButton.addEventListener('click', showEmailSelectModal);
                exportCopyButton.addEventListener('click', exportToCopy);

                // --- Email Select Listeners ---
                closeEmailSelectModal.addEventListener('click', hideEmailSelectModal);
                emailGmailButton.addEventListener('click', () => handleEmailExport('gmail'));
                emailOutlookButton.addEventListener('click', () => handleEmailExport('outlook'));
                emailMailtoButton.addEventListener('click', () => handleEmailExport('mailto'));


                // Use window.onload to ensure all DOM elements are loaded before calling initSequence
                window.onload = initSequence;
        </script>
        <!-- === Reflection Prompt Banner Add-on (Safe, Standalone) === -->
        <script>
        /* CMIOY Reflection Prompt Add-on (Safe Version)
           - Does NOT change tag selection logic
           - Only shows a small banner when certain emotions are tagged
           - Works with both Quick Log & Add Note tag buttons
        */
        (function () {
            // --- 1. Create banner if needed ---
            function cmioyEnsureReflectionBanner() {
                if (document.getElementById("cmioyReflectionBanner")) return;

                const el = document.createElement("div");
                el.id = "cmioyReflectionBanner";
                el.className =
                    "fixed bottom-6 left-1/2 -translate-x-1/2 max-w-xs w-11/12 " +
                    "bg-gray-900 text-gray-100 text-xs rounded-xl shadow-xl px-3 py-2 " +
                    "border border-gray-600 z-[9999] opacity-0 pointer-events-none " +
                    "transition-opacity duration-300";
                el.innerHTML =
                    '<p id="cmioyReflectionText" class="leading-snug text-[11px]"></p>';
                document.body.appendChild(el);
            }

            // --- 2. Show a reflection prompt for a given emotion ---
            function cmioyShowReflectionPrompt(emotion) {
                const prompts = {
            "Shame":
                "This feeling is about your pain, not your worth. What would you say to someone you cared about if they felt this?",
            "Anger":
                "Your anger is protecting something important. What might it be defending for you right now?",
            "Emptiness":
                "Feeling flat doesn‚Äôt mean you‚Äôre broken. What is one tiny thing that still exists in your world (a sound, a color, a texture)?",
            "Anxiety":
                "Your body is reacting as if there‚Äôs danger. Is there one thing in this moment that feels even a little bit safe?",
            "Sadness":
                "Your sadness shows that something matters to you. What is one small thing this sadness is pointing toward?",
            "Overwhelmed":
                "Everything might feel like too much at once. Is there one tiny piece you can put down or postpone, even just for now?"
        };

                const msg = prompts[emotion];
                if (!msg) return; // no prompt configured for this emotion

                cmioyEnsureReflectionBanner();

                const banner = document.getElementById("cmioyReflectionBanner");
                const textEl = document.getElementById("cmioyReflectionText");
                if (!banner || !textEl) return;

                textEl.textContent = msg;

                // Fade in
                banner.classList.remove("opacity-0");
                banner.classList.add("opacity-100");
                banner.style.pointerEvents = "auto";

                // Fade out after 6s
                setTimeout(() => {
                    banner.classList.add("opacity-0");
                    banner.classList.remove("opacity-100");
                    banner.style.pointerEvents = "none";
                }, 6000);
            }

            // --- 3. Attach reflection logic to existing tag buttons ---
            function cmioyAttachReflectionToEmotionButtons() {
                // We ONLY hook into your tag buttons to avoid breaking anything else
                const buttons = document.querySelectorAll(
                    ".quick-emotion-btn, .note-emotion-btn"
                );

                buttons.forEach((btn) => {
                    // Prevent multiple listeners if called again
                    if (btn.dataset.cmioyReflectionBound === "1") return;
                    btn.dataset.cmioyReflectionBound = "1";

                    btn.addEventListener("click", () => {
                        // Try to read emotion from data-emotion on the button OR inner span
                        let emotion = btn.dataset.emotion;
                        if (!emotion) {
                            const inner = btn.querySelector("[data-emotion]");
                            if (inner) emotion = inner.getAttribute("data-emotion");
                        }
                        if (!emotion) {
                            // last fallback: use visible text
                            emotion = btn.textContent.trim();
                        }

                        cmioyShowReflectionPrompt(emotion);
                    });
                });
            }

            // --- 4. Initialise add-on safely ---
            function cmioyInitReflectionAddon() {
                try {
                    cmioyEnsureReflectionBanner();
                    cmioyAttachReflectionToEmotionButtons();
                } catch (err) {
                    console.warn("CMIOY reflection add-on error:", err);
                }
            }

            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", cmioyInitReflectionAddon);
            } else {
                cmioyInitReflectionAddon();
            }
        })();
        // Lightweight toast-style popup for short messages
        function showTemporaryPopup(message) {
            let popup = document.getElementById('cmioy-temp-popup');

            // Create the popup element once and reuse it
            if (!popup) {
                popup = document.createElement('div');
                popup.id = 'cmioy-temp-popup';
                popup.className = [
                    'fixed',
                    'left-1/2',
                    'bottom-6',
                    'transform',
                    '-translate-x-1/2',
                    'bg-gray-900',
                    'text-white',
                    'px-4',
                    'py-2',
                    'rounded-xl',
                    'shadow-lg',
                    'text-sm',
                    'z-[200]',
                    'opacity-0',
                    'transition-opacity',
                    'duration-200'
                ].join(' ');

                document.body.appendChild(popup);
            }

            popup.textContent = message;
            popup.classList.remove('opacity-0');

            // Clear any previous timer so multiple calls don‚Äôt fight
            if (popup._hideTimeout) {
                clearTimeout(popup._hideTimeout);
            }

            popup._hideTimeout = setTimeout(() => {
                popup.classList.add('opacity-0');
            }, 3500);
        }

        </script><script>
    (() => {
      // Ensure we only wire once even if the file has duplicate blocks
      if (window.__wiredGuide) return;
      window.__wiredGuide = true;

      const infoButton  = document.getElementById('infoButton');
      const guideModal  = document.getElementById('guideModal');
      const closeGuide  = document.getElementById('closeGuideModal');

      function openGuide() {
        if (!guideModal) return;
        guideModal.classList.remove('hidden');
      }
      function closeGuideModal() {
        if (!guideModal) return;
        guideModal.classList.add('hidden');
      }

      if (infoButton) {
        // Open the guide every time Info is opened
        infoButton.addEventListener('click', (e) => {
          // If you still want to show the App Info notice too, uncomment the next line:
          // showWelcomeModal?.();
          openGuide();
        });
      }

      // Safe close hook
      closeGuide?.addEventListener('click', closeGuideModal);

      // Optional: close when clicking backdrop
      guideModal?.addEventListener('click', (e) => {
        if (e.target === guideModal) closeGuideModal();
      });
    })();
    </script>
<script>
  // Centralized app bootstrap
  window.addEventListener("load", () => {
    try {
      if (typeof initSequence === "function") {
        initSequence();
      } else if (typeof startLocalApp === "function") {
        // If initSequence isn't defined for some reason, fall back
        startLocalApp();
      }
    } catch (e) {
      console.error("Init failed, starting local fallback:", e);
      try {
        if (typeof startLocalApp === "function") {
          startLocalApp();
        }
      } catch (_) {}

      try {
        if (typeof dismissSplashScreen === "function") {
          dismissSplashScreen();
        } else {
          const splash = document.getElementById("splashScreen");
          if (splash) splash.classList.add("hidden");
        }
      } catch (_) {
        const splash = document.getElementById("splashScreen");
        if (splash) splash.classList.add("hidden");
      }
    }
  });
</script>
        </body>
        </html>